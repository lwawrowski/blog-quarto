[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Materiały szkoleniowe dla IMGW z języka R",
    "section": "",
    "text": "Wprowadzenie\nSkrypty ze szkolenia\nPolecana literatura:\n\nGarret Grolemund, Hadley Wickham - R for Data Science (polska wersja)\nMarek Gągolewski - Programowanie w języku R. Analiza danych, obliczenia, symulacje.\nJakub Nowosad - Elementarz programisty\nTomasz Zieliński - Poradnik dla sponiewieranych Excelem",
    "crumbs": [
      "Wprowadzenie"
    ]
  },
  {
    "objectID": "01-wprowadzenie.html",
    "href": "01-wprowadzenie.html",
    "title": "1  Wprowadzenie do R i RStudio",
    "section": "",
    "text": "1.1 R\nPrezentacja\nGNU R to interpretowany język programowania oraz środowisko do obliczeń statystycznych i wizualizacji wyników [Wikipedia 2025].\nBazowa wersja R jest do pobrania ze strony r-project.org.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R i RStudio</span>"
    ]
  },
  {
    "objectID": "01-wprowadzenie.html#rstudio",
    "href": "01-wprowadzenie.html#rstudio",
    "title": "1  Wprowadzenie do R i RStudio",
    "section": "1.2 RStudio",
    "text": "1.2 RStudio\nRStudio to zintegrowane środowisko programistyczne (IDE) dla języka R dostępne za darmo na stronie RStudio.\n\nZ R można także korzystać w Microsoft Visual Studio Code.\nDodatkowo rozwijana jest aplikacja Positron zbliżona wyglądem do VSC.\nJeśli nie chcemy instalować R na lokalnym komputerze to można skorzystać z wersji on-line dostępnej pod adresem https://posit.cloud/. W darmowej wersji użytkownik ma do dyspozycji 1 CPU, 1 GB RAM i limitowany do 25 godzin na miesiąc czas wykonywania obliczeń. Trzeba także pamiętać, że dane są wówczas przechowywane na zagranicznych serwerach. Alternatywą może być instalacja RStudio Server na serwerze obliczeniowym w organizacji.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R i RStudio</span>"
    ]
  },
  {
    "objectID": "01-wprowadzenie.html#zasady-korzystania-z-języka-r",
    "href": "01-wprowadzenie.html#zasady-korzystania-z-języka-r",
    "title": "1  Wprowadzenie do R i RStudio",
    "section": "1.3 Zasady korzystania z języka R",
    "text": "1.3 Zasady korzystania z języka R\n\nR jest wrażliwy na wielkość liter\nSeparatorem części dziesiętnej liczby jest kropka\nKatalog roboczy\n\nWażnym pojęciem w R jest katalog roboczy (ang. working directory), który określa gdzie zostaną zapisane pliki, wykresy, zbiory, itp. jeśli nie podamy dokładnej ścieżki do pliku. Katalog roboczy przypisuje się z wykorzystaniem funkcji setwd(\"ścieżka do katalogu\"), a jego wartość można sprawdzić funkcją getwd(). W RStudio przypisanie katalogu roboczego odbywa się w momencie utworzenia projektu.\n\nProjekt\n\nKatalog na dysku, w którym znajdują się wszystkie pliki projektu wraz z plikiem o rozszerzeniu .Rproj skojarzonym z RStudio.\n\nKorzystanie z pomocy\n\nDostęp do pomocy odnośnie wybranej funkcji można uzyskać na dwa sposoby. Pierwszym z nich jest poprzedzenie nazwy funkcji w konsoli znakiem zapytania np. ?getwd lub wywołanie funkcji help na nazwie funkcji help(\"getwd\"). Drugim sposobem jest umieszczenie kursora w dowolnym miejscu nazwy funkcji i wciśnięcie klawisza F1.\nInternet - przede wszystkim stackoverflow.\n\nKomentarze\n\n\nReal programmers don’t comment their code. If it was hard to write it should be hard to understand.\n\nDobrze napisany kod jest czytelny bez komentarzy. W R komentarze rozpoczynają się od symbolu #. Skrót klawiaturowy w RStudio to CTRL + SHIFT + C (do wstawiania i usuwania komentarzy).\n\nPodpowiadanie składni\n\nRStudio ma zaimplementowaną funkcję podpowiadania składni. Listę możliwych funkcji i obiektów wywołuję się klawiszem TAB lub CTRL + SPACJA po wpisaniu co najmniej jednej litery. Kolejne naciśnięcie TAB lub ENTER powoduje uzupełnienie kodu o wybraną funkcję lub obiekt.\n\nWykonywanie programów\n\nProgramy w R możemy tworzyć jako skrypty w pliku tekstowym o rozszerzeniu .R lub wywoływać polecenia bezpośrednio w konsoli. Kod programu napisanego w skrypcie przekazywany jest do konsoli. Gotowość do pracy R sygnalizuje w konsoli znakiem zachęty &gt;. Jeśli podczas wykonywania programu w konsoli pojawi się znak + to oznacza oczekiwanie na kompletny kod - brak domkniętego nawiasu, cudzysłowia, itp.:\n&gt; getwd(\n+ \nW powyższym przykładzie brakuje prawego nawiasu. Dodanie brakującego kodu spowoduje wykonanie przekazanego polecenia. Z kolei wciśnięcie klawisza ESC spowoduje przerwanie wykonywanie programu i powrót do znaku zachęty. Zawartość konsoli można wyczyścić stosując kombinację klawiszy CTRL + L.\n\nPliki \n\nJeśli w pamięci znajdują się jakieś obiekty (zakładka Environment) to RStudio przy zamykaniu programu zapyta o zapisanie tych obiektów do pliku .RData. Jeżeli zdecydujemy się na tą propozycję to po ponownym uruchomieniu projektu obiekty znajdujące się w pliku .RData zostaną automatycznie wczytane do pamięci.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R i RStudio</span>"
    ]
  },
  {
    "objectID": "01-wprowadzenie.html#pakiety",
    "href": "01-wprowadzenie.html#pakiety",
    "title": "1  Wprowadzenie do R i RStudio",
    "section": "1.4 Pakiety",
    "text": "1.4 Pakiety\nPodstawowe możliwości R są dosyć ograniczone. Rozszerzają je pakiety, których obecnie jest ponad 22 tysięcy. Można je przeglądać według kategorii w CRAN Task Views lub w wygodnej wyszukiwarce METACRAN i rdrr.io.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R i RStudio</span>"
    ]
  },
  {
    "objectID": "01-wprowadzenie.html#r-jako-kalkulator",
    "href": "01-wprowadzenie.html#r-jako-kalkulator",
    "title": "1  Wprowadzenie do R i RStudio",
    "section": "1.5 R jako kalkulator",
    "text": "1.5 R jako kalkulator\nDziałania matematycznie w R:\n\n\n\nOperator\nOperacja\n\n\n\n\n+\ndodawanie\n\n\n-\nodejmowanie\n\n\n*\nmnożenie\n\n\n/\ndzielenie\n\n\n^ lub **\npotęgowanie\n\n\nsqrt()\npierwiastkowanie\n\n\n\nW R istnieje także stała wbudowana pi przechowująca wartość liczby pi.\nFunkcja factorial(x) zwraca silnię (znak wykrzyknika !) z podanej wartości x, a sign(x) sprawdza znak wyrażenia i zwraca odpowiednio wartość -1 jeśli wyrażenie jest ujemne, 0 jeśli jest równe 0 i 1 dla wyrażeń dodatnich.\nFunkcja exp(x) zwraca wartość wyrażenia \\(e^x\\), natomiast funkcja log(x) zwraca logarytm z podanej liczby. Domyślnie jest to logarytm naturalny, ale można zmienić podstawę podając wartość argumentu base.\nFunkcja abs(x) zwraca wartość bezwzględną (absolutną) wyrażenia.\nĆwiczenie\nOblicz wartość wyrażenia: \\(2\\cdot \\sqrt{\\pi} + log_28\\).\nRozwiązanie:\n\n2*sqrt(pi)+log(8,2)\n\n[1] 6.544908\n\n\nZadania\nOblicz wartość wyrażeń:\n\n\\(\\frac{2^3\\cdot6^2}{(\\frac{1}{2})^2\\cdot(\\frac{4}{5})^3}\\)\n\\(\\sqrt[3]{\\frac{6-3.5}{2^{11}}}\\)\n\\(\\pi+\\sqrt{e^4}\\)\n\\(5! - log_{10}100\\)\n\\(|1-e|\\)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R i RStudio</span>"
    ]
  },
  {
    "objectID": "02-struktury.html",
    "href": "02-struktury.html",
    "title": "2  Struktury danych",
    "section": "",
    "text": "2.1 Obiekty\nPrezentacja\nW R praktycznie wszystko jest obiektem. Może to być zbiór danych, ale także wykres czy mapa. Zasadnicza różnica to klasa tych obiektów i operacje jakie mogą być na nich wykonywane.\nFunkcje w R wymagają jako argumentów określonych typów obiektów - stąd tak ważna jak znajomość istniejących struktur.\nKażdy obiekt w R możemy przypisać do tzw. obiektu nazwanego. Wówczas jest przechowywany w pamięci i można się do niego odwołać. Przypisanie odbywa się za pomocą operatora &lt;-.\nMożna także przypisywać obiekty z wykorzystaniem znaku równości =, ale nie jest to zalecane ponieważ symbol ten jest używany w innych miejscach np. do deklarowania wartości argumentów w funkcji.\nW R dostępna jest funkcja assign, która także umożliwia przypisanie nazwy do obiektu:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#obiekty",
    "href": "02-struktury.html#obiekty",
    "title": "2  Struktury danych",
    "section": "",
    "text": "nazwa &lt;- obiekt\nobiekt -&gt; nazwa\n\n\nassign(\"nazwa\", obiekt)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#wektor",
    "href": "02-struktury.html#wektor",
    "title": "2  Struktury danych",
    "section": "2.2 Wektor",
    "text": "2.2 Wektor\nWektor jest najprostszym typem danych w R. Najczęściej korzysta się z trzech typów wektorów:\n\nlogicznych\nliczbowych\ntekstowych\n\nWektor tworzy się z wykorzystaniem funkcji c().\n\n2.2.1 Wektor wartości logicznych\nPrzyjmuje wartości prawda lub fałsz:\n\nc(TRUE, FALSE, FALSE)\n\n[1]  TRUE FALSE FALSE\n\n\nlub w skróconej wersji:\n\nc(T, F, F)\n\n[1]  TRUE FALSE FALSE\n\n\nDo sprawdzenia długości wektora używa się funkcji length:\n\nlength(c(T, F, F))\n\n[1] 3\n\n\nlub korzystając z obiektu nazwanego:\n\nwart_log &lt;- c(T,F,F)\nlength(wart_log)\n\n[1] 3\n\n\nWektory można także utworzyć poprzez replikację określonej wartości lub wektora z wykorzystaniem funkcji rep. Funkcja ta przyjmuje co najmniej dwa argumenty: obowiązkowo x - wektor wejściowy oraz jeden z następujących: times - liczba powtórzeń elementów wektora x, each - liczba powtórzeń elementów wektora x (wyjaśnienie różnicy poniżej) lub length.out - oczekiwana długość wektora wynikowego.\nTrzy równoważne zapisy:\n\nrep(x = c(T,F), times = 3)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\nrep(c(T,F), times = 3)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\nrep(c(T,F), 3)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\n\nA tak to wygląda z argumentem each:\n\nrep(c(T,F), each = 3)\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\n\nWykorzystanie argumentu length.out:\n\nrep(c(T,F), length.out = 5)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n\n\n\n\n2.2.2 Wektor wartości liczbowych\nW wektorze możemy przechowywać także liczby:\n\nc(1, 3, -5, 2.5, .6) # nie trzeba pisać zera przed ułamkiem\n\n[1]  1.0  3.0 -5.0  2.5  0.6\n\n\nPołączenie dwóch wektorów to także wektor:\n\nc(c(1,2,3), c(3.5,4,4.5))\n\n[1] 1.0 2.0 3.0 3.5 4.0 4.5\n\n\nPojedyncza liczba też jest jednoelementowym wektorem:\n\nlength(2)\n\n[1] 1\n\n\nProste ciągi o różnicy równej 1 można generować wykorzystując dwukropek:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nlub\n\nc(-5:-1,1:5)\n\n [1] -5 -4 -3 -2 -1  1  2  3  4  5\n\n\nDo generowania ciągów liczbowych o różnych różnicach wykorzystuje się funkcję seq, która przyjmuje następujące argumenty. Wartość początkową from, wartość końcową to oraz jeden z następujących: by - krok lub length.out - oczekiwana długość wektora.\nTo samo co 1:10\n\nseq(1, 10, 1)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWartości niecałkowite:\n\nseq(1, 2, 0.2)\n\n[1] 1.0 1.2 1.4 1.6 1.8 2.0\n\n\nWektor wartości malejących:\n\nseq(10, 1, by=1) # błędny zapis\n\nError in seq.default(10, 1, by = 1): wrong sign in 'by' argument\n\nseq(10, 1, by=-1) # poprawny zapis\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n\nTworzenie wektora w oparciu o argument length.out - funkcja sama dobiera krok:\n\nseq(1, 7, length.out = 13)\n\n [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0\n\n\nDo generowania liczb pseudolosowych służy funkcja runif(n), która do poprawnego wywołania wymaga tylko jednego argumentu - długości wektora wynikowego. Domyślnie losowane są liczby z przedziału \\([0;1]\\) (tak jak w funkcji los() w Excelu), można to jednak zmienić podając odpowiednie wartości argumentów min i max.\n\nrunif(6)\n\n[1] 0.7542305 0.4287362 0.9799636 0.8911597 0.5059975 0.5065895\n\n\nObserwacje można także generować z innych rozkładów:\n\nrnorm - rozkład normalny,\nrchisq - rozkład \\(\\chi^2\\),\nrt - rozkład t-studenta,\nitp.\n\nWykaz wszystkich dostępnych w R rozkładów uzyskamy wywołując polecenie help(\"Distributions\").\nZa każdym uruchomieniem jednej z wymienionych wyżej funkcji losujących wartości z danego rozkładu otrzymamy inne wartości:\n\nrunif(5)\n\n[1] 0.6326084 0.8810437 0.3648544 0.1744558 0.8771406\n\nrunif(5)\n\n[1] 0.9285570 0.3475509 0.8957113 0.2240241 0.3436611\n\n\nPowtarzalność wyników możemy uzyskać ustalając ziarno generatora:\n\nset.seed(123)\nrunif(5)\n\n[1] 0.2875775 0.7883051 0.4089769 0.8830174 0.9404673\n\nset.seed(123)\nrunif(5)\n\n[1] 0.2875775 0.7883051 0.4089769 0.8830174 0.9404673\n\n\n\n\n2.2.3 Wektor wartości tekstowych\nW wektorze może być przechowywany tekst - wówczas poszczególne elementy zapisujemy w cudzysłowie lub apostrofach:\n\nc(\"ala\", \"ma\", \"kota\")\n\n[1] \"ala\"  \"ma\"   \"kota\"\n\nc('ala', 'ma', 'kota')\n\n[1] \"ala\"  \"ma\"   \"kota\"\n\n\nW RStudio wygodniej używać cudzysłowu, ponieważ program automatycznie go zamyka.\nIstnieje także stała zawierająca litery alfabetu:\n\nletters\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nLETTERS\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n\n\n\n2.2.4 Przeciążanie wektora\nJeśli w wektorze pomieszamy kilka typów zmiennych to R przekształci poszczególne wartości, tak aby stracić jak najmniej informacji:\n\nc(TRUE, 2, 5)\n\n[1] 1 2 5\n\nc(3, \"cztery\", 5)\n\n[1] \"3\"      \"cztery\" \"5\"     \n\n\nW pierwszym przypadku wartość TRUE została przekształcona na odpowiednik liczbowy - 1. Z kolei w drugim przykładzie podane liczby zostały przekonwertowane na tekst.\n\n\n2.2.5 Operacje na wektorach\nNa wektorach logicznych i liczbowych można wykonywać operacje arytmetyczne np. mnożenie:\n\n1:10*2\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\nWektor liczbowy plus wektor liczbowy:\n\n1:10 + c(1,2)\n\n [1]  2  4  4  6  6  8  8 10 10 12\n\n\nWektor liczbowy razy wektor liczbowy:\n\n1:10 * c(1,2)\n\n [1]  1  4  3  8  5 12  7 16  9 20\n\n\nWektor liczbowy razy wektor logiczny:\n\n1:10 * c(T, F)\n\n [1] 1 0 3 0 5 0 7 0 9 0\n\n\nDługości obu wektorów muszą być odpowiednie:\n\n1:10 * c(T,F,T)\n\nWarning in 1:10 * c(T, F, T): longer object length is not a multiple of shorter\nobject length\n\n\n [1]  1  0  3  4  0  6  7  0  9 10\n\n\nDłuższy z wektorów musi być wielokrotnością krótszego.\nSiłą rzeczy działania arytmetyczne na wektorach tekstowych nie są możliwe:\n\nc(\"jeden\", \"dwa\", \"trzy\", \"cztery\") * c(T,F)\n\nError in c(\"jeden\", \"dwa\", \"trzy\", \"cztery\") * c(T, F): non-numeric argument to binary operator\n\nc(\"jeden\", \"dwa\", \"trzy\", \"cztery\") + c(1,2)\n\nError in c(\"jeden\", \"dwa\", \"trzy\", \"cztery\") + c(1, 2): non-numeric argument to binary operator\n\n\n\n\n2.2.6 Operacje agregujące\nNa wektorach można także wykonywać operacje agregujące:\n\n\n\nFunkcja\nDziałanie\n\n\n\n\nmean()\nśrednia elementów\n\n\nsum()\nsuma elementów\n\n\nprod()\niloczyn elementów\n\n\nvar()\nwariancja elementów\n\n\nsd()\nodchylenie standardowe elementów\n\n\nmedian()\nmediana elementów\n\n\nquantile()\nkwantyl danego rzędu\n\n\nmin()\nminimum\n\n\nmax()\nmaksimum\n\n\n\nObliczenie skośności i kurtozy jest możliwe po zainstalowaniu pakietu e1071. Wówczas mamy dostęp do funkcji:\n\n\n\nFunkcja\nDziałanie\n\n\n\n\nskewness()\nskośność elementów\n\n\nkurtosis()\nkurtoza elementów\n\n\n\nSuma wektora numerycznego:\n\nsum(1:10)\n\n[1] 55\n\n\nSuma i średnia wektora logicznego:\n\nsum(c(T, F, F, T))\n\n[1] 2\n\nmean(c(T, F, F, T))\n\n[1] 0.5\n\n\nKorzystanie z funkcji pochodzących z pakietów zewnętrznych wymaga wskazania skąd pochodzi dana funkcja. Można to zrobić na dwa sposoby: funkcją library(pakiet) - wówczas wszystkie funkcje z tego pakietu są wczytywane do pamięci i można do nich sięgać bezpośrednio lub wskazując przed nazwą funkcji z jakiego pakietu pochodzi.\nWczytanie pakietu:\n\nlibrary(e1071)\nskewness(c(1,2,3,4,5,7,9,11,13))\n\n[1] 0.3451259\n\n\nlub równoważnie:\n\ne1071::skewness(c(1,2,3,4,5,7,9,11,13))\n\n[1] 0.3451259\n\n\nPodsumowanie rozkładu wektora można także uzyskać z wykorzystaniem funkcji summary(x):\n\nsummary(1:10)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    3.25    5.50    5.50    7.75   10.00 \n\n\nDziała także na wektorach tekstowych:\n\nsummary(c(\"jeden\", \"dwa\", \"trzy\", \"cztery\"))\n\n   Length     Class      Mode \n        4 character character \n\n\n\n\n2.2.7 Sprawdzanie typu wektora\nDo określenia typu wektora służy funkcja typeof, class lub mode.\n\ntypeof(wart_log)\n\n[1] \"logical\"\n\n\nSprawdzenie czy obiekt jest danego typu odbywa się z wykorzystaniem dedykowanych funkcji z przyrostkiem is.\n\nis.logical(wart_log)\n\n[1] TRUE\n\nis.character(wart_log)\n\n[1] FALSE\n\n\n\n\n2.2.8 Rzutowanie wektorów\nCzasami jako np. argument funkcji będzie wymagany inny typ wektora aniżeli aktualnie posiadany w pamięci. Można wówczas spróbować przekształcić taki wektor z wykorzystaniem funkcji rozpoczynającej się od as.:\n\ntypeof(wart_log)\n\n[1] \"logical\"\n\nas.numeric(wart_log)\n\n[1] 1 0 0\n\ntypeof(as.numeric(wart_log))\n\n[1] \"double\"\n\n\n\n\n2.2.9 Indeksowanie wektorów\nAby uzyskać dostęp do części wektora korzysta się z indeksatora w postaci nawiasów kwadratowych. Utworzymy nowy wektor zawierający liczby całkowite od 10 do 20:\n\nwart_10_20 &lt;- seq(10,20)\nwart_10_20\n\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\na następnie wybieramy trzecią obserwację:\n\nwart_10_20[3]\n\n[1] 12\n\n\nMożemy także odwołać się do większego zakresu:\n\nwart_10_20[3:5]\n\n[1] 12 13 14\n\n\nI wybranych elementów:\n\nwart_10_20[c(1,3,5)]\n\n[1] 10 12 14\n\n\nW ten sposób można także modyfikować odpowiednie elementy wektora:\n\nwart_10_20[7] &lt;- 90\n\nWybór obserwacji większych od 15:\n\nwart_10_20[wart_10_20&gt;15]\n\n[1] 90 17 18 19 20\n\n\nZ kolei następujący zapis zwróci nam wektor wartości logicznych:\n\nwart_10_20 &gt; 15\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n\n2.2.10 Wartości nieliczbowe\nBrak danych w R jest przedstawiany jako wartość NA (ang. not available) i może powodować trudności z wywoływaniem niektórych funkcji:\n\nv_na &lt;- c(1,2,1,NA,1)\nv_na\n\n[1]  1  2  1 NA  1\n\nsum(v_na)\n\n[1] NA\n\n\nW związku z tym większość funkcji ma zaimplementowany dodatkowy argument służący do obsługi tego typu wartości, który najczęściej nie uwzględnia tych wartości w obliczeniach:\n\nsum(v_na, na.rm = TRUE)\n\n[1] 5\n\n\nOprócz braku danych podczas obliczeń możemy natrafić na wartości nieokreślone NaN (ang. not a number) oraz nieskończone Inf (ang. infinity).\n\n0/0\n\n[1] NaN\n\n1/0\n\n[1] Inf\n\nsqrt(-10)\n\nWarning in sqrt(-10): NaNs produced\n\n\n[1] NaN\n\n\nW R istnieje także wartość NULL, która jest podstawowym typem danych a nie wartością. NULL można traktować jako odpowiednik zbioru pustego. Jest stosowany np. w funkcjach, które niczego nie zwracają.\n\nv_null &lt;- c(1,2,1,NULL,1)\nv_null\n\n[1] 1 2 1 1\n\nsum(v_null)\n\n[1] 5\n\n\n\n\n2.2.11 Zadania\n\nIle wynosi suma elementów większych od 10 dla następujących liczb: 12, 5, 20, 18, 8.5, 10, 4, 101, -2?\nZ wykorzystaniem funkcji seq i na podstawie wektora … dokonaj przekształcenia tworząc następujący wektor: 2 0 0 4 0 0 6 0 0 8 0 0.\nDane są dwa wektory - a: 2, 3, 7, 8, 2, b: 9, 1, 2, 0, 2. Jakiego typu będzie wektor będący wynikiem działania a&lt;=b?\nUzupełnij wektor letters o polskie litery diakrytyzowane. Jaką długość ma nowo utworzony wektor?\nWylosuj z rozkładu normalnego 1000 obserwacji z ziarnem równym 76. Ile wynosi kurtoza tych wartości?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#macierz",
    "href": "02-struktury.html#macierz",
    "title": "2  Struktury danych",
    "section": "2.3 Macierz",
    "text": "2.3 Macierz\nMacierze są wykorzystywane w R do przechowywania np. odległości pomiędzy punktami czy wskazywania sąsiedztwa obszarów geograficznych.\nDo tworzenia macierzy służy funkcja matrix:\n\nm &lt;- matrix(1:6, nrow = 2, ncol=3)\nm\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nZ wykorzystaniem wybranych funkcji można sprawdzić wymiary macierzy, liczbę wierszy oraz kolumn:\n\ndim(m)\n\n[1] 2 3\n\nncol(m)\n\n[1] 3\n\nnrow(m)\n\n[1] 2\n\n\nMacierz może także zawierać tekst:\n\nmatrix(letters[1:9], nrow=3)\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"d\"  \"g\" \n[2,] \"b\"  \"e\"  \"h\" \n[3,] \"c\"  \"f\"  \"i\" \n\n\nDomyślnie macierz układana jest kolumnami. Aby to zmienić należy dodać argument byrow=TRUE:\n\nmatrix(letters[1:9], nrow=3, byrow=TRUE)\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"b\"  \"c\" \n[2,] \"d\"  \"e\"  \"f\" \n[3,] \"g\"  \"h\"  \"i\" \n\n\nJeśli liczba elementów wejściowych jest mniejsza iloczyn podanej liczby kolumn i wierszy to w brakujące miejsce wstawiane są elementy z początku wektora wejściowego:\n\nmatrix(letters[1:7], nrow=3, byrow=TRUE)\n\nWarning in matrix(letters[1:7], nrow = 3, byrow = TRUE): data length [7] is not\na sub-multiple or multiple of the number of rows [3]\n\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"b\"  \"c\" \n[2,] \"d\"  \"e\"  \"f\" \n[3,] \"g\"  \"a\"  \"b\" \n\n\nZ kolei macierz diagnonalną posiadającą elementy niezerowe wyłącznie na przekątnej tworzy się z wykorzystaniem funkcji diag. Macierz jednostkowa o wymiarach \\(4 \\times 4\\):\n\ndiag(4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    1    0    0\n[3,]    0    0    1    0\n[4,]    0    0    0    1\n\n\nMacierz diagonalna o wartościach 5 na przekątnej i wymiarach \\(3 \\times 3\\)\n\ndiag(5, nrow=3, ncol=3)\n\n     [,1] [,2] [,3]\n[1,]    5    0    0\n[2,]    0    5    0\n[3,]    0    0    5\n\n\nFunkcja diag umożliwia także ekstrakcję przekątnej z istniejącej już macierzy:\n\ndiag(matrix(letters[1:9], nrow=3))\n\n[1] \"a\" \"e\" \"i\"\n\n\n\n2.3.1 Łączenie macierzy\nZ wykorzystaniem funkcji rbind i cbind można odpowiednio łączyć obiekty wierszami (ang. row bind) lub kolumnami (ang. col bind):\n\nrbind(m, c(99, 88, 77))\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n[3,]   99   88   77\n\ncbind(m, matrix(101:104, nrow=2))\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5  101  103\n[2,]    2    4    6  102  104\n\n\n\n\n2.3.2 Indeksowanie macierzy\nDostęp do poszczególnych elementów macierzy odbywa się z wykorzystaniem nawiasów kwadratowych, ale można podać dwie wartość - obiekt[wiersz,kolumna]:\n\nm[2,1] # drugi wiersz, pierwsza kolumna\n\n[1] 2\n\nm[2,]  # tylko drugi wiersz\n\n[1] 2 4 6\n\nm[,1]  # tylko pierwsza kolumna\n\n[1] 1 2\n\nm[,]   # wszystkie obserwacje\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nm[]    # wszystkie obserwacje\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nW ten sposób można dokonać modyfikacji konkretnych elementów macierzy:\n\nm[2,1] &lt;- 77\nm\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]   77    4    6\n\n\n\n\n2.3.3 Operacje na macierzach\nNa macierzach można wywołać szereg operacji:\n\n\n\nOperator/funkcja\nDziałanie\n\n\n\n\na %*% b\nmnożenie macierzy a i b\n\n\nt(a)\ntranspozycja macierzy a\n\n\ndet(a)\nwyznacznik macierzy a\n\n\nsolve(a)\nmacierz odwrotna z a\n\n\nsolve(a, b)\nrozwiązanie układu a*x=b\n\n\n\nRozważmy dwie macierze:\n\na &lt;- matrix(c(2, 3, 4, 2, 1, 2, 1, 3, 2), nrow = 3)\nb &lt;- matrix(6:1, ncol=2)\na;b\n\n     [,1] [,2] [,3]\n[1,]    2    2    1\n[2,]    3    1    3\n[3,]    4    2    2\n\n\n     [,1] [,2]\n[1,]    6    3\n[2,]    5    2\n[3,]    4    1\n\n\nAby przeprowadzić mnożenie macierzy a i b, liczba kolumn macierzy a musi być równa liczbie wierszy w macierzy b. Z kolei rozmiar macierzy wyjściowej to liczba wierszy macierzy a i liczba kolumn macierzy b.\n\na %*% b\n\n     [,1] [,2]\n[1,]   26   11\n[2,]   35   14\n[3,]   42   18\n\n\nTranspozycja macierzy b:\n\nt(b)\n\n     [,1] [,2] [,3]\n[1,]    6    5    4\n[2,]    3    2    1\n\n\nWyznacznik macierzy a:\n\ndet(a)\n\n[1] 6\n\n\nMacierz odwrotna do macierzy a:\n\nsolve(a)\n\n           [,1]       [,2]       [,3]\n[1,] -0.6666667 -0.3333333  0.8333333\n[2,]  1.0000000  0.0000000 -0.5000000\n[3,]  0.3333333  0.6666667 -0.6666667\n\n\nWyznaczenie macierzy x w równaniu a*x=b:\n\nsolve(a,b)\n\n          [,1]      [,2]\n[1,] -2.333333 -1.833333\n[2,]  4.000000  2.500000\n[3,]  2.666667  1.666667\n\na %*% solve(a,b)\n\n     [,1] [,2]\n[1,]    6    3\n[2,]    5    2\n[3,]    4    1\n\nb\n\n     [,1] [,2]\n[1,]    6    3\n[2,]    5    2\n[3,]    4    1\n\n\n\n\n2.3.4 Zadanie\n\nCo powstanie po przemnożeniu macierzy przez jej macierz odwrotną?\nEstymator parametrów beta w metodzie najmniejszych kwadratów jest dany wzorem:\n\n\\[b=(X'X)^{-1}X'y\\]\nZmienna \\(x_1\\) przyjmuje wartości 2,4,1,6,9,3,2,9,10,7, zmienna \\(x_2\\) 1.5,0.2,0.1,2,3.1,1.2,0.4,2.9,2.5,1.9, a zmienna \\(x_0\\) to wektor jedynek. Te trzy zmienne tworzą macierz \\(X\\). Z kolei wartości zmiennej \\(y\\) są następujące 12,15,10,19,26,13,13,21,29,18. Wyznacz wartość \\(b\\).\n\nzad1 &lt;- matrix(1:4, nrow=2)\nsolve(zad1)\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\nzad1 %*% solve(zad1)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#czynnik",
    "href": "02-struktury.html#czynnik",
    "title": "2  Struktury danych",
    "section": "2.4 Czynnik",
    "text": "2.4 Czynnik\nCzynnik (ang. factor) służy do przechowywania danych jakościowych o mało licznej liczbie kategorii, mierzonych na skali nominalnej i porządkowej.\nRozważmy informacje o wykształceniu:\n\nwyk &lt;- rep(c(\"podstawowe\", \"średnie\", \"wyższe\"), c(5,3,2))\nwyk\n\n [1] \"podstawowe\" \"podstawowe\" \"podstawowe\" \"podstawowe\" \"podstawowe\"\n [6] \"średnie\"    \"średnie\"    \"średnie\"    \"wyższe\"     \"wyższe\"    \n\n\ni dokonajmy transformacji na czynnik:\n\nwyk_f &lt;- factor(wyk)\nwyk_f\n\n [1] podstawowe podstawowe podstawowe podstawowe podstawowe średnie   \n [7] średnie    średnie    wyższe     wyższe    \nLevels: podstawowe średnie wyższe\n\n\nFunkcja summary() wywołana na czynniku zwraca wynik innego typu aniżeli na wektorze tekstowym:\n\nsummary(wyk)\n\n   Length     Class      Mode \n       10 character character \n\nsummary(wyk_f)\n\npodstawowe    średnie     wyższe \n         5          3          2 \n\n\nJeśli chcemy zaakcentować fakt, że zmienne są mierzone na skali porządkowej dodajemy argument ordered=TRUE:\n\nwyk_of &lt;- factor(wyk, ordered = TRUE)\nwyk_of\n\n [1] podstawowe podstawowe podstawowe podstawowe podstawowe średnie   \n [7] średnie    średnie    wyższe     wyższe    \nLevels: podstawowe &lt; średnie &lt; wyższe\n\n\nW łatwy sposób możemy edytować etykiety:\n\nlevels(wyk_of) &lt;- c(\"pod.\", \"śr.\", \"wyż.\")\nwyk_of\n\n [1] pod. pod. pod. pod. pod. śr.  śr.  śr.  wyż. wyż.\nLevels: pod. &lt; śr. &lt; wyż.\n\n\nCzynniki mają szczególne znaczenie w przypadku tworzenia wykresów, gdy chcemy określić porządek wyświetlania.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#lista",
    "href": "02-struktury.html#lista",
    "title": "2  Struktury danych",
    "section": "2.5 Lista",
    "text": "2.5 Lista\nListy to ciągi złożone z elementów o dowolnych typach. Mogą przydać się w szczególności przy budowaniu funkcji, które zwracają tylko jedną wartość. Wówczas dane różnego typu mogą być zawarte w takiej liście.\nTworzenie prostej listy:\n\nl &lt;- list(TRUE, c(1,2,3,4), \"element tekstowy\")\nl\n\n[[1]]\n[1] TRUE\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] \"element tekstowy\"\n\n\nJuż na pierwszy rzut oka widać bardziej złożoną strukturę listy. W związku z tym odwoływanie do poszczególnych elementów będzie trochę się różnić od wektorów czy macierzy.\n\nl[2] # druga lista\n\n[[1]]\n[1] 1 2 3 4\n\nl[[2]] # zawartość listy\n\n[1] 1 2 3 4\n\nl[[2]][3] # trzeci element wektora drugiej listy\n\n[1] 3\n\n\nListę można także rozwinąć do wektora z wykorzystaniem funkcji unlist:\n\nunlist(l)\n\n[1] \"TRUE\"             \"1\"                \"2\"                \"3\"               \n[5] \"4\"                \"element tekstowy\"\n\n\nPoszczególne elementy listy można nazwać:\n\nln &lt;- list(log=TRUE, num=c(1,2,3,4), tekst=\"element tekstowy\")\nln\n\n$log\n[1] TRUE\n\n$num\n[1] 1 2 3 4\n\n$tekst\n[1] \"element tekstowy\"\n\n\nWówczas można uzyskać do nich dostęp poprzez symbol $ i podaną nazwę:\n\nln$num\n\n[1] 1 2 3 4\n\nln[[2]] # normalne indeksowanie nadal działa\n\n[1] 1 2 3 4\n\nln$num[2]\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#ramka-danych",
    "href": "02-struktury.html#ramka-danych",
    "title": "2  Struktury danych",
    "section": "2.6 Ramka danych",
    "text": "2.6 Ramka danych\nRamka danych to tabela, która przypomina tą z Excela zawierająca dane o różnych typach. Tworzona za pomocą funkcji data.frame:\n\ndf &lt;- data.frame(plec=c(\"m\", \"k\", \"k\", \"m\", \"k\", \"m\", \"m\", \"m\"),\n                 wzrost=c(173, 170, 163, 178, 169, 180, 175, NA),\n                 pali=c(T, F, F, F, T, F, NA, T))\n\nW RStudio po wybraniu tego obiektu w zakładce Environment pojawia się przyjazne okno do przeglądania oraz poglądowego filtrowania i sortowania danych ze zbioru.\nMożemy zobaczyć podsumowanie całego zbioru wywołując na nim funkcję summary():\n\nsummary(df)\n\n     plec               wzrost         pali        \n Length:8           Min.   :163.0   Mode :logical  \n Class :character   1st Qu.:169.5   FALSE:4        \n Mode  :character   Median :173.0   TRUE :3        \n                    Mean   :172.6   NA's :1        \n                    3rd Qu.:176.5                  \n                    Max.   :180.0                  \n                    NA's   :1                      \n\n\nRamki danych można indeksować w taki sam sposób jak macierze lub z wykorzystaniem operatora $:\n\ndf[,2] # druga kolumna\n\n[1] 173 170 163 178 169 180 175  NA\n\ndf$wzrost # kolumna wzrost\n\n[1] 173 170 163 178 169 180 175  NA\n\ndf[,c(\"plec\", \"pali\")]\n\n  plec  pali\n1    m  TRUE\n2    k FALSE\n3    k FALSE\n4    m FALSE\n5    k  TRUE\n6    m FALSE\n7    m    NA\n8    m  TRUE\n\n\nZ kolei do wyboru obserwacji można wykorzystać warunek:\n\ndf[df$plec==\"m\",]\n\n  plec wzrost  pali\n1    m    173  TRUE\n4    m    178 FALSE\n6    m    180 FALSE\n7    m    175    NA\n8    m     NA  TRUE\n\n\nWyodrębnienie informacji o wzroście tylko dla kobiet i wyznaczenie średniej:\n\nwzrost_k &lt;- df$wzrost[df$plec == \"k\"]\nwzrost_k\n\n[1] 170 163 169\n\nmean(wzrost_k)\n\n[1] 167.3333\n\n\nWidzimy, że dla mężczyzn nie udało się ustalić wszystkich informacji i jeden z nich nie ma podanego wzrostu, a dla drugiego brakuje informacji o paleniu papierosów. Możemy usunąć braki danych w kolumnach korzystając z funkcji complete.cases():\n\ndf[complete.cases(df$wzrost),] # tylko zmienna wzrost\n\n  plec wzrost  pali\n1    m    173  TRUE\n2    k    170 FALSE\n3    k    163 FALSE\n4    m    178 FALSE\n5    k    169  TRUE\n6    m    180 FALSE\n7    m    175    NA\n\ndf[complete.cases(df),] # wszystkie zmienne\n\n  plec wzrost  pali\n1    m    173  TRUE\n2    k    170 FALSE\n3    k    163 FALSE\n4    m    178 FALSE\n5    k    169  TRUE\n6    m    180 FALSE\n\n\nZbiory danych przechowywane są także w R i pochodzą z różnych pakietów. Wywołując funkcję data(\"zbior\") ładujemy dany zbiór do pamięci. Do szybkiego podglądu zebranych danych służy funkcja head(), która domyślnie wyświetla 6 pierwszych obserwacji ze zbioru:\n\ndata(\"iris\")\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html",
    "href": "03-przetwarzanie.html",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "",
    "text": "3.1 Pakiet tidyverse\nPrezentacja\nPakiet tidyverse to zestaw pakietów do kompleksowego przetwarzania i wizualizacji danych. Ładuje następujące pakiety:\nManifest tidyverse ustala następujące zasady:\nWobec tego załadujmy pakiet tidyverse:\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nW konsoli pojawi się informacja o wersji załadowanych pakietów oraz o konfliktach występujących pomiędzy pakietami. Konflikty te wynikają z takich samych nazw funkcji w różnych pakietach. Kolejność wczytywania pakietów ma znaczenie - kolejny pakiet przykryje funkcje z wcześniej wczytanego. Wywołanie przykrytej funkcji jest możliwe poprzez zapis nazwa_pakietu::nazwa_funkcji.\nKorzystanie z pakietu i zasad tidyverse to dużo bardziej czytelny kod w porównaniu do wbudowanych funkcji. Poniżej przedstawiony jest przykład przetwarzania danych polegający na filtrowaniu, wyborze kolumn oraz utworzeniu nowej zmiennej.\ndata(\"ChickWeight\")\n\n# bez pakietu tidyverse\n\nchick_15 &lt;- ChickWeight[ChickWeight$Chick==\"15\",]\nchick_15 &lt;- chick_15[c(\"weight\", \"Time\", \"Diet\"),]\nchick_15$weight_kg &lt;- chick_15$weight/1000\n\n# z pakietem tidyverse\n\nchick_15 &lt;- ChickWeight %&gt;%\n  filter(Chick==\"15\") %&gt;%\n  select(-Chick) %&gt;%\n  mutate(weight_kg=weight/1000)\nRozwiązanie z wykorzystaniem wbudowanych funkcji to 133 znaki, natomiast wykorzystanie tidyverse to 30% oszczędność miejsca i tylko 92 znaki.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#pakiet-tidyverse",
    "href": "03-przetwarzanie.html#pakiet-tidyverse",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "",
    "text": "ggplot2 - tworzenie wykresów,\ndplyr - przetwarzanie danych,\ntidyr - zmiana reprezentacji danych,\nreadr - wczytywanie danych tekstowych,\npurrr - programowanie funkcyjne\ntibble - sposób przechowywania danych,\nstringr - przetwarzanie tekstów,\nforcats - przetwarzanie faktorów\nlubridate - operacje na datach\n\n\n\npowtórne użycie istniejących struktur danych,\ntworzenie czytelnych kodów z operatorem pipe %&gt;% (ang. rura, przewód, łącznik). Od wersji R 4.1.0 dostępny jest natywny pipe |&gt; - można go włączyć w ustawieniach RStudio.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#import-danych",
    "href": "03-przetwarzanie.html#import-danych",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.2 Import danych",
    "text": "3.2 Import danych\nWczytywanie danych do R jest możliwe z wielu różnych źródeł. Funkcje, które to umożliwiają zwykle mają nazwę rozpoczynającą się od read.\nBędziemy korzystać z następujących zbiorów danych:\n\nmovies - plik tekstowy zawierający informacje o filmach,\nrossmann - plik excel zawierający dane ze sklepów Rossmann,\nsmog - plik tekstowy zawierający informacje pogodowe oraz PM10 w Pszczynie,\nlotto - plik tekstowy zawierający dane z losowań Lotto,\ncru10min30_tmp.nc - CRU CL 2.0 1961-1990 Monthly Average Temperature (0.5-deg subset) pobrany ze strony.\n\n\n3.2.1 Pliki CSV\nDo wczytywania plików csv można wykorzystać wbudowaną funkcję read.csv() lub tą pochodzącą z pakietu readr - read_csv(). W obu przypadkach wynik wczytania będzie podobny. Zaleca się oczywiście korzystanie z nowszej wersji.\n\nlibrary(readr)\n\n# CSV z separatorem przecinkowym\nmovies &lt;- read_csv(\"data/movies.csv\")\n\n# Plik z separatorem średnikowym\nsmog &lt;- read_csv2(\"data/smog_pszczyna.csv\")\n\n# Plik tekstowy z niestandardowym separatorem (np. tabulacja)\n# lotto &lt;- read_delim(\"http://www.mbnet.com.pl/dl.txt\", delim = \" \", col_names = c(\"id\", \"data\", \"numery\"))\n\nZapisywanie danych odbywa się z wykorzystaniem funkcji z przyrostkiem write:\n# Zapis do CSV\nwrite_csv(dane_csv, \"wynik.csv\")\n\n# Zapis z separatorem średnikowym\nwrite_csv2(dane_csv, \"wynik2.csv\")\n\n\n3.2.2 Pliki excel\nDo wczytywania plików z Excela niezbędny jest dodatkowy pakiet readxl. W funkcji read_xlsx() podajemy jako argument nazwę pliku. Możemy także dodać nazwę lub numer arkusza w argumencie (sheet =) oraz zakres komórek jako wartość argumentu range =.\n\nlibrary(readxl)\n\nrossmann &lt;- read_xlsx(path = \"data/rossmann.xlsx\")\n\n# rossmann &lt;- read_xlsx(path = \"data/rossmann.xlsx\", sheet = 1)\n# rossmann &lt;- read_xlsx(path = \"data/rossmann.xlsx\", sheet = \"Sheet 1\")\n\n# rossmann &lt;- read_xlsx(path = \"data/rossmann.xlsx\", range = \"A1:L936\")\n\nPakiet readxl nie obsługuje zapisu do Excela. Użyj pakietu writexl lub openxlsx do zapisu.\n\n\n3.2.3 Pliki SAS, SPSS\nPakiet haven umożliwia wczytywanie danych z popularnych narzędzi statystycznych.\nlibrary(haven)\n\n# Plik SPSS (.sav)\ndane_spss &lt;- read_sav(\"plik.sav\")\n\n# Plik SAS (.sas7bdat)\ndane_sas &lt;- read_sas(\"plik.sas7bdat\")\nMożliwe jest także zapisywanie danych w tych formatach\n# Zapis do SPSS\nwrite_sav(dane_spss, \"wynik.sav\")\n\n# Zapis do SAS\nwrite_sas(dane_sas, \"wynik.sas7bdat\")\n\n\n3.2.4 Pliki netCDF\nnetCDF (Network Common Data Form) to format używany głównie w naukach przyrodniczych (np. meteorologii).\n\nlibrary(ncdf4)\n\n# Otwórz plik netCDF\nnc &lt;- nc_open(\"data/cru10min30_tmp.nc\")\nprint(nc)\n\nFile data/cru10min30_tmp.nc (NC_FORMAT_CLASSIC):\n\n     2 variables (excluding dimension variables):\n        float time_bounds[nv,time]   \n        float tmp[lon,lat,time]   \n            long_name: air_temperature\n            units: degC\n            _FillValue: -99\n            source: E:\\Projects\\cru\\data\\cru_cl_2.0\\nc_files\\cru10min_tmp.nc\n\n     4 dimensions:\n        lon  Size:720 \n            standard_name: longitude\n            long_name: longitude\n            units: degrees_east\n            axis: X\n        lat  Size:360 \n            standard_name: latitude\n            long_name: latitude\n            units: degrees_north\n            axis: Y\n        time  Size:12 \n            standard_name: time\n            long_name: time\n            units: days since 1900-01-01 00:00:00.0 -0:00\n            axis: T\n            calendar: standard\n            climatology: climatology_bounds\n        nv  Size:2 (no dimvar)\n\n    7 global attributes:\n        data: CRU CL 2.0 1961-1990 Monthly Averages\n        title: CRU CL 2.0 -- 10min grid sampled every 0.5 degree\n        institution: http://www.cru.uea.ac.uk/\n        source: http://www.cru.uea.ac.uk/~markn/cru05/cru05_intro.html\n        references: New et al. (2002) Climate Res 21:1-25\n        history: Wed Oct 29 11:27:35 2014: ncrename -v climatology_bounds,time_bounds cru10min30_tmp.nc\nP.J. Bartlein, 19 Jun 2005\n        Conventions: CF-1.0\n\n# Lista zmiennych\nnames(nc$var)\n\n[1] \"time_bounds\" \"tmp\"        \n\n# Odczyt konkretnej zmiennej\ntemperatura &lt;- ncvar_get(nc, \"tmp\")\ntemperatura_maj = temperatura[,,5]\n\nlat &lt;- ncvar_get(nc, \"lat\")\nlon &lt;- ncvar_get(nc, \"lon\")\n\nlonlat &lt;- as.matrix(expand.grid(lon,lat))\ntmp_vec &lt;- as.vector(temperatura_maj)\n\ntmp_df01 &lt;- data.frame(cbind(lonlat,tmp_vec))\nnames(tmp_df01) &lt;- c(\"lon\",\"lat\",\"temp\")\nhead(na.omit(tmp_df01), 10)\n\n         lon    lat temp\n49186 -67.25 -55.75  3.1\n49901 -69.75 -55.25  3.2\n49902 -69.25 -55.25  3.5\n49903 -68.75 -55.25  2.6\n49904 -68.25 -55.25  3.3\n49905 -67.75 -55.25  3.3\n49906 -67.25 -55.25  3.2\n50617 -71.75 -54.75  4.1\n50619 -70.75 -54.75  3.7\n50620 -70.25 -54.75  2.8\n\nsummary(tmp_df01)\n\n      lon               lat              temp       \n Min.   :-179.75   Min.   :-89.75   Min.   :-22.20  \n 1st Qu.: -89.88   1st Qu.:-44.88   1st Qu.:  3.70  \n Median :   0.00   Median :  0.00   Median : 13.70  \n Mean   :   0.00   Mean   :  0.00   Mean   : 12.59  \n 3rd Qu.:  89.88   3rd Qu.: 44.88   3rd Qu.: 23.50  \n Max.   : 179.75   Max.   : 89.75   Max.   : 35.90  \n                                    NA's   :196239  \n\ntmp_df01_cc &lt;- tmp_df01[complete.cases(tmp_df01),]\n\nplot(tmp_df01_cc$lon, tmp_df01_cc$lat)\n\n\n\n\n\n\n\nggplot(tmp_df01_cc, aes(x=lon, y=lat, color=temp)) +\n  geom_point()\n\n\n\n\n\n\n\nwrite_csv(tmp_df01_cc, \"data/temp_maj.csv\")\n\n# Zamknięcie pliku\nnc_close(nc)\n\nW tym przypadku wykorzystywane są różne funkcje do obsługi pliku:\n\nnc_open(): otwiera plik.\nncvar_get(nc, varname): pobiera dane zmiennej.\nnc_close(nc): zamyka plik.\n\nZapisywanie do pliku netCDF jest bardziej złożone i wymaga:\n\nzdefiniowania wymiarów (ncdim_def()),\nzdefiniowania zmiennych (ncvar_def()),\nutworzenia pliku (nc_create()),\nzapisania danych (ncvar_put()),\nzamknięcia pliku (nc_close()).\n\nStudium przypadku dotyczące tego pliku dostępne jest na stronie https://pjbartlein.github.io/REarthSysSci/netCDF.html\n\n\n3.2.5 Natywne pliki R\nR oferuje możliwość przechowywania obiektów w specjalnym, binarnym formacie .RData lub .rda, który jest bardzo szybki i efektywny w kontekście dużych danych.\n# Zapis jednego lub wielu obiektów do pliku\nsave(obiekt1, obiekt2, file = \"moje_dane.RData\")\n\n# Zapis wszystkich obiektów z pamięci roboczej\nsave.image(file = \"wszystko.RData\")\nObowiązkowym argumentem tych funkcji jest file:\n\nfile: nazwa pliku wyjściowego.\n...: nazwy obiektów do zapisania.\ncompress: czy kompresować dane (TRUE, FALSE, \"gzip\", \"bzip2\", \"xz\").\n\nWczytywanie danych z tego formatu:\n# Wczytanie danych z pliku RData\nload(\"moje_dane.RData\")\nPo użyciu load() wszystkie obiekty zapisane w pliku trafiają do środowiska globalnego z zachowaniem ich oryginalnych nazw.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#filtrowanie",
    "href": "03-przetwarzanie.html#filtrowanie",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.3 Filtrowanie",
    "text": "3.3 Filtrowanie\nDo przetwarzania danych służą funkcje z pakietu dplyr. Większość z nich jako pierwszy argument przyjmuje przetwarzany zbiór danych, ale można tego uniknąć wykorzystując symbole %&gt;%.\nFiltrowanie polega na wybraniu obserwacji, które spełniają określony warunek lub warunki. Ze zbioru smog wybierzmy wszystkie dni, kiedy poziom PM10 był dopuszczalny:\n\nsmog_dop &lt;- filter(smog, poziom == \"dopuszczalny\")\n\nlub alternatywnie:\n\nsmog_dop &lt;- smog %&gt;%\n  filter(poziom == \"dopuszczalny\")\n\nPo zmiennej, która jest filtrowana musimy podać operator porównania czyli podwójny znak równości ==. Jeśli chcemy filtrować po większej liczbie zmiennych to kolejne warunki dodajemy po przecinku:\n\nsmog_dop_2015 &lt;- smog %&gt;%\n  filter(poziom == \"dopuszczalny\", rok == 2015)\n\nWówczas oba warunki muszą zostać spełnione czyli pomiędzy nimi zachodzi relacja i. Równoważny zapis jest następujący:\n\nsmog_dop_2015 &lt;- smog %&gt;%\n  filter(poziom == \"dopuszczalny\" & rok == 2015)\n\nPomiędzy warunkami może także zachodzić relacja lub. Wybieramy dni, kiedy poziom PM10 był dopuszczalny lub odnosiły się do pomiaru w 2015 roku.\n\nsmog_dop_lub_2015 &lt;- smog %&gt;%\n    filter(poziom == \"dopuszczalny\" | rok == 2015)\n\nMożliwy jest także wybór wielu kryteriów filtrowania poprzez operator %in%:\n\nsmog_poziomy &lt;- smog %&gt;%\n  filter(poziom %in% c(\"dopuszczalny\", \"w normie\"))\n\nsmog_2015_2017 &lt;- smog %&gt;%\n  filter(rok %in% 2015:2017)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#wybieranie-kolumn",
    "href": "03-przetwarzanie.html#wybieranie-kolumn",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.4 Wybieranie kolumn",
    "text": "3.4 Wybieranie kolumn\nDo wyboru kolumn służy funkcja select(). Zmodyfikujemy wcześniej utworzony zbiór smog_dop:\n\nsmog_dop &lt;- smog %&gt;%\n  filter(poziom == \"dopuszczalny\") %&gt;% \n  select(data, pm10, tmax_daily)\n\nTen sam kod możemy zapisać zagnieżdżając funkcje, ale traci on w ten sposób na czytelności:\n\nsmog_dop &lt;- select(filter(smog, poziom == \"dopuszczalny\"), data, pm10, tmax_daily)\n\nMożemy także wskazać, które zmienne nie mają znaleźć się w zbiorze wynikowym:\n\nsmog_dop &lt;- smog %&gt;%\n  filter(poziom == \"dopuszczalny\") %&gt;% \n  select(-poziom)\n\nNatomiast jeśli zmiennych jest więcej to musimy jest umieścić w wektorze, żeby nie pisać przed każdą zmienną znaku minus:\n\nsmog_dop &lt;- smog %&gt;%\n  filter(poziom == \"dopuszczalny\") %&gt;% \n  select(-poziom, -dzien_tyg, -kwartal, -rok)\n\n\nsmog_dop &lt;- smog %&gt;%\n  filter(poziom == \"dopuszczalny\") %&gt;% \n  select(-c(poziom, dzien_tyg, kwartal, rok))\n\nZ wykorzystaniem znaku dwukropka możemy także wskazywać zakresy zmiennych:\n\nsmog_dop &lt;- smog %&gt;%\n  filter(poziom == \"dopuszczalny\") %&gt;% \n  select(-poziom, -c(dzien_tyg:rok))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#tworzenie-nowych-zmiennych",
    "href": "03-przetwarzanie.html#tworzenie-nowych-zmiennych",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.5 Tworzenie nowych zmiennych",
    "text": "3.5 Tworzenie nowych zmiennych\nDo utworzenia nowej zmiennej wykorzystuje się funkcję mutate(). Utwórzmy w naszym zbiorze nową zmienną, która będzie różnicę pomiędzy najwyższą a najniższą temperaturą:\n\nsmog_dop &lt;- smog %&gt;%\n  filter(poziom == \"dopuszczalny\") %&gt;% \n  select(-poziom, -c(dzien_tyg:rok)) %&gt;% \n  mutate(amplituda=tmax_daily-tmin_daily)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#zmiana-nazwy-zmiennej",
    "href": "03-przetwarzanie.html#zmiana-nazwy-zmiennej",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.6 Zmiana nazwy zmiennej",
    "text": "3.6 Zmiana nazwy zmiennej\nDo zmiany nazw zmiennych służy funkcja rename(). Najpierw podajemy nazwę nowej zmiennej, a po znaku równości starą nazwę:\n\nsmog &lt;- smog %&gt;%\n  rename(tmean_daily=t2m_mean_daily)\n\nZmiany nazwy można także dokonać z wykorzystaniem funkcji select:\n\nsmog_nowy &lt;- smog %&gt;%\n  select(data, pm10, pm10_poziom=poziom)\n\nW takim przypadku trzeba jednak pamiętać o wypisaniu wszystkich zmiennych, które mają się znaleźć w zbiorze wynikowym.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#podsumowanie-danych",
    "href": "03-przetwarzanie.html#podsumowanie-danych",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.7 Podsumowanie danych",
    "text": "3.7 Podsumowanie danych\nFunkcja summarise() służy do podsumowań danych w formie zagregowanej:\n\nsmog %&gt;%\n  summarise(pm10_srednia=mean(pm10, na.rm=T),\n            pm10_mediana=median(pm10, na.rm=T))\n\n# A tibble: 1 × 2\n  pm10_srednia pm10_mediana\n         &lt;dbl&gt;        &lt;dbl&gt;\n1         51.6         34.5\n\n\nPodsumowanie danych ma najwięcej sensu w połączeniu z funkcją grupującą.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#grupowanie",
    "href": "03-przetwarzanie.html#grupowanie",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.8 Grupowanie",
    "text": "3.8 Grupowanie\nDo grupowania obserwacji służy funkcja group_by(). Zobaczmy jak wyglądają statystyki PM10 w poszczególnych kwartałach:\n\nsmog %&gt;%\n  group_by(kwartal) %&gt;%\n  summarise(pm10_srednia=mean(pm10, na.rm=T),\n            pm10_mediana=median(pm10, na.rm=T))\n\n# A tibble: 4 × 3\n  kwartal   pm10_srednia pm10_mediana\n  &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;\n1 Kwartał 1         86.6         67  \n2 Kwartał 2         32.4         29.0\n3 Kwartał 3         27.5         25.6\n4 Kwartał 4         62.0         49.4\n\n\nPo przecinku w funkcji group_by() można wskazać kolejne zmienne grupujące:\n\nsmog %&gt;%\n  group_by(rok, kwartal) %&gt;%\n  summarise(pm10_srednia=mean(pm10, na.rm=T),\n            pm10_mediana=median(pm10, na.rm=T))\n\n`summarise()` has grouped output by 'rok'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 20 × 4\n# Groups:   rok [5]\n     rok kwartal   pm10_srednia pm10_mediana\n   &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;\n 1  2015 Kwartał 1         76.2         69.1\n 2  2015 Kwartał 2         32.0         28.9\n 3  2015 Kwartał 3         30.0         29.5\n 4  2015 Kwartał 4         71.6         53.8\n 5  2016 Kwartał 1         85.2         57.5\n 6  2016 Kwartał 2         36.4         33  \n 7  2016 Kwartał 3         29.7         25.6\n 8  2016 Kwartał 4         58.9         43.8\n 9  2017 Kwartał 1        115.          75  \n10  2017 Kwartał 2         30.1         27.2\n11  2017 Kwartał 3         25.3         22.2\n12  2017 Kwartał 4         53.3         43.0\n13  2018 Kwartał 1         90.0         77.6\n14  2018 Kwartał 2         32.8         30.5\n15  2018 Kwartał 3         29.3         28  \n16  2018 Kwartał 4         67.2         53.0\n17  2019 Kwartał 1         65.2         51.8\n18  2019 Kwartał 2         30.6         26.3\n19  2019 Kwartał 3         23.4         21.8\n20  2019 Kwartał 4         59.6         51.7\n\n\nPrzydatna jest także funkcja n(), która nie przyjmuje żadnego argumentu i zwraca liczebność zbioru bądź grupy.\n\nsmog %&gt;%\n  group_by(kwartal) %&gt;%\n  summarise(liczebnosc=n(),\n            pm10_srednia=mean(pm10, na.rm=T),\n            pm10_mediana=median(pm10, na.rm=T))\n\n# A tibble: 4 × 4\n  kwartal   liczebnosc pm10_srednia pm10_mediana\n  &lt;chr&gt;          &lt;int&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n1 Kwartał 1        451         86.6         67  \n2 Kwartał 2        455         32.4         29.0\n3 Kwartał 3        460         27.5         25.6\n4 Kwartał 4        460         62.0         49.4\n\n\nJeżeli chcemy tylko wyznaczyć liczebności grup to możemy skorzystać z funkcji count():\n\nsmog %&gt;%\n  group_by(kwartal) %&gt;%\n  count()\n\n# A tibble: 4 × 2\n# Groups:   kwartal [4]\n  kwartal       n\n  &lt;chr&gt;     &lt;int&gt;\n1 Kwartał 1   451\n2 Kwartał 2   455\n3 Kwartał 3   460\n4 Kwartał 4   460\n\n\nJedną z kategorii zmiennej poziom jest brak danych (NA). Zamienimy tą wartość na kategorię nieustalony z wykorzystaniem funkcji mutate() oraz if_else(). Funkcja if_else() przyjmuje trzy argumenty - pierwszy (condition =) to warunek, który jest weryfikowany, następnie podajemy wartość, która ma być wprowadzona w przypadku spełnienia warunku (true =), a na końcu wartość dla niespełnionego warunku (false =). Jest to odpowiednik funkcji JEŻELI z Excela.\nW omawianym przykładzie warunkiem jest sprawdzenie czy wartości zmiennej poziom są równe NA. Jeśli tak to na ich miejsce wprowadzany jest tekst nieustalony, a w przeciwnym przypadku pozostaje oryginalna wartość.\n\nsmog %&gt;%\n  mutate(poziom=if_else(is.na(poziom), \"nieustalony\", poziom)) %&gt;%\n  group_by(poziom) %&gt;%\n  count()\n\n# A tibble: 5 × 2\n# Groups:   poziom [5]\n  poziom           n\n  &lt;chr&gt;        &lt;int&gt;\n1 alarmowy        11\n2 dopuszczalny   521\n3 informowania    26\n4 nieustalony     36\n5 w normie      1232",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#sortowanie",
    "href": "03-przetwarzanie.html#sortowanie",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.9 Sortowanie",
    "text": "3.9 Sortowanie\nSortowanie jest możliwe z wykorzystaniem funkcji arrange(). Jako argument podajemy zmienną według, której chcemy posortować zbiór. Domyślne zbiór sortowany jest rosnąco - od wartości najmniejszych do największych:\n\nsmog_sort &lt;- smog %&gt;%\n  arrange(pm10)\n\nZmiana kierunku sortowania jest możliwa po zastosowaniu funkcji desc():\n\nsmog_sort &lt;- smog %&gt;%\n  arrange(desc(pm10))\n\nSortowanie możemy także zastosować do wyników podsumowania danych:\n\nsmog %&gt;%\n  group_by(kwartal) %&gt;%\n  summarise(liczebnosc=n(),\n            pm10_srednia=mean(pm10, na.rm=T),\n            pm10_mediana=median(pm10, na.rm=T)) %&gt;% \n  arrange(pm10_mediana)\n\n# A tibble: 4 × 4\n  kwartal   liczebnosc pm10_srednia pm10_mediana\n  &lt;chr&gt;          &lt;int&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n1 Kwartał 3        460         27.5         25.6\n2 Kwartał 2        455         32.4         29.0\n3 Kwartał 4        460         62.0         49.4\n4 Kwartał 1        451         86.6         67",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#łączenie-zbiorów",
    "href": "03-przetwarzanie.html#łączenie-zbiorów",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.10 Łączenie zbiorów",
    "text": "3.10 Łączenie zbiorów\nW celu zaprezentowania funkcji łączących dane przygotujemy kilka zbiorów pomocniczych:\n\ndane_pm10 &lt;- smog %&gt;%\n  select(data, pm10, poziom) %&gt;% \n  filter(complete.cases(.))\n\ndane_temp &lt;- smog %&gt;% \n  select(data, starts_with(\"t\")) %&gt;% \n  filter(complete.cases(.))\n\ndane_wiatr &lt;- smog %&gt;% \n  select(data, starts_with(\"rr\")) %&gt;% \n  filter(complete.cases(.))\n\nDo łączenia dwóch zbiorów danych służy funkcja inner_join(), która jako argumenty przyjmuje nazwy zbiorów danych oraz klucz łączenia. Jeśli w obu zbiorach występują kolumny o takich samych nazwach to zostaną potraktowane jako klucz łączenia:\n\ndane_pm10_temp &lt;- inner_join(dane_pm10, dane_temp)\n\nJoining with `by = join_by(data)`\n\n\nJeśli takie kolumny nie będą istniały to wywołanie funkcji zwróci błąd. W takich przypadku należy wskazać klucz połączenia. Można to zrobić na kilka równoważnych sposobów:\n\ndane_pm10_temp &lt;- inner_join(dane_pm10, dane_temp, by = join_by(data))\ndane_pm10_temp &lt;- inner_join(dane_pm10, dane_temp, by = \"data\")\ndane_pm10_temp &lt;- inner_join(dane_pm10, dane_temp, by = c(\"data\"=\"data\"))\n\nJeśli w jednym ze zbiorów nie ma wszystkich identyfikatorów, które znajdują się w drugim zbiorze to zastosowanie funkcji inner_join() będzie skutkowało zbiorem, w którym znajdą się tylko te obserwacje, które udało się połączyć. Jeśli chcemy pozostawić niedopasowane obserwacje to należy wykorzystać jedną z funkcji - left_join() lub right_join() w zależności od tego dla którego zbioru chcemy pozostawić wszystkie informacje, lub full_join() w przypadku wszystkich obserwacji.\n\ndane_temp_pm10 &lt;- left_join(dane_temp, dane_pm10)\n\nJoining with `by = join_by(data)`\n\n\nW brakujących wierszach zostaną wstawione braki danych.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#szeroka-i-wąska-reprezentacja-danych",
    "href": "03-przetwarzanie.html#szeroka-i-wąska-reprezentacja-danych",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.11 Szeroka i wąska reprezentacja danych",
    "text": "3.11 Szeroka i wąska reprezentacja danych\nDane mogą występować w reprezentacji szerokiej i wąskiej. Reprezentacja szeroka to najczęściej spotykany format danych, kiedy w wierszach mamy obiekty, a w kolumnach dane opisujące te obiekty. Przykładem takiego zbioru może być np. zbiór dane_temp. Taka tabela jest przykładem szerokiej reprezentacji danych. Z kolei w niektórych sytuacjach wygodnie jest korzystać z wąskiej reprezentacji danych, a niektóre pakiety wręcz wymagają takich zbiorów wejściowych.\nDo transformacji danych z reprezentacji szerokiej na wąską służą funkcje z pakietu tidyr - w tym przypadku pivot_longer().\n\ndane_long &lt;- dane_temp %&gt;% \n  pivot_longer(tmax_daily:tmin_soil)\n\nhead(dane_long)\n\n# A tibble: 6 × 3\n  data       name        value\n  &lt;date&gt;     &lt;chr&gt;       &lt;dbl&gt;\n1 2015-01-01 tmax_daily    0.2\n2 2015-01-01 tmin_daily   -4.6\n3 2015-01-01 tmean_daily  -2.3\n4 2015-01-01 tmin_soil    -4.4\n5 2015-01-02 tmax_daily    6.9\n6 2015-01-02 tmin_daily   -2.9\n\n\nW takiej formie łatwiej podsumować dane:\n\ndane_long %&gt;%\n  group_by(name) %&gt;%\n  summarise(srednia=mean(value),\n            mediana=median(value))\n\n# A tibble: 4 × 3\n  name        srednia mediana\n  &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;\n1 tmax_daily    14.9     14.8\n2 tmean_daily    9.66     9.5\n3 tmin_daily     5.00     4.9\n4 tmin_soil      2.50     2.3\n\n\nW porównaniu do szerokiej reprezentacji danych:\n\ndane_temp %&gt;% \n  summarise(across(tmax_daily:tmin_soil,\n                     list(\n                       srednia = ~mean(.x, na.rm = TRUE),\n                       mediana = ~median(.x, na.rm = TRUE))))\n\n# A tibble: 1 × 8\n  tmax_daily_srednia tmax_daily_mediana tmin_daily_srednia tmin_daily_mediana\n               &lt;dbl&gt;              &lt;dbl&gt;              &lt;dbl&gt;              &lt;dbl&gt;\n1               14.9               14.8               5.00                4.9\n# ℹ 4 more variables: tmean_daily_srednia &lt;dbl&gt;, tmean_daily_mediana &lt;dbl&gt;,\n#   tmin_soil_srednia &lt;dbl&gt;, tmin_soil_mediana &lt;dbl&gt;\n\n\nTransformacja z wąskiej do szerokiej reprezentacji danych jest możliwa z zastosowaniem funkcji pivot_wider().\n\ndane_wide &lt;- dane_long %&gt;%\n  pivot_wider()\n\nhead(dane_wide)\n\n# A tibble: 6 × 5\n  data       tmax_daily tmin_daily tmean_daily tmin_soil\n  &lt;date&gt;          &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n1 2015-01-01        0.2       -4.6        -2.3      -4.4\n2 2015-01-02        6.9       -2.9         2.3      -4.4\n3 2015-01-03        3.4        0           1.3      -0.5\n4 2015-01-04        2.5       -0.5         1.1      -1.5\n5 2015-01-05        1.4       -3          -1.1     -10.9\n6 2015-01-06       -1.9       -8.7        -5.4     -13.9\n\n\nTaka forma danych może być też przydatna do przygotowania zbiorów z podsumowaniami.\n\nsmog_rok_kw &lt;- smog %&gt;%\n  group_by(rok, kwartal) %&gt;%\n  summarise(pm10_srednia=round(mean(pm10, na.rm=T),1))\n\n`summarise()` has grouped output by 'rok'. You can override using the `.groups`\nargument.\n\nhead(smog_rok_kw)\n\n# A tibble: 6 × 3\n# Groups:   rok [2]\n    rok kwartal   pm10_srednia\n  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n1  2015 Kwartał 1         76.2\n2  2015 Kwartał 2         32  \n3  2015 Kwartał 3         30  \n4  2015 Kwartał 4         71.6\n5  2016 Kwartał 1         85.2\n6  2016 Kwartał 2         36.4\n\n\n\nsmog_rok_kw %&gt;% \n  pivot_wider(names_from = kwartal, values_from = pm10_srednia)\n\n# A tibble: 5 × 5\n# Groups:   rok [5]\n    rok `Kwartał 1` `Kwartał 2` `Kwartał 3` `Kwartał 4`\n  &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n1  2015        76.2        32          30          71.6\n2  2016        85.2        36.4        29.7        58.9\n3  2017       115          30.1        25.3        53.3\n4  2018        90          32.8        29.3        67.2\n5  2019        65.2        30.6        23.4        59.6",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#zadania",
    "href": "03-przetwarzanie.html#zadania",
    "title": "3  Wczytywanie i przetwarzanie danych",
    "section": "3.12 Zadania",
    "text": "3.12 Zadania\n\n3.12.1 Rossmann\nNa podstawie zbioru Rossmann odpowiedź na pytania:\n\nIle było sklepów o asortymencie rozszerzonym w dniu 25-02-2014?\nW jaki dzień tygodnia średnia liczba klientów była największa w sklepie nr 101?\nSklep jakiego typu charakteryzuje się największą medianą sprzedaży?\nCzy w ciągu roku odległość do najbliższego sklepu konkurencji zmieniła się dla jakiegokolwiek sklepu Rossmann?\nPołącz dane ze sklepów Rossmann z danymi o średnim kursie EUR/PLN z 2014 roku, który można pobrać ze strony NBP. Przelicz wielkość sprzedaży na złotówki.\n\n\n\n3.12.2 Wybory 2020\nNa podstawie zbioru dotyczącego wyborów prezydenckich w 2020 roku odpowiedź na pytania:\n\nIle obwodów głosowania miało frekwencję powyżej 80%?\nIle obwodów głosowania znajduje się w Poznaniu?\n\nIle jest obwodów według typu obszaru?\nJaka była średnia frekwencja w województwach?\nGdzie była największa różnica pomiędzy kandydatami?\n\n\n\n3.12.3 Mistrzostwa Świata\nNa podstawie zbioru dotyczącego wyników meczów rozegranych w ramach Mistrzostw Świata odpowiedź na pytania:\n\nIle razy Włochy grały w finale MŚ?\nJaka jest największa liczba bramek w jednym meczu?\n\nJakie miasto najczęściej gościło piłkarzy?\nJaka była średnia liczba widzów?\nIle było meczów, w których drużyna prowadząca po pierwszej połowie ostatecznie przegrywała?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wczytywanie i przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html",
    "href": "05-wizualizacja.html",
    "title": "4  Wizualizacja danych",
    "section": "",
    "text": "4.1 Wprowadzenie\nPrezentacja\nBędziemy działać na zbiorze dotyczącym sprzedaży w sklepach: rossmann.xlsx.\nlibrary(tidyverse)\nlibrary(readxl)\n\nrossmann &lt;- read_xlsx(\"data/rossmann.xlsx\")\n\nsklep77 &lt;- rossmann %&gt;%\n  filter(sklep_id==77, czy_otwarty==\"Tak\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html#pakiet-graphics",
    "href": "05-wizualizacja.html#pakiet-graphics",
    "title": "4  Wizualizacja danych",
    "section": "4.2 Pakiet graphics",
    "text": "4.2 Pakiet graphics\nDo prostych wykresów można wykorzystać wbudowane funkcje z pakietu graphics.\nPakiet graphics oferuje podstawowe funkcje do tworzenia wykresów w R. Ten pakiet jest szybki, prosty i wystarczający do wielu typowych zastosowań.\n\n4.2.1 Wykres punktowy\nFunkcja plot() jest bardzo elastyczna i może tworzyć różne typy wykresów w zależności od typu danych.\n\nx &lt;- 1:10\ny &lt;- x^2\n\n# Wykres punktowy\nplot(x, y)\n\n\n\n\n\n\n\n# Wykres liniowy\nplot(x, y, type = \"l\")\n\n\n\n\n\n\n\n# Punkty i linia\nplot(x, y, type = \"b\", col = \"blue\", pch = 19)\n\n\n\n\n\n\n\n\n\nplot(sklep77$sprzedaz, sklep77$liczba_klientow, \n     xlab = \"Sprzedaż\", ylab = \"Liczba klientów\",\n     main = \"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\")\n\n\n\n\n\n\n\n\nNajważniejsze argumenty\n\ntype: \"p\" (punkty), \"l\" (linia), \"b\" (oba), \"h\" (słupki pionowe), itd.\nmain: tytuł wykresu,\nxlab, ylab: etykiety osi,\ncol: kolor,\npch: typ punktu (np. 19 = kółko wypełnione),\nlwd: grubość linii.\n\n\n\n4.2.2 Histogram\nSłuży do przedstawienia rozkładu zmiennej ciągłej.\n\ndane &lt;- rnorm(100)\nhist(dane, main = \"Histogram\", xlab = \"Wartości\", col = \"lightblue\", breaks = 10)\n\n\n\n\n\n\n\n\nNajważniejsze argumenty:\n\nbreaks: liczba (lub lokalizacja) przedziałów,\ncol: kolor słupków,\nfreq: czy na osi Y mają być liczby (TRUE) czy gęstość (FALSE),\nmain, xlab: tytuł i etykieta osi.\n\n\n\n4.2.3 Wykres słupkowy\nUżywany głównie do prezentacji danych kategorycznych.\n\ndane &lt;- table(c(\"A\", \"B\", \"A\", \"C\", \"B\", \"B\"))\nbarplot(dane, main = \"Wykres słupkowy\", col = \"orange\", xlab = \"Kategorie\")\n\n\n\n\n\n\n\n\nNajważniejsze argumenty:\n\nhoriz: wykres poziomy (TRUE/FALSE),\ncol: kolory słupków,\nnames.arg: niestandardowe etykiety osi X,\nbeside: oddzielne słupki dla grup (gdy dane są macierzą),\nylim, xlim: zakresy osi.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html#pakiet-ggplot2",
    "href": "05-wizualizacja.html#pakiet-ggplot2",
    "title": "4  Wizualizacja danych",
    "section": "4.3 Pakiet ggplot2",
    "text": "4.3 Pakiet ggplot2\nWiodącym pakietem do wizualizacji danych w R jest obecnie ggplot2:\n\ndokumentacja: https://ggplot2.tidyverse.org/\ncheatsheet\ntworzenie wykresów poprzez dodawanie (+) kolejnych warstw\n\n\n4.3.1 Wykres punktowy\nTen sam wykres co wcześniej, ale z wykorzystaniem pakietu ggplot2.\n\n\n\n\n\n\n\n\n\nWykonanie krok po kroku:\n\nUtworzenie siatki - określenie co chcemy na wykresie przedstawić\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow))\n\n\n\n\n\n\n\n\nW zależności od typu wykresu w funkcji aes mogą znaleźć się argumenty:\n\nx\ny\nfill\nsize\ncolor\nshape\n\n\nOkreślenie w jaki sposób chcemy te dane przedstawić - funkcja zawsze zaczyna się od geom_:\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nEdytowanie etykiet osi - funkcje xlab i ylab:\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\")\n\n\n\n\n\n\n\n\n\nDodanie tytułu - funkcja ggtitle\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\")\n\n\n\n\n\n\n\n\n\nZmiana motywu - funkcja rozpoczynająca się od theme_:\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\n\n\n\n\nDostępne motywy:\n\ntheme_bw\ntheme_classic\ntheme_dark\ntheme_gray\ntheme_light\ntheme_linedraw\ntheme_minimal\ntheme_void\n\nPowyższe motywy są zaimplementowane w pakiecie ggplot2, ale można także skorzystać z dodatkowych pakietów:\n\ntheme_bbc\ntheme_xkcd\n\nAlbo stworzyć swój własny motyw.\nZadanie\nZmień motyw wykresu na wybrany przez siebie.\nDodamy teraz do wykresu kolejną cechę - rozpoczęcie promocji, żeby sprawdzić czy istnieje jakaś tendencja.\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\n\n\n\n\nOkazuje się dosyć interesująco, niemniej nazwa etykiety legendy nie wygląda zbyt dobrze. Żeby to poprawić musimy użyć funkcji scale_\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\n\n\n\n\nW funkcji scale_ musimy podać w jaki sposób daną cechę wizualizujemy (x/y/color/…) oraz jakiego jest typu. Oprócz nazwy w tej funkcji możemy określić wiele innych kwestii takich jak:\n\nwyświetlane etykiety\npoczątek i koniec osi\nkolory wariantów\netykiety wariantów\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\n\n\n\n\nZmiana pozycji legendy możliwa jest z wykorzystaniem funkcji theme:\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light() +\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html#histogram-1",
    "href": "05-wizualizacja.html#histogram-1",
    "title": "4  Wizualizacja danych",
    "section": "4.4 Histogram",
    "text": "4.4 Histogram\nRozkład cechy można ocenić na podstawie histogramu - domyślnie rysowanych jest 30 słupków.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nW funkcji geom_histogram można podać liczbę słupków (bins) albo ich szerokość (binwidth). Poniżej zastosowano słupki o szerokości 1000 euro.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 1000)\n\n\n\n\n\n\n\n\nDodatkowo w tej funkcji można określić kwestie estetyczne - kolory obramowania i wypełnienia słupków.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 500, color = \"black\", fill = \"green\")\n\n\n\n\n\n\n\n\nPełna lista nazw kolorów znajduje się tutaj.\nZ wykorzystaniem funkcji scale_ zmieniamy nazwy osi (name), granice (limits) oraz wskazania liczbowe (breaks). Te dwie ostatnie wartości musimy deklarować jako wektory z wykorzystaniem funkcji c().\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 500, \n                 color = \"black\", fill = \"green\") +\n  scale_x_continuous(name = \"Sprzedaż\", \n                     limits = c(4000,17000),\n                     breaks = c(5000, 8000, 11000)) +\n  scale_y_continuous(name = \"Liczebność\",\n                     limits = c(0,50))\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_bar()`).\n\n\n\n\n\n\n\n\n\nMożna zautomatyzować proces dobierania wskazań liczbowych z wykorzystaniem funkcji seq opisanej szerzej w rozdziale 2.1.2.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 500, \n                 color = \"black\", fill = \"green\") +\n  scale_x_continuous(name = \"Sprzedaż\", \n                     limits = c(4000,17000),\n                     breaks = seq(4000, 17000, 1500)) +\n  scale_y_continuous(name = \"Liczebność\",\n                     limits = c(0,50))\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_bar()`).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html#wykres-pudełkowy",
    "href": "05-wizualizacja.html#wykres-pudełkowy",
    "title": "4  Wizualizacja danych",
    "section": "4.5 Wykres pudełkowy",
    "text": "4.5 Wykres pudełkowy\nWykres pudełkowy umożliwia porównywanie rozkładów cechy wg zmiennej grupującej. Wymogiem jest aby na osi x znajdowała się zmienna grupująca, a na osi y cecha analizowana.\nPrzeanalizujemy sprzedaż według kolejnych dni tygodnia.\n\nggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) + geom_boxplot()\n\nWarning: Continuous x aesthetic\nℹ did you forget `aes(group = ...)`?\n\n\n\n\n\n\n\n\n\nZdecydowanie nie jest wykres jakiego oczekiwaliśmy. Wynika to z faktu, że dzień tygodnia w zbiorze danych jest zapisany jako zmienna numeryczna, natomiast prawidłowym typem dla zmiennej grupującej jest typ tekstowy lub czynnik (faktor). Ten typ danych został szczegółowo opisany w części 2.3.\nDokonujemy zatem zamiany typu danych:\n\nsklep77 &lt;- sklep77 %&gt;%\n  mutate(dzien_tyg=factor(x = dzien_tyg,\n                          levels = 1:6,\n                          labels = c(\"Pon\", \"Wt\", \"Śr\", \"Czw\", \"Pt\", \"Sob\"),\n                          ordered = TRUE))\n\nggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) +\n  geom_boxplot() \n\n\n\n\n\n\n\n\nZ tego wykresu można już odczytać, że najwyższa mediana sprzedaży występuje w poniedziałek, a najniższa w środę.\nZamiana ról x i y powoduje wyświetlanie dni tygodnia na osi x, co może być przydatne w przypadku bardzo licznych kategorii. W tej sytuacji jednak na samej górze wykresu jest Sobota. Do zarządzania kolejnością wyświetlania kategorii na wykresach najlepiej posłużyć się funkcji z pakietu forcats.\n\nggplot(sklep77, aes(x=sprzedaz, y=dzien_tyg)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nFunkcja fct_rev() odwraca kolejność poziomów czynnika, co jest przydatne, gdy chcemy zmienić kierunek wyświetlania na wykresie.\n\nggplot(sklep77, aes(x=sprzedaz, y=fct_rev(dzien_tyg))) +\n  geom_boxplot()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html#wykres-słupkowy-1",
    "href": "05-wizualizacja.html#wykres-słupkowy-1",
    "title": "4  Wizualizacja danych",
    "section": "4.6 Wykres słupkowy",
    "text": "4.6 Wykres słupkowy\nW zależności od typu danych wejściowych, wykres słupkowy można stworzyć na dwa sposoby:\n\ndane jednostkowe - geom_bar - funkcja sama oblicza wartości do wyświetlenia,\ndane zagregowane - geom_col - funkcja otrzymuje już obliczone wartości.\n\nSprawdźmy ile jest sklepów o danym asortymencie. W tym celu potrzebujemy informację o sklepie i typie oferowanego asortymentu.\n\nrossmann_asort &lt;- rossmann %&gt;%\n  select(sklep_id, sklep_asort) %&gt;%\n  distinct()\n\nW funkcji aes podajemy tylko kolumnę zawierającą dane do zliczenia.\n\nggplot(rossmann_asort, aes(x=sklep_asort)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nNatomiast użycie funkcji geom_col wymaga samodzielnego obliczenia wartości:\n\nrossmann_asort2 &lt;- rossmann_asort %&gt;%\n  count(sklep_asort)\n\nglimpse(rossmann_asort2)\n\nRows: 3\nColumns: 2\n$ sklep_asort &lt;chr&gt; \"Extra\", \"Podstawowy\", \"Rozszerzony\"\n$ n           &lt;int&gt; 9, 593, 513\n\n\nWartość do wyświetlenia podajemy w funkcji aes w argumencie y.\n\nggplot(rossmann_asort2, aes(x=sklep_asort, y=n)) +\n  geom_col()\n\n\n\n\n\n\n\n\nFunkcja fct_reorder() z pakietu forcats, pozwalająca na uporządkowanie poziomów czynnika według wartości innej zmiennej.\n\nggplot(rossmann_asort2, aes(x=fct_reorder(sklep_asort, n), y=n)) +\n  geom_col()\n\n\n\n\n\n\n\n\n\nggplot(rossmann_asort2, aes(x=fct_reorder(sklep_asort, n, .desc=T), y=n)) +\n  geom_col()\n\n\n\n\n\n\n\n\nDo wykresu słupkowego możemy dodać jeszcze jedną zmienną. W tym przypadku będzie to typ sklepu. Dodatkowo skorzystamy z funkcji fct_inorder(), która porządkuje poziomy według kolejności, w jakiej pojawiły się w danych.\n\nrossmann_asort3 &lt;- rossmann %&gt;%\n  select(sklep_id, sklep_asort, sklep_typ) %&gt;%\n  distinct() %&gt;%\n  count(sklep_asort, sklep_typ) %&gt;%\n  mutate(sklep_asort=fct_infreq(sklep_asort))\n\nUwzględnienie kolejnej zmiennej jest możliwe jako argument fill w funkcji aes.\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col()\n\n\n\n\n\n\n\n\nDomyślnie kategorie są układane jedna na drugą - stack. Można je ułożyć obok siebie dodając argument position = \"dodge\" w funkcji geom_col.\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col(position = \"dodge\")\n\n\n\n\n\n\n\n\nMożemy jeszcze dodać etykiety słupków wykorzystując funkcję geom_text, w której trzeba podać argumenty definiujące położenie wartości etykiet. Wartości tych argumentów będą zależały od typu wykresu.\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col(position = \"dodge\") + \n  geom_text(aes(label = n), \n            position = position_dodge(width = 0.9),\n            vjust = -0.3)\n\n\n\n\n\n\n\n\nZmienimy jeszcze nazwę legendy za pomocą funkcji scale_fill_discrete. Wykorzystujemy tę konkretną funkcję ze względu na to, że typ sklepu jest argumentem fill w funkcji aes oraz cechą jakościową (discrete).\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col(position = \"dodge\") + \n  geom_text(aes(label = n), \n            position = position_dodge(width = 0.9),\n            vjust = -0.3) +\n  scale_fill_discrete(name = \"Typ sklepu\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html#wykres-kafelkowy",
    "href": "05-wizualizacja.html#wykres-kafelkowy",
    "title": "4  Wizualizacja danych",
    "section": "4.7 Wykres kafelkowy",
    "text": "4.7 Wykres kafelkowy\nDo wizualizacji tabeli częstości można użyć wykresu kafelkowego. W tym celu najpierw zliczamy wystąpienia wariantów cech czy_promocja oraz czy_swieto_szkolne i wynik przekazujemy bezpośrednio do funkcji ggplot().\n\nsklep77 %&gt;%\n  count(czy_promocja, czy_swieto_szkolne) %&gt;%\n  ggplot(aes(x = czy_promocja, \n             y = czy_swieto_szkolne,\n             fill = n)) +\n  geom_tile()\n\n\n\n\n\n\n\n\nAby dodać do tego wykresu etykiety posłużymy się funkcją geom_label()\n\nsklep77 %&gt;%\n  count(czy_promocja, czy_swieto_szkolne) %&gt;%\n  ggplot(aes(x = czy_promocja, \n             y = czy_swieto_szkolne,\n             fill = n)) +\n  geom_tile() +\n  geom_label(aes(label = n), color = \"white\")\n\n\n\n\n\n\n\n\nZwykle patrząc na wykres podświadomie zakładamy, że ciemniejszy kolor oznacza wyższe wartości, natomiast jasny małe liczby. W tym przypadku układ kolorów jest odwrócony. Musimy odpowiednio dobrać kolory, aby to poprawić. Bardzo przydatne narzędzie znajduje się pod adresem: http://colorbrewer2.org/. Następnie korzystamy z funkcji scale_fill_gradient, w której określamy tylko kolor początkowy i końcowy.\n\nsklep77 %&gt;%\n  count(czy_promocja, czy_swieto_szkolne) %&gt;%\n  ggplot(., aes(x = czy_promocja, \n                y = czy_swieto_szkolne,\n                fill = n)) +\n  geom_tile() +\n  geom_label(aes(label = n), color = \"white\") +\n  scale_fill_gradient(low = \"#66c2a4\", \n                      high = \"#005824\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html#uwzględnienie-czasu",
    "href": "05-wizualizacja.html#uwzględnienie-czasu",
    "title": "4  Wizualizacja danych",
    "section": "4.8 Uwzględnienie czasu",
    "text": "4.8 Uwzględnienie czasu\nPróba stworzenia wykresu przedstawiającego zmianę sprzedaży w czasie za pomocą oryginalnych danych spowoduje uzyskanie niezbyt czytelnej grafiki.\n\nggplot(sklep77, aes(x=data,\n                    y=sprzedaz,\n                    color=dzien_tyg)) +\n  geom_point()\n\n\n\n\n\n\n\n\nWynika to z faktu, że dzień tygodnia jest traktowany jak zmienna numeryczna, a data jest zmienną tekstową. Konwersja tekstu na datę jest możliwa z wykorzystaniem pakietu lubridate. W tym pakiecie każda część daty ma swój akronim, który później jest wykorzystywany w odpowiednich funkcjach:\n\ny - rok (year)\nm - miesiąc (month)\nd - dzień (day)\nh - godzina (hour)\nm - minuta (minute)\n\nPrzykłady funkcji:\n\nymd - konwertuje tekst zapisany w postaci rok-miesiąc-dzień na obiekt daty\ndmy_hm - konwertuje tekst zapisany w postaci dzień-miesiąc-rok godzina:minuta na obiekt daty\nmonth - pobiera z obiektu daty informację o miesiącu\nyear - pobiera z obiektu daty informację o roku\nweek - pobiera z obiektu daty informację o tygodniu roku\n\nWedług powyższych reguł korzystamy z funkcji ymd() do konwersji daty w naszym zbiorze.\n\nlibrary(lubridate)\n\nsklep77a &lt;- sklep77 %&gt;%\n  mutate(dzien_tyg=as.factor(dzien_tyg),\n         data=ymd(data))\n\nggplot(sklep77a, aes(x=data,\n                    y=sprzedaz,\n                    color=dzien_tyg)) +\n  geom_point()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html#facets",
    "href": "05-wizualizacja.html#facets",
    "title": "4  Wizualizacja danych",
    "section": "4.9 Facets",
    "text": "4.9 Facets\nWykorzystanie płaszczyzn (ang. facets) pozwala na dodawanie kolejnych cech jakościowych do wykresów nawet w przypadku wyczerpania wszystkich domyślnych ról takich jak fill, color czy shape. W przypadku jednej cechy jej użycie musimy poprzedzić symbolem tyldy.\n\nggplot(sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  facet_wrap(~ czy_promocja)\n\n\n\n\n\n\n\n\nZastosowanie dla dwóch cech wygląda następująco.\n\nggplot(sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  facet_wrap(dzien_tyg ~ czy_promocja, scales = \"free\", nrow = 2)\n\n\n\n\n\n\n\n\nMożemy dodatkowo sterować zakresem osi (argument scales) oraz liczbą wierszy lub kolumn (nrow i ncol). W przypadku kiedy poziomy cechy tworzą macierz ładniejszym rozwiązaniem wizualnym jest użycie facet_grid().\n\nggplot(sklep77, aes(x=sprzedaz, y=liczba_klientow, color = czy_swieto_szkolne)) +\n  geom_point() +\n  facet_grid(dzien_tyg ~ czy_promocja)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html#wykres-interaktywny",
    "href": "05-wizualizacja.html#wykres-interaktywny",
    "title": "4  Wizualizacja danych",
    "section": "4.10 Wykres interaktywny",
    "text": "4.10 Wykres interaktywny\nZa pomocą pakietu plotly w prosty sposób można zamienić statystyczny wykres ggplot na interaktywny.\n\nlibrary(plotly)\n\np &lt;- ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n\nplotly::ggplotly(p)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-wizualizacja.html#zadania",
    "href": "05-wizualizacja.html#zadania",
    "title": "4  Wizualizacja danych",
    "section": "4.11 Zadania",
    "text": "4.11 Zadania\nWczytaj zbiór danych movies.csv zawierający dane dotyczące filmów.\n\nStwórz wykres przedstawiający zależność pomiędzy oceną a długością filmu.\n\n\n\n\n\n\n\n\n\n\n\nNa histogramach przedstaw rozkład ocen dla filmów akcji, komedii i dramatów (szerokość słupka 0,5).\n\n\n\nWarning: Removed 6 rows containing missing values or values outside the scale range\n(`geom_bar()`).\n\n\n\n\n\n\n\n\n\n\nPrzestaw na wykresie liczbę filmów wyreżyserowanych przez 10 reżyserów z największą liczbą filmów.\n\n\n\n\n\n\n\n\n\n\n\nPrzestaw na wykresie po 5 najlepiej ocenianych filmów z lat 2014-2016\n\n\n\n\n\n\n\n\n\n\n\nNa wykresie pudełkowym przedstaw rozkład długości filmów w kolejnych dekadach.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "06-programowanie.html",
    "href": "06-programowanie.html",
    "title": "5  Programowanie w R",
    "section": "",
    "text": "5.1 Wprowadzenie\nPrezentacja\nW odróżnieniu od treści prezentowanych w poprzednich rozdziałach, w tym nie będziemy korzystać z zewnętrznych pakietów. Zagadnienia związane z tworzeniem własnych funkcji oraz modyfikacją przepływu sterowania będą od nas wymagały poznania wielu różnych operatorów wbudowanych w bazowe pakiety R.\nW rozdziale skorzystamy ze sztucznie wygenerowanego zbioru danych:\nset.seed(123)\ndane &lt;- data.frame(x1=rnorm(10), x2=rnorm(10), x3=rnorm(10), x4=rnorm(10))\ndane\n\n            x1         x2         x3          x4\n1  -0.56047565  1.2240818 -1.0678237  0.42646422\n2  -0.23017749  0.3598138 -0.2179749 -0.29507148\n3   1.55870831  0.4007715 -1.0260044  0.89512566\n4   0.07050839  0.1106827 -0.7288912  0.87813349\n5   0.12928774 -0.5558411 -0.6250393  0.82158108\n6   1.71506499  1.7869131 -1.6866933  0.68864025\n7   0.46091621  0.4978505  0.8377870  0.55391765\n8  -1.26506123 -1.9666172  0.1533731 -0.06191171\n9  -0.68685285  0.7013559 -1.1381369 -0.30596266\n10 -0.44566197 -0.4727914  1.2538149 -0.38047100",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Programowanie w R</span>"
    ]
  },
  {
    "objectID": "06-programowanie.html#funkcje",
    "href": "06-programowanie.html#funkcje",
    "title": "5  Programowanie w R",
    "section": "5.2 Funkcje",
    "text": "5.2 Funkcje\nFunkcję ograniczają potrzebę kopiowania kodu i ułatwiają wprowadzanie zmian. Zamiast dodawać komentarze do dużej ilości kodu można opakować go w funkcję, co ułatwi zrozumienie programu. Jeśli istnieje potrzeba wprowadzenia zmian to wystarczy zrobić to w jednym miejscu.\nStworzenie funkcji wymaga:\n\nwymyślenia nazwy funkcji,\nokreślenia elementów wejściowych,\numieszczenia kodu w ciele funkcji.\n\nIstnieją pewne dobre praktyki tworzenia funkcji:\n\nnazwy funkcji powinny być czasownikami,\npodkreślnik vs. notacja camelCase i konsekwencja stosowania,\nwspólny przedrostek np. rnorm, runif.\n\nPodstawowa składnia definiowania funkcji w R:\nnazwa_funkcji &lt;- function(argument1, argument2, ...) {\n  # ciało funkcji - zbiór instrukcji\n  \n  # zwracana wartość\n  return(wynik)\n}\nPrzykład prostej funkcji, która oblicza wskaźnik będący stosunkiem średniej do odchylenia standardowego:\noblicz_wskaznik &lt;- function(x) {\n  wskaznik &lt;- mean(x) / sd(x)\n  return(wskaznik)\n}\nW R można definiować funkcje na kilka sposobów, które różnią się składnią, ale działają identycznie:\n\n# Sposób 1 - pełna składnia z nawiasami klamrowymi i return\nnormalize &lt;- function(x) {\n  return((x - min(x)) / (max(x) - min(x)))\n}\n\n# Sposób 2 - bez jawnego return\nnormalize &lt;- function(x) {\n  (x - min(x)) / (max(x) - min(x))\n}\n\n# Sposób 3 - skrócona składnia, bez klamr\nnormalize &lt;- function(x) (x - min(x)) / (max(x) - min(x))\n\n# Sposób 4 - nowoczesna składnia od R 4.1 z operatorem \\()\nnormalize &lt;- \\(x) (x - min(x)) / (max(x) - min(x))\n\nW każdym z powyższych przypadków funkcja robi to samo - normalizuje wartości wektora do przedziału [0, 1].\nFunkcje najlepiej tworzyć, gdy: - Powtarzamy ten sam fragment kodu wielokrotnie - Chcemy uporządkować logicznie kod - Chcemy stworzyć narzędzie wielokrotnego użytku\nPrzykład zastosowania funkcji do normalizacji danych:\n\n# Zastosowanie funkcji normalize dla każdej kolumny\ndane$z1 &lt;- normalize(dane$x1)\ndane$z2 &lt;- normalize(dane$x2)\ndane$z3 &lt;- normalize(dane$x3)\ndane$z4 &lt;- normalize(dane$x4)\n\n# Wizualizacja efektu normalizacji\nplot(dane$x1, dane$z1)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Programowanie w R</span>"
    ]
  },
  {
    "objectID": "06-programowanie.html#instrukcje-warunkowe",
    "href": "06-programowanie.html#instrukcje-warunkowe",
    "title": "5  Programowanie w R",
    "section": "5.3 Instrukcje warunkowe",
    "text": "5.3 Instrukcje warunkowe\nZa pomocą instrukcji if możemy warunkowo wykonywać kod. Ogólna postać jest następująca:\nPodstawowa składnia:\nif (warunek) {\n  # kod wykonywany, gdy warunek jest TRUE\n} else {\n  # kod wykonywany, gdy warunek jest FALSE\n}\nRozszerzona składnia if-else if-else:\nif (warunek1) {\n  # kod wykonywany, gdy warunek1 jest TRUE\n} else if (warunek2) {\n  # kod wykonywany, gdy warunek1 jest FALSE, ale warunek2 jest TRUE\n} else {\n  # kod wykonywany, gdy oba warunki są FALSE\n}\nElement warunek musi zwracać wartość logiczną TRUE albo FALSE. Chcąc uwzględnić więcej niż jeden warunek należy wykorzystać odpowiedni operator łączenia:\n\ni : &&\nlub : ||\n\nPrzykład funkcji sprawdzającej wartość:\nsprawdz_wartosc &lt;- function(wartosc) {\n  # Sprawdzanie poprawności danych\n  if (is.na(wartosc)) {\n    stop(\"Podana wartość to NA\")\n  }\n  if (is.character(wartosc)) {\n    stop(\"Podana wartość to tekst\")\n  }\n  \n  # Sprawdzanie wartości\n  if (wartosc &gt; 0) {\n    print(\"Wartość &gt; 0\")\n  } else if (wartosc &lt; 0) {\n    print(\"Wartość &lt; 0\")\n  } else {\n    print(\"Wartość = 0\")\n  }\n}\nW tym przypadku użyliśmy warunków wewnątrz funkcji dodatkowo używając ich do weryfikacji poprawności argumentów wejściowych.\nTak zdefiniowane warunki pozwalają na warunkowe wykonywanie całych bloków kodu np. jeśli w zbiorze danych znajduje się kolumna wiek to stwórz i zapis wykres, a w przeciwnym wypadku połącz się z zewnętrznym źródłem danych w celu uzupełnienia brakujących informacji.\nW tym miejscu zapoznamy się także z warunkowym przetwarzaniem wartości obiektu z wykorzystaniem funkcji ifelse oraz jej ulepszonym wariantem z pakietu dplyr. Funkcja ifelse() jest wektorową wersją instrukcji warunkowej, działającą element po elemencie:\nifelse(test, yes, no)\ngdzie: - test to wektor wartości logicznych (TRUE/FALSE) - yes to wartości zwracane dla elementów, które spełniają warunek - no to wartości zwracane dla elementów, które nie spełniają warunku\nPrzykład:\n\nwartosc &lt;- 10\nifelse(test = wartosc &gt; 0, yes = \"Wartość &gt; 0\", no = \"Wartość &lt; 0\")\n\n[1] \"Wartość &gt; 0\"\n\n# Zastosowanie dla każdego wiersza w ramce danych\ndane$x1_zero &lt;- ifelse(dane$x1 &gt; 0, \"wartość &gt; 0\", \"wartość &lt; 0\")\n\nMożna zagnieżdżać wywołania ifelse() dla bardziej złożonych warunków:\ndane$z1_zero &lt;- ifelse(dane$z1 &gt; 0, \"wartość &gt; 0\", \n                       ifelse(dane$z1 &lt; 0, \"wartość &lt; 0\", \"wartość = 0\"))\nFunkcja case_when() z pakietu dplyr (część tidyverse) oferuje bardziej czytelną alternatywę dla zagnieżdżonych if-else:\nlibrary(tidyverse)\n\ndane &lt;- dane %&gt;% \n  mutate(z1_zero = case_when(\n    z1 &gt; 0 ~ \"wartość &gt; 0\",\n    z1 &lt; 0 ~ \"wartość &lt; 0\",\n    z1 == 0 ~ \"wartość = 0\"\n  ))\nW funkcji case_when możliwe jest podanie wartości .default w celu określenia co ma się stać z wartościami niepasującymi do żadnego warunku.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Programowanie w R</span>"
    ]
  },
  {
    "objectID": "06-programowanie.html#pętle",
    "href": "06-programowanie.html#pętle",
    "title": "5  Programowanie w R",
    "section": "5.4 Pętle",
    "text": "5.4 Pętle\nPętle pozwalają na wielokrotne wykonanie tego samego kodu dla różnych wartości. W R często można uniknąć używania pętli poprzez operacje wektorowe, ale ich znajomość jest kluczowa.\nPodstawowa składnia pętli for:\nfor (zmienna in sekwencja) {\n  # instrukcje wykonywane dla każdej wartości zmiennej\n}\nIteracja po indeksach - musimy wskazać ile razy pętla ma się wykonać\nfor (month in 1:12) {\n  print(month.name[month])\n}\nZamiast korzystać z ‘magicznych liczb’ można użyć funkcji seq_along(), która generuje sekwencję indeksów o długości danego wektora:\nfor (month in seq_along(month.name)) {\n  print(month.name[month])\n}\nW zależności od potrzeb możemy też przeprowadzić iterację po wektorze wartości\nfor (month in month.name) {\n  print(month)\n}\nPrzykład tworzenia nowego wektora na podstawie istniejącego:\nmonth_upper &lt;- character(length = length(month.name))  # inicjalizacja pustego wektora\n\nfor (month in seq_along(month.name)) {\n  month_upper[month] &lt;- toupper(month.name[month])\n}\n\nmonth_upper  # wektor z nazwami miesięcy dużymi literami\nWarto zauważyć, że w R często można uniknąć pętli, stosując operacje wektorowe:\nmonth_upper &lt;- toupper(month.name)  # to samo co powyższa pętla, ale szybsze i bardziej eleganckie\nPętle są szczególnie przydatne w przypadku symulacji różnych zdarzeń np. rzutów kostką:\n# Podejście z pętlą\nrzut_kostka &lt;- numeric(10000)\n\nfor (rzut in seq_along(rzut_kostka)) {\n  rzut_kostka[rzut] &lt;- sample(1:6, 1)\n}\n\n# Statystyki\nmean(rzut_kostka)\ntable(rzut_kostka)\nChociaż często tutaj także można zastosować podejście wektorowe:\n# Podejście wektorowe - bardziej wydajne\nrzut_kostka_vec &lt;- sample(1:6, 10000, replace = TRUE)\n\nmean(rzut_kostka_vec)\ntable(rzut_kostka_vec)\nChoć R jest zoptymalizowany pod kątem operacji wektorowych, pętle są przydatne gdy:\n\nAlgorytm wymaga dostępu do poprzednich wyników (np. symulacje szeregów czasowych)\nOperacje są zbyt złożone, aby wyrazić je w formie wektorowej\nIterujemy po strukturach danych, które nie są wektorami (np. listy elementów o różnej strukturze)\nPrzeprowadzamy operacje sekwencyjne (np. import wielu plików)\n\nWarto jednak zawsze rozważyć, czy operacja nie może być wykonana bardziej efektywnie za pomocą podejścia wektorowego lub funkcji takich jak apply, lapply, sapply, vapply, czy funkcji z pakietu purrr.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Programowanie w R</span>"
    ]
  },
  {
    "objectID": "06-programowanie.html#zadania",
    "href": "06-programowanie.html#zadania",
    "title": "5  Programowanie w R",
    "section": "5.5 Zadania",
    "text": "5.5 Zadania\n\n5.5.1 Paradoks dnia urodzin\nArtykuł na wikipedii\nIle minimalnie osób należy wybrać, żeby prawdopodobieństwo znalezienia wśród nich co najmniej dwóch osób obchodzących urodziny tego samego dnia było większe od 0,5.\nRozwiązaniem problemu jest liczba 23. Ta zaskakująco mała liczba osób jest przyczyną określenia „Paradoks dnia urodzin”.\nNapisz funkcję, która jako argument będzie przyjmowała liczbę osób (max. 100), dla których ma wylosować datę urodzenia (bez roku). Następnie sprawdź czy któraś data powtarza się w ramach wylosowanych wartości i zapisz wynik (prawda lub fałsz). Powtórz losowanie 100000 razy. Wynikiem jest prawdopodobieństwo wyznaczone poprzez podzielenie liczby przypadków, gdzie data się powtórzyła przez liczbę wszystkich losowań.\n\nparadoks_urodzin(23)\n\nW grupie 23 osób prawdopodobieństwo, że dwie osoby będą miały urodziny tego samego dnia wynosi 50.95%.\n\n\n5.5.2 Poszukiwacz dzielników\nTermin dzielnik liczby oznacza liczbę, która dzieli ją bez reszty.\nNapisz funkcję, która dla podanej liczby będzie zwracała jej dzielniki. Użyj pętli do sprawdzenia czy potencjalny dzielnik faktycznie dzieli się bez reszty.\n\ndzielnik_liczby(26)\n\nDzielniki liczby 26 to: 1, 2, 13, 26.\n\n\n5.5.3 Papier, kamień, nożyce,\nArtykuł na wikipedii\nNapisz funkcję, która jako argument przyjmuje jeden z trzech symboli (kamień/nożyce/papier). Komputer może objąć trzy strategię: losowo wybierać symbol, zawsze wygrywać lub zawsze przegrywać. Możesz użyć funkcji opóźniającej podanie wyniki, aby zwiększyć emocje.\n\npkn(symbol=\"kamień\", tryb=\"losowy\")\n\nkamień vs. nożyce - wygrałeś!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Programowanie w R</span>"
    ]
  },
  {
    "objectID": "04-statystyka.html",
    "href": "04-statystyka.html",
    "title": "6  Statystyka opisowa",
    "section": "",
    "text": "6.1 Analiza struktury\nPrezentacja\nQuarto\nDo charakterystyk najczęściej wykorzystywanych przy opisie danych należą:\nAnaliza struktury bazuje na dwóch typach miar:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statystyka opisowa</span>"
    ]
  },
  {
    "objectID": "04-statystyka.html#analiza-struktury",
    "href": "04-statystyka.html#analiza-struktury",
    "title": "6  Statystyka opisowa",
    "section": "",
    "text": "miary przeciętne - służące do określania tej wartości zmiennej opisanej przez rozkład, wokół której skupiają się pozostałe wartości zmiennej,\nmiary rozproszenia (dyspersji) - służące do badania stopnia zróżnicowania wartości zmiennej,\nmiary asymetrii - służące do badania asymetrii rozkładu,\nmiary koncentracji - służące do analizy stopnia skupienia poszczególnych jednostek wokół średniej.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statystyka opisowa</span>"
    ]
  },
  {
    "objectID": "04-statystyka.html#miary-klasyczne---obliczane-na-podstawie-wszystkich-obserwacji",
    "href": "04-statystyka.html#miary-klasyczne---obliczane-na-podstawie-wszystkich-obserwacji",
    "title": "6  Statystyka opisowa",
    "section": "6.2 Miary klasyczne - obliczane na podstawie wszystkich obserwacji",
    "text": "6.2 Miary klasyczne - obliczane na podstawie wszystkich obserwacji\n\n\n\n\n\n\n\n\n\nMiara\nSymbol\nWzór\nInterpretacja\n\n\n\n\nŚrednia arytmetyczna\n\\(\\bar{x}\\)\n\\(\\frac{\\sum_{i=1}^N x_i}{N}\\)\nWartość przeciętna\n\n\nOdchylenie kwadratowe\n\\(d^2\\)\n\\(\\sum_{i=1}^N (x_i - \\bar{x})^2\\)\nKwadrat odchylenia przeciętnego\n\n\nOdchylenie standardowe (dla populacji)\n\\(s\\)\n\\(\\sqrt{\\frac{\\sum_{i=1}^N (x_i - \\bar{x})^2}{N}}\\)\nO ile przeciętnie odchylają się wartości od średniej\n\n\nWariancja (dla próby)\n\\(s^2\\)\n\\(\\frac{\\sum_{i=1}^N (x_i - \\bar{x})^2}{N-1}\\)\nInformuje o zróżnicowaniu próby\n\n\nRozstęp\n\\(R\\)\n\\(max(x) - min(x)\\)\nEmpiryczny obszar zmienności, wartość maksymalna cechy x minus wartość minimalna tej cechy\n\n\nWspółczynnik zmienności\n\\(V_x\\)\n\\(\\frac{s}{\\bar{x}}\\)\nInformuje o relatywnym zróżnicowaniu populacji (próby). Zwykle wykorzystujemy do porównań dwóch lub więcej grup. Wyrażamy w procentach.\n\n\nWspółczynnik asymetrii\n\\(\\alpha_3\\)\n\\(\\frac{\\frac{1}{N}\\sum_{i=1}^{N}{(x_{i}-\\bar{x})^3}}{s^3}\\)\nPozwala zidentyfikować czy rozkład jest symetryczny lub asymetryczny\n\n\nWspółczynnik koncentracji\n\\(\\alpha_4\\)\n\\(\\frac{\\frac{1}{N}\\sum_{i=1}^{N}{(x_{i}-\\bar{x})^4}}{s^4}\\)\nPozwala zidentyfikować czy rozkład jest wysmukły czy spłaszczony",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statystyka opisowa</span>"
    ]
  },
  {
    "objectID": "04-statystyka.html#miary-pozycyjne---wartość-miary-wskazuje-dana-jednostka.",
    "href": "04-statystyka.html#miary-pozycyjne---wartość-miary-wskazuje-dana-jednostka.",
    "title": "6  Statystyka opisowa",
    "section": "6.3 Miary pozycyjne - wartość miary wskazuje dana jednostka.",
    "text": "6.3 Miary pozycyjne - wartość miary wskazuje dana jednostka.\n\n\n\n\n\n\n\n\n\nMiara\nSymbol\nWzór\nInterpretacja\n\n\n\n\nKwartyl 1\n\\(Q_1\\)\n\nDzieli populację na dwie części w stosunku 25 / 75\n\n\nKwartyl 2, Mediana\n\\(Q_2, Me\\)\n\nDzieli populację na dwie części w stosunku 50 / 50\n\n\nKwartyl 3\n\\(Q_3\\)\n\nDzieli populację na dwie części w stosunku 75 / 25\n\n\nOdchylenie ćwiartkowe\n\\(Q\\)\n\\(Q=\\frac{Q3-Q1}{2}\\)\nMierzy ono przeciętne odchylenie wartości cechy zbiorowości od mediany\n\n\nPozycyjny współczynnik zmienności\n\\(V_Q\\)\n\\(\\frac{Q}{Me}\\)\nMierzy przeciętne zróżnicowanie cechy\n\n\nPozycyjny współczynnik asymetrii\n\\(A_Q\\)\n\\(\\frac{Q_1+Q3-2Me}{2Q}\\)\nMierzy (a)symetrię rozkładu\n\n\n\nCelem analizy struktury jest dostarczenie kilku liczb, które w łatwy sposób pozwolą na opis i porównania badanych cech.\nDominanta (inaczej moda, modalna) czyli najczęściej występująca wartość i jest wyznaczana dla zmiennych jakościowych.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statystyka opisowa</span>"
    ]
  },
  {
    "objectID": "04-statystyka.html#wyznaczanie-przedziału-ufności-dla-średniej-i-odsetka.",
    "href": "04-statystyka.html#wyznaczanie-przedziału-ufności-dla-średniej-i-odsetka.",
    "title": "6  Statystyka opisowa",
    "section": "6.4 Wyznaczanie przedziału ufności dla średniej i odsetka.",
    "text": "6.4 Wyznaczanie przedziału ufności dla średniej i odsetka.\nwiększość prowadzonych badań ogranicza się do analizy jedynie fragmentu populacji. Wówczas, oprócz obliczenia interesującej nas miary ważne jest także podanie możliwego błędu. Popularną praktyką jest obliczanie przedziałów ufności, które prezentują zakres, w którym z określonym prawdopodobieństwem znajduje się prawdziwa wartość parametru. Zwykle bierze się pod uwagę następujące prawdopodobieństwa: 90%, 95% i 99%, niemniej można wybrać dowolną wartość z przedziału 0-100%. We wzorach operuje się pojęciem poziomu istotności oznaczanym przez \\(\\alpha\\).\nBędziemy musieli wyznaczyć kwantyl rozkładu, który odpowiada przyjętemu poziomowi prawdopodobieństwa i tym samym obszar, który pokryje wyznaczony przedział ufności. Dla rozkładu normalnego ta sytuacja jest przedstawiona na wykresie:\n\n\n\n\n\n\n\n\n\nW tabeli przedstawiono relację przyjętego prawdopodobieństwa, poziomu istotności oraz wartości kwantyli rozkładu normalnego.\n\n\n\nPrawdopodobieństwo\nPoziom istotności\nKwantyl rozkł. norm.\n\n\n\n\n99% (0,99)\n0,01\n2,58\n\n\n95% (0,95)\n0,05\n1,96\n\n\n90% (0,90)\n0,10\n1,64\n\n\n\nTe wartości dla najpopularniejszych poziomów prawdopodobieństwa zawsze będą takie same. Natomiast w przypadku małych prób (\\(n &lt; 30\\)) należy skorzystać z rozkładu t-Studenta. Kształt tego rozkładu jest zbliżony do normalnego, natomiast wartości kwantyli zależą od dwóch parametrów - przyjętego poziomu istotności oraz liczebności próby pomniejszonej o 1 (liczba stopni swobody).\n\n\n\n\n\n\n\n\n\n\n6.4.1 Średnia\nJeśli odchylenie standardowe w populacji nie jest znane to można wykorzystać wzór, w którym używa się wartości odchylenia standardowego obliczonego na podstawie próbie. Trzeba jednak rozróżnić małą oraz dużą próbę. Przyjętym w statystyce progiem jest \\(n &gt; 30\\), kiedy uznaje się próbę za dużą. Podstawową różnicą jest wykorzystanie we wzorze przedziału ufności dla małej próby kwantyla rozkładu t-Studenta, a dla dużej kwantyla rozkładu normalnego.\n\\[P\\left\\{\\bar{X}-t_{(1-\\alpha/2,n-1)}\\frac{s}{\\sqrt{n-1}}&lt;m&lt;\\bar{X}+t_{(1-\\alpha/2,n-1)}\\frac{s}{\\sqrt{n-1}}\\right\\}=1-\\alpha\\]\ngdzie:\n\n\\(m\\) - prawdziwa wartość średniej w populacji,\n\\(\\bar{X}\\) - estymator średniej,\n\\(t_{(1-\\alpha/2,n-1)}\\) - kwantyl rozkładu t-Studenta dla poziomu istotności \\(\\alpha\\) z \\(n-1\\) stopniami swobody,\n\\(s\\) - odchylenie standardowe z próby,\n\\(n\\) - liczebność próby.\n\nPrzykład\nPostanowiono oszacować średni czas potrzebny do wykonania detalu. Z populacji robotników wylosowano próbę 17 osób i dokonano pomiaru czasu wykonywania detalu. Okazało się, że średni czas wykonania detalu wynosił 15 minut, a odchylenie standardowe 2 minuty. Rozkład czasu wykonania tego detalu ma rozkład normalny i przyjęto poziom istotności \\(\\alpha=0,05\\).\nWartość kwantyla rozkładu t-Studenta wynosi 2,12.\n\\[15-2,12\\frac{2}{\\sqrt{16}}&lt;m&lt;15+2,12\\frac{2}{\\sqrt{16}}\\]\n\\[13,94 &lt; m &lt; 16,06\\]\nŚredni czas wykonania detalu z 95% prawdopodobieństwem jest nie mniejszy niż 13,94 i nie większy niż 16,06 minuty.\n\n# Dane wejściowe\nx_bar &lt;- 15        # średnia próby\ns &lt;- 2             # odchylenie standardowe próby\nn &lt;- 17            # liczność próby\nalpha &lt;- 0.05      # poziom istotności\n\n# Wartość t dla 16 stopni swobody (n - 1)\nt_crit &lt;- qt(1 - alpha/2, df = n - 1)\n\n# Obliczenie błędu standardowego\nSE &lt;- s / sqrt(n-1)\n\n# Obliczenie przedziału ufności\nCI_lower &lt;- x_bar - t_crit * SE\nCI_upper &lt;- x_bar + t_crit * SE\n\n# Wynik\ncat(\"95% przedział ufności dla średniego czasu wykonania detalu: [\", \n    round(CI_lower, 2), \",\", round(CI_upper, 2), \"]\\n\")\n\n95% przedział ufności dla średniego czasu wykonania detalu: [ 13.94 , 16.06 ]\n\n\n\n\n6.4.2 Proporcja\nNa podobnej zasadzie można także wyznaczyć przdział ufności dla odsetka.\n\\[  P\\left\\{\\frac{m}{n}-z_{(1-\\alpha/2)}\\sqrt{\\frac{\\frac{m}{n}\\left(1-\\frac{m}{n}\\right)}{n}}&lt;p&lt;\\frac{m}{n}+z_{(1-\\alpha/2)}\\sqrt{\\frac{\\frac{m}{n}\\left(1-\\frac{m}{n}\\right)}{n}}\\right\\} \\approx 1-\\alpha\\]\ngdzie:\n\n\\(p\\) - wartość proporcji w populacji,\n\\(z_{(1-\\alpha/2)}\\) - kwantyl rozkładu normalnego obliczony dla poziomu istotności \\(\\alpha\\),\n\\(m\\) - liczba jednostek posiadających daną cechę,\n\\(n\\) - liczebność\n\nPrzykład\nSpośród 10 tysięcy pracowników wylosowano próbę liczącą 200 osób i przeprowadzono badanie dotyczące opuszczenia zakładu pracy. Okazało się, że 20 z 200 respondentów zamierza, z różnych względów, opuścić zakład pracy. Dla poziomu ufności 90% wyznaczyć przedział ufności dla wskaźnika pracowników planujących opuścić bieżące miejsce pracy.\n\\[\\frac{20}{200}-1,64\\sqrt{\\frac{\\frac{20}{200}\\left(1-\\frac{20}{200}\\right)}{200}} &lt; p &lt; \\frac{20}{200}+1,64\\sqrt{\\frac{\\frac{20}{200}\\left(1-\\frac{20}{200}\\right)}{200}}\\]\n\\[0,065 &lt; p &lt; 0,135\\]\n\\[6,5\\% &lt; p &lt; 13,5\\%\\]\nZ prawdopodobieństwem 90% możemy stwierdzić, że pracowników planujących opuścić zakład pracy jest nie mniej niż 6,5% i nie więcej niż 13,5%.\n\n# Dane wejściowe\nn &lt;- 200\nm &lt;- 20\nm_n &lt;- m / n\nalpha &lt;- 0.10\nz_crit &lt;- qnorm(1 - alpha/2)  # z dla 90% CI\n\n# Błąd standardowy\nSE &lt;- sqrt(m_n * (1 - m_n) / n)\n\n# Przedział ufności\nCI_lower &lt;- m_n - z_crit * SE \nCI_upper &lt;- m_n + z_crit * SE\n\n# Wynik\ncat(\"90% przedział ufności dla odsetka pracowników planujących odejście: [\",\n    round(CI_lower, 4), \",\", round(CI_upper, 4), \"]\\n\")\n\n90% przedział ufności dla odsetka pracowników planujących odejście: [ 0.0651 , 0.1349 ]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statystyka opisowa</span>"
    ]
  },
  {
    "objectID": "04-statystyka.html#analiza-zależności-pomiędzy-zmiennymi-ilościowymi",
    "href": "04-statystyka.html#analiza-zależności-pomiędzy-zmiennymi-ilościowymi",
    "title": "6  Statystyka opisowa",
    "section": "6.5 Analiza zależności pomiędzy zmiennymi ilościowymi",
    "text": "6.5 Analiza zależności pomiędzy zmiennymi ilościowymi\nKorelacja [łac.], mat. wzajemne powiązanie, współzależność zjawisk lub obiektów; w teorii prawdopodobieństwa i statystyce — współzależność liniowa zmiennych losowych (jej liczbową miara jest współczynnik korelacji) [źródło: słownik PWN].\nSprawdźmy czy liczba klientów jest skorelowana ze sprzedażą w sklepie nr 1. Pierwszym krokiem w analizie korelacji jest stworzenie wykresu rozrzutu:\n\n\n\n\n\n\n\n\n\nNa tej podstawie możemy już stwierdzić, że zależność jest dodatnia - wzrost wartości jednej cechy pociąga za sobą wzrost wartości drugiej cechy:\n\nwzrost temperatury, większa sprzedaż lodów;\nwzrost wynagrodzenia, zwiększenie wydatków;\nmniej czasu spędzonego na działaniach marketingowych, mniej klientów.\n\nWięcej przykładów\nZ korelacją ujemną mielibyśmy do czynienia, gdy wartości jednej cechy by rosły, a drugiej malały. Przykłady ujemnej korelacji:\n\nliczba nieobecności na zajęciach jest zwykle związana z niższymi ocenami;\nwiększa prędkość pociągu, krótszy czas dotarcia do stacji końcowej;\nspadek temperatury, wzrost sprzedaży grzejników.\n\nWięcej przykładów\nWartością liczbową, która określa kierunek korelacji jest kowariancja. Wyznaczenie kowariancji polega na policzeniu różnic wartości obu cech od średniej, a następnie ich przemnożeniu i uśrednieniu, zgodnie ze wzorem:\n\\[cov(x,y)=cov(y,x)=\\frac{1}{n}\\sum\\limits_{i=1}^{n}{(x_{i}-\\bar{x})\\cdot(y_{i}-\\bar{y})}\\]\nZnak kowariancji determinuje kierunek zależności, który jest ustalany na podstawie iloczynu różnic pomiędzy wartościami średnich a analizowanymi cechami.\nJeśli kowariancja będzie:\n\n\\(cov(x,y)=0\\) — brak zależności,\n\\(cov(x,y)&lt;0\\) — ujemna zależność,\n\\(cov(x,y)&gt;0\\) — dodatnia zależność.\n\nW przypadku sklepu nr 1 kowariancja wynosi 9.4843^{4}, co oczywiście pociąga za sobą dodatnią zależność. Na podstawie kowariancji nie możemy natomiast wyznaczyć siły zależności ponieważ jest wyznaczona w dziwnych jednostkach - osobo-euro. Poza tym może przyjąć wartości z całego zakresu liczb rzeczywistych: \\((-\\infty;+\\infty)\\).\nStandaryzując kowariancję z wykorzystaniem odchylenia standardowego każdej cechy otrzymamy współczynnik korelacji liniowej Pearsona:\n\\[r_{xy}=r_{yx}=\\frac{cov(X,Y)}{S_{x}\\cdot S_{y}}\\]\nlub\n\\[r_{xy}=\\frac{\\sum\\limits_{i=1}^{n}{(x_{i}-\\bar{x})\\cdot(y_{i}-\\bar{y})}}{\\sqrt{\\sum\\limits_{i=1}^{n}{(x_{i}-\\bar{x})^2\\cdot(y_{i}-\\bar{y})^2}}}\\]\nWspółczynnik ten jest wielkością unormowaną, przyjmuje wartości z przedziału \\(r\\in&lt;-1;1&gt;\\).\nJeśli:\n\n\\(r_{xy}=1\\) — korelacja dodatnia doskonała,\n\\(0&lt;r_{xy}&lt;1\\) — korelacja dodatnia niedoskonała (słaba/umiarkowana/silna)\n\\(r_{xy}=0\\) — brak zależności,\n\\(-1&lt;r_{xy}&lt;0\\) — korelacja ujemna niedoskonała (słaba/umiarkowana/silna)\n\\(r_{xy}=-1\\) — korelacja ujemna doskonała.\n\nW sklepie nr 1 współczynnik korelacji liniowej Pearona wynosi 0.94, co oznacza, że pomiędzy wartością sprzedaży a liczbą klientów występuje silna dodatnia korelacja liniowa.\nW przypadku, gdy w zbiorze analizowanych cech znajdą się wartości odstające, które zaburzają liniowość relacji, współczynnik korelacji liniowej może nie spełniać swojej funkcji. Wówczas należy skorzystać ze współczynnika korelacji rang Spearmana, który jest współczynnikiem korelacji liniowej Pearsona, ale obliczanym na rangach.\nRangowanie polega na posortowaniu wartości jednej cechy rosnąco - przypisanie kolejnych wartości od \\(1\\) do \\(n\\) (jak w sporcie), na następnie powtórzenie operacji dla drugiej cechy. Jeśli jakaś wartość będzie się powtarzać (ex aequo), wówczas wyznaczamy wartość tzn. rangi wiązanej - średniej arytmetycznej z rang tej wartości.\nW programie R do obliczenia korelacji dla cech ciągłych wykorzystuje się funkcję cor(). Domyślna metoda zwraca współczynnik korelacji liniowej Pearsona.\n\ncor(rossmann_1$sprzedaz, rossmann_1$liczba_klientow)\n\n[1] 0.9432882\n\ncor(rossmann_1$sprzedaz, rossmann_1$liczba_klientow, method = \"pearson\")\n\n[1] 0.9432882\n\n\nZ kolei do obliczenia korelacji rang Spearmana należy zmodyfikować argument method.\n\ncor(rossmann_1$sprzedaz, rossmann_1$liczba_klientow, method = \"spearman\")\n\n[1] 0.9240377\n\n\nDo testowania istotności statystycznej wykorzystywana jest funkcja cor.test.\n\ncor.test(rossmann_1$sprzedaz, rossmann_1$liczba_klientow, method = \"pearson\")\n\n\n    Pearson's product-moment correlation\n\ndata:  rossmann_1$sprzedaz and rossmann_1$liczba_klientow\nt = 49.297, df = 301, p-value &lt; 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.9293934 0.9545131\nsample estimates:\n      cor \n0.9432882 \n\n\nNa tej podstawie stwierdzamy, że współczynnik korelacji pomiędzy cechami sprzedaż i liczba klientów wynosi 0,94 i jest istotny statystycznie.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statystyka opisowa</span>"
    ]
  },
  {
    "objectID": "04-statystyka.html#analiza-zależności-pomiędzy-zmiennymi-jakościowymi",
    "href": "04-statystyka.html#analiza-zależności-pomiędzy-zmiennymi-jakościowymi",
    "title": "6  Statystyka opisowa",
    "section": "6.6 Analiza zależności pomiędzy zmiennymi jakościowymi",
    "text": "6.6 Analiza zależności pomiędzy zmiennymi jakościowymi\nCelem analizy współzależności jest określenie siły związku pomiędzy dwiema cechami jakościowymi. Sprawdźmy czy istnieje zależność pomiędzy wynikiem z egzaminu a płcią?\nPodstawą takiej analizy jest tablica kontyngencji albo tablica krzyżowa. W przypadku obserwacji statystycznej dotyczącej dużej ilości zmiennych, operowanie wartościami szczegółowymi jest uciążliwe. W celu stwierdzenia istnienia lub braku związku korelacyjnego konstruuje się tablicę korelacyjną. Na skrzyżowaniu kolumn z wierszami wpisuje się liczebności jednostek zbiorowości statystycznej, u których zaobserwowano jednoczesne występowanie określonej wartości \\(x_{i}\\) i \\(y_{i}\\). Ogólna postać tablicy krzyżowej jest następująca:\n\n\n\n\n\n\n\n\n\n\n\n\n\ncecha X / cecha Y\n\\(y_{1}\\)\n\\(y_{2}\\)\n\\(\\cdots\\)\n\\(y_{j}\\)\n\\(\\cdots\\)\n\\(y_{r}\\)\n\\(\\sum\\limits_{j}\\)\n\n\n\n\n\\(x_{1}\\)\n\\(n_{11}\\)\n\\(n_{12}\\)\n\\(\\cdots\\)\n\\(n_{1j}\\)\n\\(\\cdots\\)\n\\(n_{1r}\\)\n\\(n_{1.}\\)\n\n\n\\(x_{2}\\)\n\\(n_{21}\\)\n\\(n_{22}\\)\n\\(\\cdots\\)\n\\(n_{2j}\\)\n\\(\\cdots\\)\n\\(n_{2r}\\)\n\\(n_{2.}\\)\n\n\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\n\n\\(x_{i}\\)\n\\(n_{i1}\\)\n\\(n_{i2}\\)\n\\(\\cdots\\)\n\\(n_{ij}\\)\n\\(\\cdots\\)\n\\(n_{ir}\\)\n\\(n_{i.}\\)\n\n\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\n\n\\(x_{k}\\)\n\\(n_{k1}\\)\n\\(n_{k2}\\)\n\\(\\cdots\\)\n\\(n_{kj}\\)\n\\(\\cdots\\)\n\\(n_{kr}\\)\n\\(n_{k.}\\)\n\n\n\\(\\sum\\limits_{i}\\)\n\\(n_{.1}\\)\n\\(n_{.2}\\)\n\\(\\cdots\\)\n\\(n_{.j}\\)\n\\(\\cdots\\)\n\\(n_{.r}\\)\n\\(n\\)\n\n\n\nJak wynika z tablicy zmienna losowa \\(X\\) przyjmuje \\(k\\) wariantów (i=1,2,…,k), zaś zmienna losowa \\(Y\\) przyjmuje \\(r\\) wariantów (j=1,2,…,r).\nSymbol \\(n_{.j}\\) oznacza liczbę jednostek, które mają wariant \\(y_{j}\\) zmiennej Y, natomiast symbol \\(n_{i.}\\) - liczbę jednostek, które mają wariant \\(x_{i}\\) zmiennej X. Symbole \\(n_{ij}\\) oznaczają liczbę jednostek, które posiadają jednocześnie wariant \\(x_{i}\\) cechy X i warianty \\(y_{j}\\) cechy Y. Symbol \\(n\\) oznacza liczebność próby, przy czym:\n\\[n=\\sum\\limits_{i=1}^{k}{n_{i.}}=\\sum\\limits_{j=1}^{r}{n_{.j}}=\\sum\\limits_{i=1}^{k}\\sum\\limits_{j=1}^{r}{n_{ij}}\\]\nW analizowanym przykładzie pozyskaliśmy informację od 500 osób na temat wyniku egzaminu oraz płci. Tablica krzyżowa tych danych wygląda następująco:\n\n\n\nPłeć / Wynik\nNie zdany\nZdany\nSuma\n\n\n\n\nMężczyzna\n100\n70\n170\n\n\nKobieta\n130\n200\n330\n\n\nSuma\n230\n270\n500\n\n\n\nDo odpowiedzi na pytanie czy istnieje zależność pomiędzy tymi cechami wykorzystamy statystykę chi-kwadrat (\\(\\chi^2\\)). W pierwszym kroku musimy obliczyć oczekiwane (teoretyczne) częstości dla każdej komórki czyli wartości jakie musiałyby występować, żeby zależności nie było. Wzór na liczebności teoretyczne jest następujący \\(\\hat{n}_{ij}=\\frac{n_{i.} \\cdot n_{.j}}{n}\\). Na tej postawie wyznacza się wartość statystyki:\n\\[\\chi^{2}=\\sum\\limits_{i=1}^{k}\\sum\\limits_{j=1}^{r}{\\frac{(n_{ij}-\\hat{n}_{ij})^2}{\\hat{n}_{ij}}}\\]\ngdzie:\n\n\\(r\\) - liczba wariantów cechy Y,\n\\(k\\) - liczba wariantów cechy X,\n\\(n_{ij}\\) - liczebności empiryczne dla i-tego wariantu cechy X i j-tego wariantu cechy Y,\n\\(\\hat{n}_{ij}\\) - liczebności teoretyczne dla i-tego wariantu cechy X i j-tego wariantu cechy Y.\n\nSama wartość statystyki chi-kwadrat nie informuje sile zależności pomiędzy analizowanymi zmiennymi. W celu określenia siły zależności musimy wyznaczyć jedną z dostępnych miar korelacji: współczynnik V-Cramera lub współczynnik zbieżności T-Czuprowa:\n\\[V=\\sqrt{\\frac{\\chi^2}{n \\cdot min(k-1,r-1)}}\\]\n\\[T=\\sqrt{\\frac{\\chi^2}{n \\cdot \\sqrt{(k-1)(r-1)}}}\\]\ngdzie:\n\n\\(\\chi^2\\) - wyznaczona wartość statystyki \\(\\chi^2\\),\n\\(n\\) - liczba wszystkich obserwacji,\n\\(k\\) - liczba kolumn tabeli kontyngencji bez sumy (liczba wariantów pierwszej cechy),\n\\(r\\) - liczba wierszy tabeli kontyngencji bez sumy (liczba wariantów drugiej cechy).\n\nMożemy przyjąć pewne umowne progi dotyczące interpretacji tych miar:\n\nod 0,00 do 0,29 - słaby związek pomiędzy zmiennymi,\nod 0,30 do 0,49 - umiarkowany związek pomiędzy zmiennymi,\nod 0,50 do 1,00 - silny związek pomiędzy zmiennymi.\n\nW celu sprawdzenia istotności statystycznej pomiędzy cechami wykorzystuje się funkcję chisq.test().\nUkład hipotez jest następujący:\n\n\\(H_0:\\) zmienne są niezależne,\n\\(H_1:\\) zmienne nie są niezależne.\n\n\ndane &lt;- matrix(c(100, 70, 130, 200), ncol=2, byrow = T)\ndane\n\n     [,1] [,2]\n[1,]  100   70\n[2,]  130  200\n\nchisq.test(dane)\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  dane\nX-squared = 16.279, df = 1, p-value = 5.468e-05\n\n\nNa tej podstawie stwierdzamy, że zmienne są niezależne.\n\nlibrary(confintr)\n\ncramersv(chisq.test(dane))\n\n[1] 0.1804357\n\n\nWartość współczynnika V-Cramera wskazuje na bardzo słabe powiązanie pomiędzy cechami.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statystyka opisowa</span>"
    ]
  },
  {
    "objectID": "04-statystyka.html#analiza-zależności-pomiędzy-zmiennymi---zmienna-jakościowa-i-ilościowa",
    "href": "04-statystyka.html#analiza-zależności-pomiędzy-zmiennymi---zmienna-jakościowa-i-ilościowa",
    "title": "6  Statystyka opisowa",
    "section": "6.7 Analiza zależności pomiędzy zmiennymi - zmienna jakościowa i ilościowa",
    "text": "6.7 Analiza zależności pomiędzy zmiennymi - zmienna jakościowa i ilościowa\nW przypadku testowania wartości przeciętnych należy wprowadzić pojęcie prób zależnych i niezależnych:\n\npróby zależne (paired) - analizowane są te same jednostki, ale różne cechy.\npróby niezależne (unpaired) - analizowane są różne jednostki, ale ta sama cecha.\n\nW zależności od tego czy spełnione są odpowiednie założenia dotyczące normalności cechy oraz równości wariancji należy wybrać odpowiedni test.\n\n6.7.1 Test t-średnich\nWeryfikacja równości średnich może odbywać się na zasadzie porównania wartości średniej w jednej grupie z arbitralnie przyjętym poziomem lub w dwóch różnych grupach. W pierwszym przypadku rozważamy układ hipotez:\n\n\\(H_0: m = m_0\\)\n\\(H_1: m \\neq m_0\\) lub \\(H_1: m &lt; m_0\\) lub \\(H_1: m &gt; m_0\\)\n\nnatomiast w drugim przypadku hipotezy będą wyglądać następująco:\n\n\\(H_0: m_1 = m_2\\)\n\\(H_1: m_1 \\neq m_2\\) lub \\(H_1: m_1 &lt; m_2\\) lub \\(H_1: m_1 &gt; m_2\\)\n\nAlternatywnie hipotezę zerową można zapisać jako \\(m_1 - m_2 = 0\\) czyli sprawdzamy czy różnica pomiędzy grupami istotnie różni się od zera.\nW funkcji t.test() z pakietu stats w przypadku jednej próby należy podać argument x czyli wektor z wartościami, które są analizowane oraz wartość, z którą tą średnią porównujemy (argument mu, który domyślnie jest równy 0). Dodatkowo w argumencie alternative wskazujemy jaką hipotezę alternatywną bierzemy pod uwagę.\nDla weryfikacji równości średniej w dwóch próbach należy dodać argument y z wartościami w drugiej próbie. W tym przypadku mamy także możliwość określenia czy próby są zależne (argument paired) lub czy wariancja w obu próbach jest taka sama (var.equal). Jeżeli wariancje są różne to program R przeprowadzi test t Welcha i liczba stopni swobody nie będzie liczbą całkowitą.\n\n\n6.7.2 ANOVA\nW przypadku większej liczby grup stosuje się jednoczynnikową analizę wariancji (ANOVA). Ta analiza wymaga spełnienia założenia o normalności rozkładu i równości wariancji w badanych grupach. Układ hipotez jest następujący:\n\n\\(H_0: m_1 = m_2 = m_3 = ... = m_k\\)\n\\(H_1: \\exists_{i,j\\in\\{1,..,k\\}} \\; m_i \\neq m_j\\)\n\nZa pomocą funkcji aov() można w R przeprowadzić jednoczynnikową analizę wariancji. Jako argument funkcji należy podać formułę przedstawiającą zależność zmiennej badanej do zmiennej grupującej wykorzystując w tym celu symbol tyldy (~) w następującym kontekście: zmienna_analizowana ~ zmienna_grupująca. Przy takim zapisie należy także w argumencie data podać nazwę zbioru danych.\nW porównaniu do wcześniej opisanych funkcji, aov() nie zwraca w bezpośrednim wyniku wartości p. Aby uzyskać tę wartość należy wynik działania tej funkcji przypisać do obiektu, a następnie na nim wywołać funkcję summary().\nW przypadku odrzucenia hipotezy zerowej można przeprowadzić test Tukeya w celu identyfikacji różniących się par wykorzystując funkcję TukeyHSD() i jako argument podając obiekt zawierający wynik ANOVA.\nW sytuacji, w której założenia użycia testu parametrycznego nie są spełnione, należy skorzystać z testów nieparametrycznych. W przypadku testowania miar tendencji centralnej różnica pomiędzy testami parametrycznymi a nieparametrycznymi polega na zastąpieniu wartości średniej medianą. Z punktu widzenia obliczeń w miejsce oryginalnych wartości cechy wprowadza się rangi czyli następuje osłabienie skali pomiarowej - z ilorazowej na porządkową.\n\n\n6.7.3 Test Wilcoxona\nTest Wilcoxona jest nieparametryczną wersją testu t. Hipotezy w tym teście dotyczą równości rozkładów:\n\n\\(H_0: F_1=F_2\\)\n\\(H_1: F_1 \\neq F_2\\)\n\nWartość statystyki testowej będzie zależna od typu testu, natomiast w R funkcja, której należy użyć to wilcox.test(). Argumenty tej funkcji są takie same jak w przypadku testu t.\n\n\n6.7.4 Test Kruskala-Wallisa\nZ kolei test Kruskala-Wallisa jest nieparametrycznym odpowiednikiem ANOVA. Hipotezy są następujące:\n\n\\(H_0: F_1=F_2=F_3=...=F_k\\)\n\\(H_1: \\exists_{i,j\\in\\{1,..,k\\}} \\; F_i \\neq F_j\\)\n\nW programie R korzysta się z funkcji kruskal.test(), która przyjmuje takie same argumenty jak funkcja do metody ANOVA aov(). Główną różnicą jest sposób podawania wyniku testu, ponieważ w tym przypadku od razu otrzymujemy wartość p. W przypadku odrzucenia hipotezy zerowej należy sprawdzić, które grupy różnią się między sobą. Można to zrobić za pomocą funkcji pairwise.wilcox.test().\nPrzykład\nSprawdzimy czy średni poziom PM10 w latach 2015 i 2016 różnił się od siebie.\n\\(H_0\\): średni poziom PM10 w obu latach nie różni się\n\\(H_1\\): średni poziom PM10 w obu latach różni się\nW związku z tym, że badana cecha nie ma rozkładu normalnego zostanie przeprowadzony test Wilcoxona. Mamy tutaj do czynienia z testem dla prób niezależnych - badana jest jedna cecha (poziom PM10) w ramach rozłącznych grup.\n\n\n\n    Shapiro-Wilk normality test\n\ndata:  smog_2015_2016$pm10\nW = 0.68989, p-value &lt; 2.2e-16\n\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  smog_2015_2016$pm10 by smog_2015_2016$rok\nW = 66028, p-value = 0.1903\nalternative hypothesis: true location shift is not equal to 0\n\n\nPrzyjmując poziom istotności \\(\\alpha = 0,05\\) nie mamy podstaw do odrzucenia \\(H_0\\) - średni poziom PM10 w obu latach nie różni się.\nPrzykład\nCzy minimalna i maksymalna temperatura w ciągu dnia różni się od siebie w sposób istotny?\n\\(H_0\\): minimalna i maksymalna temperatura w ciągu dnia nie różni się istotnie\n\\(H_1\\): minimalna i maksymalna temperatura w ciągu dnia różni się istotnie\nW pierwszej kolejności weryfikujemy normalność rozkładu analizowanych cech.\n\nsmog_2019 &lt;- smog %&gt;% \n  filter(rok == 2019)\n\nshapiro.test(smog_2019$tmin_daily)\n\n\n    Shapiro-Wilk normality test\n\ndata:  smog_2019$tmin_daily\nW = 0.98742, p-value = 0.002985\n\nshapiro.test(smog_2019$tmax_daily)\n\n\n    Shapiro-Wilk normality test\n\ndata:  smog_2019$tmax_daily\nW = 0.97936, p-value = 4.377e-05\n\n\nTemperatura w tym zbiorze danych nie ma rozkładu normalnego. W tym przypadku analizujemy próby zależne - badamy dwie różne cechy dla tych samych jednostek (obserwacji).\n\nwilcox.test(x = smog_2019$tmin_daily, \n            y = smog_2019$tmax_daily,\n            paired = TRUE)\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  smog_2019$tmin_daily and smog_2019$tmax_daily\nV = 0, p-value &lt; 2.2e-16\nalternative hypothesis: true location shift is not equal to 0\n\n\nNa podstawie podanej wartości p odrzucamy \\(H_0\\) - minimalna i maksymalna temperatura w ciągu dnia różni się istotnie.\nPrzykład\nAnalogicznie można także sprawdzić czy np. poziom PM10 różni się w pomiędzy kwartałami - w takim przypadku rozpatrujemy głównie próby niezależne.\n\\(H_0\\): poziom PM10 nie różni się w pomiędzy kwartałami\n\\(H_1\\): poziom PM10 różni się w pomiędzy kwartałami - co najmniej jedna para jest różna\n\nkruskal.test(smog_2019$pm10 ~ smog_2019$kwartal)\n\n\n    Kruskal-Wallis rank sum test\n\ndata:  smog_2019$pm10 by smog_2019$kwartal\nKruskal-Wallis chi-squared = 83.318, df = 3, p-value &lt; 2.2e-16\n\n\nPrzyjmując poziom istotności \\(\\alpha = 0,05\\) odrzucamy hipotezę zerową - dla co najmniej jedna pary kwartałów występuje istotna różnica.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Statystyka opisowa</span>"
    ]
  },
  {
    "objectID": "07-git.html",
    "href": "07-git.html",
    "title": "7  System kontroli wersji",
    "section": "",
    "text": "7.1 Wprowadzenie\nPrezentacja\nGit to rozproszony system kontroli wersji, który umożliwia śledzenie zmian w kodzie, współpracę z innymi oraz zarządzanie różnymi wersjami projektu. RStudio oferuje wbudowaną integrację z Git, co znacznie ułatwia pracę z tym narzędziem bezpośrednio z poziomu interfejsu IDE.\nKorzyści z używania Git w projektach R\nPrzed rozpoczęciem pracy z Git w RStudio należy zainstalować Git na swoim komputerze. Konfiguracja Git w RStudio jest następująca:\nPodstawowa konfiguracja Git (nazwa użytkownika i email) może być wykonana z terminala RStudio:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>System kontroli wersji</span>"
    ]
  },
  {
    "objectID": "07-git.html#wprowadzenie",
    "href": "07-git.html#wprowadzenie",
    "title": "7  System kontroli wersji",
    "section": "",
    "text": "Historia zmian: Pełna historia modyfikacji w plikach projektu\nBezpieczeństwo danych: Możliwość przywrócenia poprzednich wersji kodu\nWspółpraca: Łatwe współdzielenie kodu i współpraca w zespole\nRozgałęzienia (branching): Możliwość pracy nad różnymi funkcjonalnościami jednocześnie\nIntegracja z platformami: Łatwa publikacja kodu na platformach takich jak GitHub, GitLab czy Bitbucket\n\n\n\nOtwórz RStudio\nPrzejdź do: Tools → Global Options → Git/SVN\nUpewnij się, że ścieżka do Git jest poprawnie ustawiona (Enable version control interface for RStudio projects)\nKliknij “Create RSA Key” jeśli chcesz wygenerować klucz SSH do bezpiecznej komunikacji z repozytoriami zdalnymi\n\n\ngit config --global user.name \"Twoje Imię i Nazwisko\"\ngit config --global user.email \"twoj.email@przyklad.com\"",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>System kontroli wersji</span>"
    ]
  },
  {
    "objectID": "07-git.html#tworzenie-i-korzystanie-z-projektów-z-kontrolą-wersji",
    "href": "07-git.html#tworzenie-i-korzystanie-z-projektów-z-kontrolą-wersji",
    "title": "7  System kontroli wersji",
    "section": "7.2 Tworzenie i korzystanie z projektów z kontrolą wersji",
    "text": "7.2 Tworzenie i korzystanie z projektów z kontrolą wersji\nMetoda 1: Nowy projekt z kontrolą wersji 1. File → New Project → New Directory 2. Wybierz typ projektu (np. R Project) 3. Zaznacz opcję “Create a git repository” 4. Kliknij “Create Project”\nMetoda 2: Inicjalizacja Git w istniejącym projekcie 1. Otwórz istniejący projekt RStudio 2. Tools → Project Options → Git/SVN 3. Wybierz “Git” jako system kontroli wersji 4. Zatwierdź zmiany i uruchom ponownie RStudio, gdy zostaniesz o to poproszony\nMetoda 3: Klonowanie istniejącego repozytorium 1. File → New Project → Version Control → Git 2. Wklej URL repozytorium, które chcesz sklonować 3. Wybierz katalog docelowy 4. Kliknij “Create Project”\nPo utworzeniu lub otwarciu projektu z kontrolą wersji Git, pojawi się nowy panel “Git” w RStudio. Oferuje on dostęp do najczęściej używanych funkcji Git",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>System kontroli wersji</span>"
    ]
  },
  {
    "objectID": "07-git.html#podstawowy-przepływ-pracy-z-git-w-rstudio",
    "href": "07-git.html#podstawowy-przepływ-pracy-z-git-w-rstudio",
    "title": "7  System kontroli wersji",
    "section": "7.3 Podstawowy przepływ pracy z Git w RStudio",
    "text": "7.3 Podstawowy przepływ pracy z Git w RStudio\nStaging zmian\n\nW panelu Git zobaczysz pliki, które zostały zmodyfikowane\nZaznacz pliki, które chcesz dodać do kolejnego commita (klikając checkbox)\nKliknij przycisk “Stage” (lub checkbox obok nazwy pliku)\n\nTworzenie commita\n\nPo zaznaczeniu plików kliknij przycisk “Commit”\nWpisz wiadomość commita (krótki opis wprowadzonych zmian)\nKliknij “Commit”\n\nPrzeglądanie historii zmian\n\nW oknie commit kliknij przycisk “History”\nPrzeglądaj historię commitów, daty, autorów i wprowadzone zmiany\n\nDodawanie zdalnego repozytorium 1. Utwórz repozytorium na GitHub/GitLab/Bitbucket 2. W terminalu RStudio wpisz:\ngit remote add origin https://github.com/username/repository.git\nPush (wysyłanie zmian do zdalnego repozytorium) 1. W panelu Git kliknij przycisk “Push” 2. Wprowadź dane logowania, jeśli zostaniesz o to poproszony\nPull (pobieranie zmian ze zdalnego repozytorium) 1. W panelu Git kliknij przycisk “Pull” 2. RStudio pobierze najnowsze zmiany z repozytorium zdalnego\nAby wykluczyć pliki z kontroli wersji (np. pliki tymczasowe, dane osobiste):\n\nUtwórz plik .gitignore w katalogu projektu\nDodaj do niego wzorce plików, które mają być ignorowane, np.:\n# Pliki R\n.Rhistory\n.RData\n.Rproj.user/\n\n# Pliki tymczasowe\n*.log\n*.tmp\n\n# Katalogi danych\n/data/raw/\n\nW Internecie dostępne są pliki .gitignore dla różnych języków programowania np. https://github.com/github/gitignore, a także często podczas tworzenia zdalnego repozytorium możliwe jest wskazanie języka programowania i powiązanego dla niego pliku.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>System kontroli wersji</span>"
    ]
  },
  {
    "objectID": "07-git.html#pomocne-pakiety-r-do-pracy-z-git",
    "href": "07-git.html#pomocne-pakiety-r-do-pracy-z-git",
    "title": "7  System kontroli wersji",
    "section": "7.4 Pomocne pakiety R do pracy z Git",
    "text": "7.4 Pomocne pakiety R do pracy z Git\n\n7.4.1 usethis\nPakiet usethis zawiera funkcje ułatwiające pracę z Git i GitHub:\n# Instalacja\ninstall.packages(\"usethis\")\n\n# Przykładowe funkcje\nusethis::use_git()            # Inicjalizuje repozytorium Git\nusethis::use_github()         # Tworzy repozytorium na GitHub\nusethis::use_git_ignore(\"*.csv\") # Dodaje wzorzec do .gitignore\nusethis::use_readme_md()      # Tworzy plik README.md\n\n\n7.4.2 gert\nPakiet gert umożliwia wykonywanie operacji Git bezpośrednio z kodu R:\n# Instalacja\ninstall.packages(\"gert\")\n\n# Przykładowe funkcje\nlibrary(gert)\ngit_status()        # Status repozytorium\ngit_add(\".\")        # Dodanie wszystkich zmian\ngit_commit(\"Opis commita\")  # Utworzenie commita\ngit_push()          # Push do zdalnego repozytorium\n\n\n7.4.3 remotes\nPakiet remotes jest nieocenionym narzędziem do instalacji pakietów R z różnych źródeł, w tym z repozytoriów Git:\n# Instalacja\ninstall.packages(\"remotes\")\n\n# Instalacja pakietu z GitHub\nremotes::install_github(\"username/repository\")\n\n# Instalacja pakietu z GitLab\nremotes::install_gitlab(\"username/repository\")\n\n# Instalacja pakietu z Bitbucket\nremotes::install_bitbucket(\"username/repository\")\n\n# Instalacja konkretnej wersji (np. określonej gałęzi)\nremotes::install_github(\"username/repository\", ref = \"develop\")\n\n# Instalacja z prywatnego repozytorium (wymaga tokenu autoryzacji)\nremotes::install_github(\"username/private-repo\", auth_token = \"your_PAT\")\nPakiet remotes oferuje wiele zalet podczas pracy z projektami R i kontrolą wersji:\n\nInstalacja pakietów w rozwoju - możesz instalować najnowsze wersje pakietów, które nie są jeszcze dostępne na CRAN\nWspółpraca - łatwa instalacja pakietów rozwojowych od współpracowników\nZależności - automatyczna instalacja zależności pakietu\nReproducibility - możliwość instalacji konkretnej wersji pakietu (commit, tag, gałąź)\nIntegracja z projektem - możesz określić zależności w pliku DESCRIPTION i zainstalować je wszystkie jednym poleceniem:\nremotes::install_deps()",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>System kontroli wersji</span>"
    ]
  },
  {
    "objectID": "07-git.html#przykładowe-scenariusze-pracy",
    "href": "07-git.html#przykładowe-scenariusze-pracy",
    "title": "7  System kontroli wersji",
    "section": "7.5 Przykładowe scenariusze pracy",
    "text": "7.5 Przykładowe scenariusze pracy\nRozpoczęcie nowego projektu analizy danych\n\nUtwórz nowy projekt RStudio z kontrolą wersji Git\nDodaj podstawowe pliki (.gitignore, README.md)\nUtwórz pierwszy commit\nUtwórz zdalne repozytorium i połącz z lokalnym\nWypchnij zmiany do zdalnego repozytorium\n\nCodzienna praca z projektem\n\nZacznij dzień od git pull aby pobrać ewentualne zmiany\nPracuj nad kodem w RStudio\nRegularnie zatwierdź zmiany (commit)\nNa koniec dnia wypchnij zmiany do repozytorium zdalnego (git push)\n\nWspółpraca z zespołem\n\nUtwórz nową gałąź dla swojego zadania\nPracuj na swojej gałęzi\nRegularnie pobieraj zmiany z gałęzi głównej (git pull origin main)\nPo zakończeniu pracy utwórz Pull/Merge Request\nPo przeglądzie kodu scal zmiany z gałęzią główną\n\nIntegracja Git z RStudio zapewnia potężne narzędzie do zarządzania projektami R, ułatwiając:\n\nŚledzenie historii zmian w kodzie\nBezpieczne eksperymentowanie z nowym kodem\nEfektywną współpracę z innymi\nDokumentowanie procesu analizy danych\nUdostępnianie pracy społeczności\n\nOpanowanie podstaw Git w znacząco podnosi produktywność i jakość pracy statystyka lub data scientista, jednocześnie promując dobre praktyki programistyczne i współpracę.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>System kontroli wersji</span>"
    ]
  }
]