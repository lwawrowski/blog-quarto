[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Podstawy programowania w R",
    "section": "",
    "text": "Wprowadzenie\nSkrypty z zajęć\nZbiory danych\nPolecana literatura:\n\nGarret Grolemund, Hadley Wickham - R for Data Science (polska wersja)\nMarek Gągolewski - Programowanie w języku R. Analiza danych, obliczenia, symulacje.\nJakub Nowosad - Elementarz programisty\nTomasz Zieliński - Poradnik dla sponiewieranych Excelem\nAnaliza danych z Banku Danych Lokalnych z wykorzystaniem programu R",
    "crumbs": [
      "Wprowadzenie"
    ]
  },
  {
    "objectID": "01-intro.html",
    "href": "01-intro.html",
    "title": "1  Wprowadzenie do R",
    "section": "",
    "text": "1.1 Wprowadzenie\nPrezentacja\nGNU R to interpretowany język programowania oraz środowisko do obliczeń statystycznych i wizualizacji wyników [Wikipedia 2017].\nRobert A. Muenchen - The Popularity of Data Science Software",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R</span>"
    ]
  },
  {
    "objectID": "01-intro.html#r",
    "href": "01-intro.html#r",
    "title": "1  Wprowadzenie do R",
    "section": "1.2 R",
    "text": "1.2 R\nBazowa wersja R jest do pobrania ze strony r-project.org.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R</span>"
    ]
  },
  {
    "objectID": "01-intro.html#rstudio",
    "href": "01-intro.html#rstudio",
    "title": "1  Wprowadzenie do R",
    "section": "1.3 RStudio",
    "text": "1.3 RStudio\nRStudio to zintegrowane środowisko programistyczne (IDE) dla języka R dostępne za darmo na stronie RStudio.\n\nZ R można także korzystać w Microsoft Visual Studio.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R</span>"
    ]
  },
  {
    "objectID": "01-intro.html#ważne-informacje",
    "href": "01-intro.html#ważne-informacje",
    "title": "1  Wprowadzenie do R",
    "section": "1.4 Ważne informacje",
    "text": "1.4 Ważne informacje\nR jest wrażliwy na wielkość liter.\nSeparatorem części dziesiętnej liczby jest kropka.\nW codziennej pracy RStudio jest wygodniejsze, jednak długotrwałe obliczenia lepiej uruchamiać w trybie wsadowym w zwykłym R.\n\nKatalog roboczy\n\nWażnym pojęciem w R jest katalog roboczy (ang. working directory), który określa gdzie zostaną zapisane pliki, wykresy, zbiory, itp. jeśli nie podamy dokładnej ścieżki do pliku. Katalog roboczy przypisuje się z wykorzystaniem funkcji setwd(\"ścieżka do katalogu\"), a jego wartość można sprawdzić funkcją getwd(). W RStudio przypisanie katalogu roboczego odbywa się w momencie utworzenia projektu.\n\nProjekt\n\nKatalog na dysku, w którym znajdują się wszystkie pliki projektu wraz z plikiem o rozszerzeniu .Rproj skojarzonym z RStudio.\n\nKorzystanie z pomocy\n\nDostęp do pomocy odnośnie wybranej funkcji można uzyskać na dwa sposoby. Pierwszym z nich jest poprzedzenie nazwy funkcji w konsoli znakiem zapytania np. ?getwd lub wywołanie funkcji help na nazwie funkcji help(\"getwd\"). Drugim sposobem jest umieszczenie kursora w dowolnym miejscu nazwy funkcji i wciśnięcie klawisza F1.\nInternet - przede wszystkim stackoverflow.\n\nKomentarze\n\n\nReal programmers don’t comment their code. If it was hard to write it should be hard to understand.\n\nDobrze napisany kod jest czytelny bez komentarzy. W R komentarze rozpoczynają się od symbolu #. Skrót klawiaturowy w RStudio to CTRL + SHIFT + C (do wstawiania i usuwania komentarzy).\n\nPodpowiadanie składni\n\nRStudio ma zaimplementowaną funkcję podpowiadania składni. Listę możliwych funkcji i obiektów wywołuję się klawiszem TAB lub CTRL + SPACJA po wpisaniu co najmniej jednej litery. Kolejne naciśnięcie TAB lub ENTER powoduje uzupełnienie kodu o wybraną funkcję lub obiekt.\n\nWykonywanie programów\n\nProgramy w R możemy tworzyć jako skrypty w pliku tekstowym o rozszerzeniu .R lub wywoływać polecenia bezpośrednio w konsoli. Kod programu napisanego w skrypcie przekazywany jest do konsoli. Gotowość do pracy R sygnalizuje w konsoli znakiem zachęty &gt;. Jeśli podczas wykonywania programu w konsoli pojawi się znak + to oznacza oczekiwanie na kompletny kod - brak domkniętego nawiasu, cudzysłowia, itp.:\n&gt; getwd(\n+ \nW powyższym przykładzie brakuje prawego nawiasu. Dodanie brakującego kodu spowoduje wykonanie przekazanego polecenia. Z kolei wciśnięcie klawisza ESC spowoduje przerwanie wykonywanie programu i powrót do znaku zachęty. Zawartość konsoli można wyczyścić stosując kombinację klawiszy CTRL + L.\n\nPliki \n\nJeśli w pamięci znajdują się jakieś obiekty (zakładka Environment) to RStudio przy zamykaniu programu zapyta o zapisanie tych obiektów do pliku .RData. Jeżeli zdecydujemy się na tą propozycję to po ponownym uruchomieniu projektu obiekty znajdujące się w pliku .RData zostaną automatycznie wczytane do pamięci.\nMożna także samodzielnie tworzyć pliki o rozszerzeniu .RData z wykorzystaniem funkcji save():\nsave(obiekt1, obiekt2, obiekt3, file = \"nazwa_pliku.RData\")\nWczytanie obiektów z takiego pliku do pamięci odbywa się z zastosowaniem funkcji load():\nload(\"nazwa_pliku.RData\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R</span>"
    ]
  },
  {
    "objectID": "01-intro.html#pakiety",
    "href": "01-intro.html#pakiety",
    "title": "1  Wprowadzenie do R",
    "section": "1.5 Pakiety",
    "text": "1.5 Pakiety\nPodstawowe możliwości R są dosyć ograniczone. Rozszerzają je pakiety, których obecnie jest ponad 12 tysięcy. Można je przeglądać według kategorii w CRAN Task Views lub w wygodnej wyszukiwarce METACRAN i rdrr.io.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R</span>"
    ]
  },
  {
    "objectID": "01-intro.html#r-jako-kalkulator",
    "href": "01-intro.html#r-jako-kalkulator",
    "title": "1  Wprowadzenie do R",
    "section": "1.6 R jako kalkulator",
    "text": "1.6 R jako kalkulator\nDziałania matematycznie w R:\n\n\n\nOperator\nOperacja\n\n\n\n\n+\ndodawanie\n\n\n-\nodejmowanie\n\n\n*\nmnożenie\n\n\n/\ndzielenie\n\n\n^ lub **\npotęgowanie\n\n\nsqrt()\npierwiastkowanie\n\n\n\nW R istnieje także stała wbudowana pi przechowująca wartość liczby pi.\nFunkcja factorial(x) zwraca silnię (znak wykrzyknika !) z podanej wartości x, a sign(x) sprawdza znak wyrażenia i zwraca odpowiednio wartość -1 jeśli wyrażenie jest ujemne, 0 jeśli jest równe 0 i 1 dla wyrażeń dodatnich.\nFunkcja exp(x) zwraca wartość wyrażenia \\(e^x\\), natomiast funkcja log(x) zwraca logarytm z podanej liczby. Domyślnie jest to logarytm naturalny, ale można zmienić podstawę podając wartość argumentu base.\nFunkcja abs(x) zwraca wartość bezwzględną (absolutną) wyrażenia.\nĆwiczenie\nOblicz wartość wyrażenia: \\(2\\cdot \\sqrt{\\pi} + log_28\\).\nRozwiązanie:\n\n2*sqrt(pi)+log(8,2)\n\n[1] 6.544908\n\n\nZadania\nOblicz wartość wyrażeń:\n\n\\(\\frac{2^3\\cdot6^2}{(\\frac{1}{2})^2\\cdot(\\frac{4}{5})^3}\\)\n\\(\\sqrt[3]{\\frac{6-3.5}{2^{11}}}\\)\n\\(\\pi+\\sqrt{e^4}\\)\n\\(5! - log_{10}100\\)\n\\(|1-e|\\)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Wprowadzenie do R</span>"
    ]
  },
  {
    "objectID": "02-struktury.html",
    "href": "02-struktury.html",
    "title": "2  Struktury danych",
    "section": "",
    "text": "2.1 Obiekty\nPrezentacja\nW R praktycznie wszystko jest obiektem. Może to być zbiór danych, ale także wykres czy mapa. Zasadnicza różnica to klasa tych obiektów i operacje jakie mogą być na nich wykonywane.\nFunkcje w R wymagają jako argumentów określonych typów obiektów - stąd tak ważna jak znajomość istniejących struktur.\nKażdy obiekt w R możemy przypisać do tzw. obiektu nazwanego. Wówczas jest przechowywany w pamięci i można się do niego odwołać. Przypisanie odbywa się za pomocą operatora &lt;-.\nMożna także przypisywać obiekty z wykorzystaniem znaku równości =, ale nie jest to zalecane ponieważ symbol ten jest używany w innych miejscach np. do deklarowania wartości argumentów w funkcji.\nW R dostępna jest funkcja assign, która także umożliwia przypisanie nazwy do obiektu:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#obiekty",
    "href": "02-struktury.html#obiekty",
    "title": "2  Struktury danych",
    "section": "",
    "text": "nazwa &lt;- obiekt\nobiekt -&gt; nazwa\n\n\nassign(\"nazwa\", obiekt)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#wektor",
    "href": "02-struktury.html#wektor",
    "title": "2  Struktury danych",
    "section": "2.2 Wektor",
    "text": "2.2 Wektor\nWektor jest najprostszym typem danych w R. Najczęściej korzysta się z trzech typów wektorów:\n\nlogicznych\nliczbowych\ntekstowych\n\nWektor tworzy się z wykorzystaniem funkcji c().\n\n2.2.1 Wektor wartości logicznych\nPrzyjmuje wartości prawda lub fałsz:\n\nc(TRUE, FALSE, FALSE)\n\n[1]  TRUE FALSE FALSE\n\n\nlub w skróconej wersji:\n\nc(T, F, F)\n\n[1]  TRUE FALSE FALSE\n\n\nDo sprawdzenia długości wektora używa się funkcji length:\n\nlength(c(T, F, F))\n\n[1] 3\n\n\nlub korzystając z obiektu nazwanego:\n\nwart_log &lt;- c(T,F,F)\nlength(wart_log)\n\n[1] 3\n\n\nWektory można także utworzyć poprzez replikację określonej wartości lub wektora z wykorzystaniem funkcji rep. Funkcja ta przyjmuje co najmniej dwa argumenty: obowiązkowo x - wektor wejściowy oraz jeden z następujących: times - liczba powtórzeń elementów wektora x, each - liczba powtórzeń elementów wektora x (wyjaśnienie różnicy poniżej) lub length.out - oczekiwana długość wektora wynikowego.\nTrzy równoważne zapisy:\n\nrep(x = c(T,F), times = 3)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\nrep(c(T,F), times = 3)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\nrep(c(T,F), 3)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\n\nA tak to wygląda z argumentem each:\n\nrep(c(T,F), each = 3)\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\n\nWykorzystanie argumentu length.out:\n\nrep(c(T,F), length.out = 5)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n\n\n\n\n2.2.2 Wektor wartości liczbowych\nW wektorze możemy przechowywać także liczby:\n\nc(1, 3, -5, 2.5, .6) # nie trzeba pisać zera przed ułamkiem\n\n[1]  1.0  3.0 -5.0  2.5  0.6\n\n\nPołączenie dwóch wektorów to także wektor:\n\nc(c(1,2,3), c(3.5,4,4.5))\n\n[1] 1.0 2.0 3.0 3.5 4.0 4.5\n\n\nPojedyncza liczba też jest jednoelementowym wektorem:\n\nlength(2)\n\n[1] 1\n\n\nProste ciągi o różnicy równej 1 można generować wykorzystując dwukropek:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nlub\n\nc(-5:-1,1:5)\n\n [1] -5 -4 -3 -2 -1  1  2  3  4  5\n\n\nDo generowania ciągów liczbowych o różnych różnicach wykorzystuje się funkcję seq, która przyjmuje następujące argumenty. Wartość początkową from, wartość końcową to oraz jeden z następujących: by - krok lub length.out - oczekiwana długość wektora.\nTo samo co 1:10\n\nseq(1, 10, 1)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWartości niecałkowite:\n\nseq(1, 2, 0.2)\n\n[1] 1.0 1.2 1.4 1.6 1.8 2.0\n\n\nWektor wartości malejących:\n\nseq(10, 1, by=1) # błędny zapis\n\nError in seq.default(10, 1, by = 1): wrong sign in 'by' argument\n\nseq(10, 1, by=-1) # poprawny zapis\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n\nTworzenie wektora w oparciu o argument length.out - funkcja sama dobiera krok:\n\nseq(1, 7, length.out = 13)\n\n [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0\n\n\nDo generowania liczb pseudolosowych służy funkcja runif(n), która do poprawnego wywołania wymaga tylko jednego argumentu - długości wektora wynikowego. Domyślnie losowane są liczby z przedziału \\([0;1]\\) (tak jak w funkcji los() w Excelu), można to jednak zmienić podając odpowiednie wartości argumentów min i max.\n\nrunif(6)\n\n[1] 0.5519858 0.7107668 0.8127037 0.8278362 0.2701283 0.8738734\n\n\nObserwacje można także generować z innych rozkładów:\n\nrnorm - rozkład normalny,\nrchisq - rozkład \\(\\chi^2\\),\nrt - rozkład t-studenta,\nitp.\n\nWykaz wszystkich dostępnych w R rozkładów uzyskamy wywołując polecenie help(\"Distributions\").\nZa każdym uruchomieniem jednej z wymienionych wyżej funkcji losujących wartości z danego rozkładu otrzymamy inne wartości:\n\nrunif(5)\n\n[1] 0.6104689 0.4780427 0.4971193 0.3586298 0.2959498\n\nrunif(5)\n\n[1] 0.54269878 0.62818310 0.03376876 0.97142105 0.85999207\n\n\nPowtarzalność wyników możemy uzyskać ustalając ziarno generatora:\n\nset.seed(123)\nrunif(5)\n\n[1] 0.2875775 0.7883051 0.4089769 0.8830174 0.9404673\n\nset.seed(123)\nrunif(5)\n\n[1] 0.2875775 0.7883051 0.4089769 0.8830174 0.9404673\n\n\n\n\n2.2.3 Wektor wartości tekstowych\nW wektorze może być przechowywany tekst - wówczas poszczególne elementy zapisujemy w cudzysłowie lub apostrofach:\n\nc(\"ala\", \"ma\", \"kota\")\n\n[1] \"ala\"  \"ma\"   \"kota\"\n\nc('ala', 'ma', 'kota')\n\n[1] \"ala\"  \"ma\"   \"kota\"\n\n\nW RStudio wygodniej używać cudzysłowu, ponieważ program automatycznie go zamyka.\nIstnieje także stała zawierająca litery alfabetu:\n\nletters\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nLETTERS\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n\n\n\n2.2.4 Przeciążanie wektora\nJeśli w wektorze pomieszamy kilka typów zmiennych to R przekształci poszczególne wartości, tak aby stracić jak najmniej informacji:\n\nc(TRUE, 2, 5)\n\n[1] 1 2 5\n\nc(3, \"cztery\", 5)\n\n[1] \"3\"      \"cztery\" \"5\"     \n\n\nW pierwszym przypadku wartość TRUE została przekształcona na odpowiednik liczbowy - 1. Z kolei w drugim przykładzie podane liczby zostały przekonwertowane na tekst.\n\n\n2.2.5 Operacje na wektorach\nNa wektorach logicznych i liczbowych można wykonywać operacje arytmetyczne np. mnożenie:\n\n1:10*2\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\nWektor liczbowy plus wektor liczbowy:\n\n1:10 + c(1,2)\n\n [1]  2  4  4  6  6  8  8 10 10 12\n\n\nWektor liczbowy razy wektor liczbowy:\n\n1:10 * c(1,2)\n\n [1]  1  4  3  8  5 12  7 16  9 20\n\n\nWektor liczbowy razy wektor logiczny:\n\n1:10 * c(T, F)\n\n [1] 1 0 3 0 5 0 7 0 9 0\n\n\nDługości obu wektorów muszą być odpowiednie:\n\n1:10 * c(T,F,T)\n\nWarning in 1:10 * c(T, F, T): longer object length is not a multiple of shorter\nobject length\n\n\n [1]  1  0  3  4  0  6  7  0  9 10\n\n\nDłuższy z wektorów musi być wielokrotnością krótszego.\nSiłą rzeczy działania arytmetyczne na wektorach tekstowych nie są możliwe:\n\nc(\"jeden\", \"dwa\", \"trzy\", \"cztery\") * c(T,F)\n\nError in c(\"jeden\", \"dwa\", \"trzy\", \"cztery\") * c(T, F): non-numeric argument to binary operator\n\nc(\"jeden\", \"dwa\", \"trzy\", \"cztery\") + c(1,2)\n\nError in c(\"jeden\", \"dwa\", \"trzy\", \"cztery\") + c(1, 2): non-numeric argument to binary operator\n\n\n\n\n2.2.6 Operacje agregujące\nNa wektorach można także wykonywać operacje agregujące:\n\n\n\nFunkcja\nDziałanie\n\n\n\n\nmean()\nśrednia elementów\n\n\nsum()\nsuma elementów\n\n\nprod()\niloczyn elementów\n\n\nvar()\nwariancja elementów\n\n\nsd()\nodchylenie standardowe elementów\n\n\nmedian()\nmediana elementów\n\n\nquantile()\nkwantyl danego rzędu\n\n\nmin()\nminimum\n\n\nmax()\nmaksimum\n\n\n\nObliczenie skośności i kurtozy jest możliwe po zainstalowaniu pakietu e1071. Wówczas mamy dostęp do funkcji:\n\n\n\nFunkcja\nDziałanie\n\n\n\n\nskewness()\nskośność elementów\n\n\nkurtosis()\nkurtoza elementów\n\n\n\nSuma wektora numerycznego:\n\nsum(1:10)\n\n[1] 55\n\n\nSuma i średnia wektora logicznego:\n\nsum(c(T, F, F, T))\n\n[1] 2\n\nmean(c(T, F, F, T))\n\n[1] 0.5\n\n\nKorzystanie z funkcji pochodzących z pakietów zewnętrznych wymaga wskazania skąd pochodzi dana funkcja. Można to zrobić na dwa sposoby: funkcją library(pakiet) - wówczas wszystkie funkcje z tego pakietu są wczytywane do pamięci i można do nich sięgać bezpośrednio lub wskazując przed nazwą funkcji z jakiego pakietu pochodzi.\nWczytanie pakietu:\n\nlibrary(e1071)\nskewness(c(1,2,3,4,5,7,9,11,13))\n\n[1] 0.3451259\n\n\nlub równoważnie:\n\ne1071::skewness(c(1,2,3,4,5,7,9,11,13))\n\n[1] 0.3451259\n\n\nPodsumowanie rozkładu wektora można także uzyskać z wykorzystaniem funkcji summary(x):\n\nsummary(1:10)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    3.25    5.50    5.50    7.75   10.00 \n\n\nDziała także na wektorach tekstowych:\n\nsummary(c(\"jeden\", \"dwa\", \"trzy\", \"cztery\"))\n\n   Length     Class      Mode \n        4 character character \n\n\n\n\n2.2.7 Sprawdzanie typu wektora\nDo określenia typu wektora służy funkcja typeof, class lub mode.\n\ntypeof(wart_log)\n\n[1] \"logical\"\n\n\nSprawdzenie czy obiekt jest danego typu odbywa się z wykorzystaniem dedykowanych funkcji z przyrostkiem is.\n\nis.logical(wart_log)\n\n[1] TRUE\n\nis.character(wart_log)\n\n[1] FALSE\n\n\n\n\n2.2.8 Rzutowanie wektorów\nCzasami jako np. argument funkcji będzie wymagany inny typ wektora aniżeli aktualnie posiadany w pamięci. Można wówczas spróbować przekształcić taki wektor z wykorzystaniem funkcji rozpoczynającej się od as.:\n\ntypeof(wart_log)\n\n[1] \"logical\"\n\nas.numeric(wart_log)\n\n[1] 1 0 0\n\ntypeof(as.numeric(wart_log))\n\n[1] \"double\"\n\n\n\n\n2.2.9 Indeksowanie wektorów\nAby uzyskać dostęp do części wektora korzysta się z indeksatora w postaci nawiasów kwadratowych. Utworzymy nowy wektor zawierający liczby całkowite od 10 do 20:\n\nwart_10_20 &lt;- seq(10,20)\nwart_10_20\n\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\na następnie wybieramy trzecią obserwację:\n\nwart_10_20[3]\n\n[1] 12\n\n\nMożemy także odwołać się do większego zakresu:\n\nwart_10_20[3:5]\n\n[1] 12 13 14\n\n\nI wybranych elementów:\n\nwart_10_20[c(1,3,5)]\n\n[1] 10 12 14\n\n\nW ten sposób można także modyfikować odpowiednie elementy wektora:\n\nwart_10_20[7] &lt;- 90\n\nWybór obserwacji większych od 15:\n\nwart_10_20[wart_10_20&gt;15]\n\n[1] 90 17 18 19 20\n\n\nZ kolei następujący zapis zwróci nam wektor wartości logicznych:\n\nwart_10_20 &gt; 15\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n\n2.2.10 Wartości nieliczbowe\nBrak danych w R jest przedstawiany jako wartość NA (ang. not available) i może powodować trudności z wywoływaniem niektórych funkcji:\n\nv_na &lt;- c(1,2,1,NA,1)\nv_na\n\n[1]  1  2  1 NA  1\n\nsum(v_na)\n\n[1] NA\n\n\nW związku z tym większość funkcji ma zaimplementowany dodatkowy argument służący do obsługi tego typu wartości, który najczęściej nie uwzględnia tych wartości w obliczeniach:\n\nsum(v_na, na.rm = TRUE)\n\n[1] 5\n\n\nOprócz braku danych podczas obliczeń możemy natrafić na wartości nieokreślone NaN (ang. not a number) oraz nieskończone Inf (ang. infinity).\n\n0/0\n\n[1] NaN\n\n1/0\n\n[1] Inf\n\nsqrt(-10)\n\nWarning in sqrt(-10): NaNs produced\n\n\n[1] NaN\n\n\nW R istnieje także wartość NULL, która jest podstawowym typem danych a nie wartością. NULL można traktować jako odpowiednik zbioru pustego. Jest stosowany np. w funkcjach, które niczego nie zwracają.\n\nv_null &lt;- c(1,2,1,NULL,1)\nv_null\n\n[1] 1 2 1 1\n\nsum(v_null)\n\n[1] 5\n\n\n\n\n2.2.11 Zadania\n\nIle wynosi suma elementów większych od 10 dla następujących liczb: 12, 5, 20, 18, 8.5, 10, 4, 101, -2?\nZ wykorzystaniem funkcji seq i na podstawie wektora … dokonaj przekształcenia tworząc następujący wektor: 2 0 0 4 0 0 6 0 0 8 0 0.\nDane są dwa wektory - a: 2, 3, 7, 8, 2, b: 9, 1, 2, 0, 2. Jakiego typu będzie wektor będący wynikiem działania a&lt;=b?\nUzupełnij wektor letters o polskie litery diakrytyzowane. Jaką długość ma nowo utworzony wektor?\nWylosuj z rozkładu normalnego 1000 obserwacji z ziarnem równym 76. Ile wynosi kurtoza tych wartości?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#macierz",
    "href": "02-struktury.html#macierz",
    "title": "2  Struktury danych",
    "section": "2.3 Macierz",
    "text": "2.3 Macierz\nMacierze są wykorzystywane w R do przechowywania np. odległości pomiędzy punktami czy wskazywania sąsiedztwa obszarów geograficznych.\nDo tworzenia macierzy służy funkcja matrix:\n\nm &lt;- matrix(1:6, nrow = 2, ncol=3)\nm\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nZ wykorzystaniem wybranych funkcji można sprawdzić wymiary macierzy, liczbę wierszy oraz kolumn:\n\ndim(m)\n\n[1] 2 3\n\nncol(m)\n\n[1] 3\n\nnrow(m)\n\n[1] 2\n\n\nMacierz może także zawierać tekst:\n\nmatrix(letters[1:9], nrow=3)\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"d\"  \"g\" \n[2,] \"b\"  \"e\"  \"h\" \n[3,] \"c\"  \"f\"  \"i\" \n\n\nDomyślnie macierz układana jest kolumnami. Aby to zmienić należy dodać argument byrow=TRUE:\n\nmatrix(letters[1:9], nrow=3, byrow=TRUE)\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"b\"  \"c\" \n[2,] \"d\"  \"e\"  \"f\" \n[3,] \"g\"  \"h\"  \"i\" \n\n\nJeśli liczba elementów wejściowych jest mniejsza iloczyn podanej liczby kolumn i wierszy to w brakujące miejsce wstawiane są elementy z początku wektora wejściowego:\n\nmatrix(letters[1:7], nrow=3, byrow=TRUE)\n\nWarning in matrix(letters[1:7], nrow = 3, byrow = TRUE): data length [7] is not\na sub-multiple or multiple of the number of rows [3]\n\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"b\"  \"c\" \n[2,] \"d\"  \"e\"  \"f\" \n[3,] \"g\"  \"a\"  \"b\" \n\n\nZ kolei macierz diagnonalną posiadającą elementy niezerowe wyłącznie na przekątnej tworzy się z wykorzystaniem funkcji diag. Macierz jednostkowa o wymiarach \\(4 \\times 4\\):\n\ndiag(4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    1    0    0\n[3,]    0    0    1    0\n[4,]    0    0    0    1\n\n\nMacierz diagonalna o wartościach 5 na przekątnej i wymiarach \\(3 \\times 3\\)\n\ndiag(5, nrow=3, ncol=3)\n\n     [,1] [,2] [,3]\n[1,]    5    0    0\n[2,]    0    5    0\n[3,]    0    0    5\n\n\nFunkcja diag umożliwia także ekstrakcję przekątnej z istniejącej już macierzy:\n\ndiag(matrix(letters[1:9], nrow=3))\n\n[1] \"a\" \"e\" \"i\"\n\n\n\n2.3.1 Łączenie macierzy\nZ wykorzystaniem funkcji rbind i cbind można odpowiednio łączyć obiekty wierszami (ang. row bind) lub kolumnami (ang. col bind):\n\nrbind(m, c(99, 88, 77))\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n[3,]   99   88   77\n\ncbind(m, matrix(101:104, nrow=2))\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5  101  103\n[2,]    2    4    6  102  104\n\n\n\n\n2.3.2 Indeksowanie macierzy\nDostęp do poszczególnych elementów macierzy odbywa się z wykorzystaniem nawiasów kwadratowych, ale można podać dwie wartość - obiekt[wiersz,kolumna]:\n\nm[2,1] # drugi wiersz, pierwsza kolumna\n\n[1] 2\n\nm[2,]  # tylko drugi wiersz\n\n[1] 2 4 6\n\nm[,1]  # tylko pierwsza kolumna\n\n[1] 1 2\n\nm[,]   # wszystkie obserwacje\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nm[]    # wszystkie obserwacje\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nW ten sposób można dokonać modyfikacji konkretnych elementów macierzy:\n\nm[2,1] &lt;- 77\nm\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]   77    4    6\n\n\n\n\n2.3.3 Operacje na macierzach\nNa macierzach można wywołać szereg operacji:\n\n\n\nOperator/funkcja\nDziałanie\n\n\n\n\na %*% b\nmnożenie macierzy a i b\n\n\nt(a)\ntranspozycja macierzy a\n\n\ndet(a)\nwyznacznik macierzy a\n\n\nsolve(a)\nmacierz odwrotna z a\n\n\nsolve(a, b)\nrozwiązanie układu a*x=b\n\n\n\nRozważmy dwie macierze:\n\na &lt;- matrix(c(2, 3, 4, 2, 1, 2, 1, 3, 2), nrow = 3)\nb &lt;- matrix(6:1, ncol=2)\na;b\n\n     [,1] [,2] [,3]\n[1,]    2    2    1\n[2,]    3    1    3\n[3,]    4    2    2\n\n\n     [,1] [,2]\n[1,]    6    3\n[2,]    5    2\n[3,]    4    1\n\n\nAby przeprowadzić mnożenie macierzy a i b, liczba kolumn macierzy a musi być równa liczbie wierszy w macierzy b. Z kolei rozmiar macierzy wyjściowej to liczba wierszy macierzy a i liczba kolumn macierzy b.\n\na %*% b\n\n     [,1] [,2]\n[1,]   26   11\n[2,]   35   14\n[3,]   42   18\n\n\nTranspozycja macierzy b:\n\nt(b)\n\n     [,1] [,2] [,3]\n[1,]    6    5    4\n[2,]    3    2    1\n\n\nWyznacznik macierzy a:\n\ndet(a)\n\n[1] 6\n\n\nMacierz odwrotna do macierzy a:\n\nsolve(a)\n\n           [,1]       [,2]       [,3]\n[1,] -0.6666667 -0.3333333  0.8333333\n[2,]  1.0000000  0.0000000 -0.5000000\n[3,]  0.3333333  0.6666667 -0.6666667\n\n\nWyznaczenie macierzy x w równaniu a*x=b:\n\nsolve(a,b)\n\n          [,1]      [,2]\n[1,] -2.333333 -1.833333\n[2,]  4.000000  2.500000\n[3,]  2.666667  1.666667\n\na %*% solve(a,b)\n\n     [,1] [,2]\n[1,]    6    3\n[2,]    5    2\n[3,]    4    1\n\nb\n\n     [,1] [,2]\n[1,]    6    3\n[2,]    5    2\n[3,]    4    1\n\n\n\n\n2.3.4 Zadanie\n\nCo powstanie po przemnożeniu macierzy przez jej macierz odwrotną?\nEstymator parametrów beta w metodzie najmniejszych kwadratów jest dany wzorem:\n\n\\[b=(X'X)^{-1}X'y\\]\nZmienna \\(x_1\\) przyjmuje wartości 2,4,1,6,9,3,2,9,10,7, zmienna \\(x_2\\) 1.5,0.2,0.1,2,3.1,1.2,0.4,2.9,2.5,1.9, a zmienna \\(x_0\\) to wektor jedynek. Te trzy zmienne tworzą macierz \\(X\\). Z kolei wartości zmiennej \\(y\\) są następujące 12,15,10,19,26,13,13,21,29,18. Wyznacz wartość \\(b\\).\n\nzad1 &lt;- matrix(1:4, nrow=2)\nsolve(zad1)\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\nzad1 %*% solve(zad1)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#czynnik",
    "href": "02-struktury.html#czynnik",
    "title": "2  Struktury danych",
    "section": "2.4 Czynnik",
    "text": "2.4 Czynnik\nCzynnik (ang. factor) służy do przechowywania danych jakościowych o mało licznej liczbie kategorii, mierzonych na skali nominalnej i porządkowej.\nRozważmy informacje o wykształceniu:\n\nwyk &lt;- rep(c(\"podstawowe\", \"średnie\", \"wyższe\"), c(5,3,2))\nwyk\n\n [1] \"podstawowe\" \"podstawowe\" \"podstawowe\" \"podstawowe\" \"podstawowe\"\n [6] \"średnie\"    \"średnie\"    \"średnie\"    \"wyższe\"     \"wyższe\"    \n\n\ni dokonajmy transformacji na czynnik:\n\nwyk_f &lt;- factor(wyk)\nwyk_f\n\n [1] podstawowe podstawowe podstawowe podstawowe podstawowe średnie   \n [7] średnie    średnie    wyższe     wyższe    \nLevels: podstawowe średnie wyższe\n\n\nFunkcja summary() wywołana na czynniku zwraca wynik innego typu aniżeli na wektorze tekstowym:\n\nsummary(wyk)\n\n   Length     Class      Mode \n       10 character character \n\nsummary(wyk_f)\n\npodstawowe    średnie     wyższe \n         5          3          2 \n\n\nJeśli chcemy zaakcentować fakt, że zmienne są mierzone na skali porządkowej dodajemy argument ordered=TRUE:\n\nwyk_of &lt;- factor(wyk, ordered = TRUE)\nwyk_of\n\n [1] podstawowe podstawowe podstawowe podstawowe podstawowe średnie   \n [7] średnie    średnie    wyższe     wyższe    \nLevels: podstawowe &lt; średnie &lt; wyższe\n\n\nW łatwy sposób możemy edytować etykiety:\n\nlevels(wyk_of) &lt;- c(\"pod.\", \"śr.\", \"wyż.\")\nwyk_of\n\n [1] pod. pod. pod. pod. pod. śr.  śr.  śr.  wyż. wyż.\nLevels: pod. &lt; śr. &lt; wyż.\n\n\nCzynniki mają szczególne znaczenie w przypadku tworzenia wykresów, gdy chcemy określić porządek wyświetlania.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#lista",
    "href": "02-struktury.html#lista",
    "title": "2  Struktury danych",
    "section": "2.5 Lista",
    "text": "2.5 Lista\nListy to ciągi złożone z elementów o dowolnych typach. Mogą przydać się w szczególności przy budowaniu funkcji, które zwracają tylko jedną wartość. Wówczas dane różnego typu mogą być zawarte w takiej liście.\nTworzenie prostej listy:\n\nl &lt;- list(TRUE, c(1,2,3,4), \"element tekstowy\")\nl\n\n[[1]]\n[1] TRUE\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] \"element tekstowy\"\n\n\nJuż na pierwszy rzut oka widać bardziej złożoną strukturę listy. W związku z tym odwoływanie do poszczególnych elementów będzie trochę się różnić od wektorów czy macierzy.\n\nl[2] # druga lista\n\n[[1]]\n[1] 1 2 3 4\n\nl[[2]] # zawartość listy\n\n[1] 1 2 3 4\n\nl[[2]][3] # trzeci element wektora drugiej listy\n\n[1] 3\n\n\nListę można także rozwinąć do wektora z wykorzystaniem funkcji unlist:\n\nunlist(l)\n\n[1] \"TRUE\"             \"1\"                \"2\"                \"3\"               \n[5] \"4\"                \"element tekstowy\"\n\n\nPoszczególne elementy listy można nazwać:\n\nln &lt;- list(log=TRUE, num=c(1,2,3,4), tekst=\"element tekstowy\")\nln\n\n$log\n[1] TRUE\n\n$num\n[1] 1 2 3 4\n\n$tekst\n[1] \"element tekstowy\"\n\n\nWówczas można uzyskać do nich dostęp poprzez symbol $ i podaną nazwę:\n\nln$num\n\n[1] 1 2 3 4\n\nln[[2]] # normalne indeksowanie nadal działa\n\n[1] 1 2 3 4\n\nln$num[2]\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "02-struktury.html#ramka-danych",
    "href": "02-struktury.html#ramka-danych",
    "title": "2  Struktury danych",
    "section": "2.6 Ramka danych",
    "text": "2.6 Ramka danych\nRamka danych to tabela, która przypomina tą z Excela zawierająca dane o różnych typach. Tworzona za pomocą funkcji data.frame:\n\ndf &lt;- data.frame(plec=c(\"m\", \"k\", \"k\", \"m\", \"k\", \"m\", \"m\", \"m\"),\n                 wzrost=c(173, 170, 163, 178, 169, 180, 175, NA),\n                 pali=c(T, F, F, F, T, F, NA, T))\n\nW RStudio po wybraniu tego obiektu w zakładce Environment pojawia się przyjazne okno do przeglądania oraz poglądowego filtrowania i sortowania danych ze zbioru.\nMożemy zobaczyć podsumowanie całego zbioru wywołując na nim funkcję summary():\n\nsummary(df)\n\n     plec               wzrost         pali        \n Length:8           Min.   :163.0   Mode :logical  \n Class :character   1st Qu.:169.5   FALSE:4        \n Mode  :character   Median :173.0   TRUE :3        \n                    Mean   :172.6   NA's :1        \n                    3rd Qu.:176.5                  \n                    Max.   :180.0                  \n                    NA's   :1                      \n\n\nRamki danych można indeksować w taki sam sposób jak macierze lub z wykorzystaniem operatora $:\n\ndf[,2] # druga kolumna\n\n[1] 173 170 163 178 169 180 175  NA\n\ndf$wzrost # kolumna wzrost\n\n[1] 173 170 163 178 169 180 175  NA\n\ndf[,c(\"plec\", \"pali\")]\n\n  plec  pali\n1    m  TRUE\n2    k FALSE\n3    k FALSE\n4    m FALSE\n5    k  TRUE\n6    m FALSE\n7    m    NA\n8    m  TRUE\n\n\nZ kolei do wyboru obserwacji można wykorzystać warunek:\n\ndf[df$plec==\"m\",]\n\n  plec wzrost  pali\n1    m    173  TRUE\n4    m    178 FALSE\n6    m    180 FALSE\n7    m    175    NA\n8    m     NA  TRUE\n\n\nWyodrębnienie informacji o wzroście tylko dla kobiet i wyznaczenie średniej:\n\nwzrost_k &lt;- df$wzrost[df$plec == \"k\"]\nwzrost_k\n\n[1] 170 163 169\n\nmean(wzrost_k)\n\n[1] 167.3333\n\n\nWidzimy, że dla mężczyzn nie udało się ustalić wszystkich informacji i jeden z nich nie ma podanego wzrostu, a dla drugiego brakuje informacji o paleniu papierosów. Możemy usunąć braki danych w kolumnach korzystając z funkcji complete.cases():\n\ndf[complete.cases(df$wzrost),] # tylko zmienna wzrost\n\n  plec wzrost  pali\n1    m    173  TRUE\n2    k    170 FALSE\n3    k    163 FALSE\n4    m    178 FALSE\n5    k    169  TRUE\n6    m    180 FALSE\n7    m    175    NA\n\ndf[complete.cases(df),] # wszystkie zmienne\n\n  plec wzrost  pali\n1    m    173  TRUE\n2    k    170 FALSE\n3    k    163 FALSE\n4    m    178 FALSE\n5    k    169  TRUE\n6    m    180 FALSE\n\n\nZbiory danych przechowywane są także w R i pochodzą z różnych pakietów. Wywołując funkcję data(\"zbior\") ładujemy dany zbiór do pamięci. Do szybkiego podglądu zebranych danych służy funkcja head(), która domyślnie wyświetla 6 pierwszych obserwacji ze zbioru:\n\ndata(\"iris\")\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\n\n2.6.1 Zadania\nZaładuj do pamięci zbiór o nazwie ChickWeight.\n\nIle razy jedzenie otrzymał kurczak o numerze 15?\nIle wynosi mediana wagi kurczaka o numerze 35?\nIle średnio ważyły kurczaki na diecie nr 1, a ile na diecie nr 2?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Struktury danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html",
    "href": "03-przetwarzanie.html",
    "title": "3  Przetwarzanie danych",
    "section": "",
    "text": "3.1 Wprowadzenie - pakiet tidyverse\nPrezentacja - wczytywanie danych\nPrezentacja - przetwarzanie\nPakiet tidyverse to zestaw pakietów do kompleksowego przetwarzania i wizualizacji danych. Ładuje następujące pakiety:\nManifest tidyverse ustala następujące zasady:\nWobec tego załadujmy pakiet tidyverse:\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nW konsoli pojawi się informacja o wersji załadowanych pakietów oraz o konfliktach występujących pomiędzy pakietami. Konflikty te wynikają z takich samych nazw funkcji w różnych pakietach. Kolejność wczytywania pakietów ma znaczenie - kolejny pakiet przykryje funkcje z wcześniej wczytanego. Wywołanie przykrytej funkcji jest możliwe poprzez zapis nazwa_pakietu::nazwa_funkcji.\nKorzystanie z pakietu i zasad tidyverse to dużo bardziej czytelny kod w porównaniu do wbudowanych funkcji. Poniżej przedstawiony jest przykład przetwarzania danych polegający na filtrowaniu, wyborze kolumn oraz utworzeniu nowej zmiennej.\ndata(\"ChickWeight\")\n\n# bez pakietu tidyverse\n\nchick_15 &lt;- ChickWeight[ChickWeight$Chick==\"15\",]\nchick_15 &lt;- chick_15[c(\"weight\", \"Time\", \"Diet\"),]\nchick_15$weight_kg &lt;- chick_15$weight/1000\n\n# z pakietem tidyverse\n\nchick_15 &lt;- ChickWeight %&gt;%\n  filter(Chick==\"15\") %&gt;%\n  select(-Chick) %&gt;%\n  mutate(weight_kg=weight/1000)\nRozwiązanie z wykorzystaniem wbudowanych funkcji to 133 znaki, natomiast wykorzystanie tidyverse to 30% oszczędność miejsca i tylko 92 znaki.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#wprowadzenie---pakiet-tidyverse",
    "href": "03-przetwarzanie.html#wprowadzenie---pakiet-tidyverse",
    "title": "3  Przetwarzanie danych",
    "section": "",
    "text": "ggplot2 - tworzenie wykresów,\ndplyr - przetwarzanie danych,\ntidyr - zmiana reprezentacji danych,\nreadr - wczytywanie danych tekstowych,\npurrr - programowanie funkcyjne\ntibble - sposób przechowywania danych,\nstringr - przetwarzanie tekstów,\nforcats - przetwarzanie faktorów\nlubridate - operacje na datach\n\n\n\npowtórne użycie istniejących struktur danych,\ntworzenie czytelnych kodów z operatorem pipe %&gt;% (ang. rura, przewód, łącznik).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#import-danych",
    "href": "03-przetwarzanie.html#import-danych",
    "title": "3  Przetwarzanie danych",
    "section": "3.2 Import danych",
    "text": "3.2 Import danych\nWczytywanie danych do R jest możliwe z wielu różnych źródeł. Funkcje, które to umożliwiają zwykle mają nazwę rozpoczynającą się od read.\nBędziemy korzystać z następujących zbiorów danych:\n\nmovies - plik tekstowy zawierający informacje o filmach,\nbank - plik excel zawierający dane dot. kampanii marketingowej banku, opis zmiennych,\nrossmann - plik excel zawierający dane ze sklepów Rossmann,\nlotto - plik tekstowy zawierający dane z losowań Lotto.\n\n\n3.2.1 Pliki CSV\nDo wczytywania plików csv można wykorzystać wbudowaną funkcję read.csv() lub tą pochodzącą z pakietu readr - read_csv(). W obu przypadkach wynik wczytania będzie podobny.\n\nmovies &lt;- read.csv(\"data/movies.csv\")\n\nmovies2 &lt;- read_csv(\"data/movies.csv\")\n\nRows: 2961 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): title, genre, director\ndbl (8): year, duration, gross, budget, cast_facebook_likes, votes, reviews,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nJeśli nas plik ma nietypową strukturę to w funkcji read.csv() możemy określić dodatkowe argumenty informując o nazwach kolumn obecnych w pliku (header =), separatorze kolumn (sep =) lub separatorze miejsc dziesiętnych (dec =)\n\nmovies &lt;- read.csv(file = \"data/movies.csv\", header = T, sep=\",\", dec=\".\")\n\n\n\n3.2.2 Pliki excel\nDo wczytywania plików z Excela niezbędny jest dodatkowy pakiet readxl. W funkcji read_xlsx() podajemy jako argument nazwę pliku. Możemy także dodać nazwę lub numer arkusza w argumencie (sheet =) oraz zakres komórek jako wartość argumentu range =.\n\nlibrary(readxl)\n\nbank &lt;- read_xlsx(\"data/bank.xlsx\")\n\n# bank &lt;- read_xlsx(\"data/bank.xlsx\", sheet = \"dane\")\n# bank &lt;- read_xlsx(\"data/bank.xlsx\", sheet = 1)\n\nbank_a1i30 &lt;- read_xlsx(\"data/bank.xlsx\", range = \"A1:I30\")\n\nrossmann &lt;- read_xlsx(\"data/rossmann.xlsx\")\n\n\n\n3.2.3 Pliki tekstowe\nZ kolei do wczytywania plików tekstowych wykorzystuje się funkcję read.table(). Wczytywany plik nie musi być zlokalizowany na dysku twardym - może to być link internetowy.\n\nlotto &lt;- read.table(\"http://www.mbnet.com.pl/dl.txt\")\nnames(lotto) &lt;- c(\"lp\", \"data\", \"numery\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#filtrowanie",
    "href": "03-przetwarzanie.html#filtrowanie",
    "title": "3  Przetwarzanie danych",
    "section": "3.3 Filtrowanie",
    "text": "3.3 Filtrowanie\nDo przetwarzania danych służą funkcje z pakietu dplyr. Większość z nich jako pierwszy argument przyjmuje przetwarzany zbiór danych, ale można tego uniknąć wykorzystując symbole %&gt;%.\nFiltrowanie polega na wybraniu obserwacji, które spełniają określony warunek lub warunki. Ze zbioru movies wybierzmy wszystkie komedie:\n\nkomedie &lt;- filter(movies, genre==\"Comedy\")\n\nlub alternatywnie:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\")\n\nPo zmiennej, która jest filtrowana musimy podać operator porównania czyli podwójny znak równości ==. Jeśli chcemy filtrować po większej liczbie zmiennych to kolejne warunki dodajemy po przecinku:\n\nkomedie_2012 &lt;- movies %&gt;%\n  filter(genre==\"Comedy\", year==2012)\n\nWówczas oba warunki muszą zostać spełnione czyli pomiędzy nimi zachodzi relacja i. Równoważny zapis jest następujący:\n\nkomedie_2012 &lt;- movies %&gt;%\n  filter(genre==\"Comedy\" & year==2012)\n\nPomiędzy warunkami może także zachodzić relacja lub. Wybieramy filmy, które są komediami lub miały swoją premierę w 2012 roku.\n\nkomedie_l_2012 &lt;- movies %&gt;%\n  filter(genre==\"Comedy\" | year==2012)\n\nMożliwy jest także wybór wielu kryteriów filtrowania poprzez operator %in%:\n\nkomedie_familijne &lt;- movies %&gt;%\n  filter(genre %in% c(\"Comedy\", \"Family\"))\n\nmovies_2000_2010 &lt;- movies %&gt;%\n  filter(year %in% 2000:2010)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#wybieranie-kolumn",
    "href": "03-przetwarzanie.html#wybieranie-kolumn",
    "title": "3  Przetwarzanie danych",
    "section": "3.4 Wybieranie kolumn",
    "text": "3.4 Wybieranie kolumn\nDo wyboru kolumn służy funkcja select(). Zmodyfikujemy wcześniej utworzony zbiór komedie:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(title, year, duration, budget, rating)\n\nTen sam kod możemy zapisać zagnieżdżając funkcje, ale traci on w ten sposób na czytelności:\n\nkomedie &lt;- select(filter(movies, genre==\"Comedy\"), title, year, duration, budget, rating)\n\nMożemy także wskazać, które zmienne nie mają znaleźć się w zbiorze wynikowym:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre)\n\nNatomiast jeśli zmiennych jest więcej to musimy jest umieścić w wektorze, żeby nie pisać przed każdą zmienną znaku minus:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre, -director, -gross, -budget)\n\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-c(genre, director, gross, budget))\n\nZ wykorzystaniem znaku dwukropka możemy także wskazywać zakresy zmiennych:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre, -c(gross:reviews))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#tworzenie-nowych-zmiennych",
    "href": "03-przetwarzanie.html#tworzenie-nowych-zmiennych",
    "title": "3  Przetwarzanie danych",
    "section": "3.5 Tworzenie nowych zmiennych",
    "text": "3.5 Tworzenie nowych zmiennych\nDo utworzenia nowej zmiennej wykorzystuje się funkcję mutate(). Utwórzmy w naszym zbiorze nową zmienną, która będzie zawierała czas trwania filmu w godzinach:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre, -c(gross:reviews)) %&gt;%\n  mutate(dur_hour = duration/60)\n\nRozsądnie będzie zaokrąglić otrzymaną wartość do jednego miejsca po przecinku - służy do tego funkcja round():\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre, -c(gross:reviews)) %&gt;%\n  mutate(dur_hour = round(duration/60,1))\n\nZ kolei funkcja transmute() tworzy zbiór w którym jest tylko nowo utworzona kolumna:\n\nkomedie_t &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre, -c(gross:reviews)) %&gt;%\n  transmute(dur_hour = round(duration/60,1))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#zmiana-nazwy-zmiennej",
    "href": "03-przetwarzanie.html#zmiana-nazwy-zmiennej",
    "title": "3  Przetwarzanie danych",
    "section": "3.6 Zmiana nazwy zmiennej",
    "text": "3.6 Zmiana nazwy zmiennej\nDo zmiany nazw zmiennych służy funkcja rename(). Najpierw podajemy nazwę nowej zmiennej, a po znaku równości starą nazwę:\n\nbank &lt;- bank %&gt;%\n  rename(karta=kredyt)\n\nZmiany nazwy można także dokonać z wykorzystaniem funkcji select:\n\nbank_nowy &lt;- bank %&gt;%\n  select(lokata=wynik)\n\nW takim przypadku trzeba jednak pamiętać o wypisaniu wszystkich zmiennych, które mają się znaleźć w zbiorze wynikowym.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#podsumowanie-danych",
    "href": "03-przetwarzanie.html#podsumowanie-danych",
    "title": "3  Przetwarzanie danych",
    "section": "3.7 Podsumowanie danych",
    "text": "3.7 Podsumowanie danych\nFunkcja summarise() służy do podsumowań danych w formie zagregowanej:\n\nbank %&gt;%\n  summarise(saldo_srednia=mean(saldo),\n            saldo_mediana=median(saldo))\n\n# A tibble: 1 × 2\n  saldo_srednia saldo_mediana\n          &lt;dbl&gt;         &lt;dbl&gt;\n1         1362.           448\n\n\nPodsumowanie danych ma najwięcej sensu w połączniu z funkcją grupującą.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#grupowanie",
    "href": "03-przetwarzanie.html#grupowanie",
    "title": "3  Przetwarzanie danych",
    "section": "3.8 Grupowanie",
    "text": "3.8 Grupowanie\nDo grupowania obserwacji służy funkcja group_by(). Zobaczmy jak wyglądają statystyki salda w poszczególnych grupach wykształcenia:\n\nbank %&gt;%\n  group_by(wykszt) %&gt;%\n  summarise(saldo_srednia=mean(saldo),\n            saldo_mediana=median(saldo))\n\n# A tibble: 4 × 3\n  wykszt     saldo_srednia saldo_mediana\n  &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;\n1 podstawowe         1251.           403\n2 srednie            1155.           392\n3 wyzsze             1758.           577\n4 &lt;NA&gt;               1527.           568\n\n\nPo przecinku w funkcji group_by() można wskazać kolejne zmienne grupujące:\n\nbank %&gt;%\n  group_by(wykszt, hipoteka) %&gt;%\n  summarise(saldo_srednia=mean(saldo),\n            saldo_mediana=median(saldo))\n\n`summarise()` has grouped output by 'wykszt'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 8 × 4\n# Groups:   wykszt [4]\n  wykszt     hipoteka saldo_srednia saldo_mediana\n  &lt;chr&gt;      &lt;chr&gt;            &lt;dbl&gt;         &lt;dbl&gt;\n1 podstawowe nie              1571.          521 \n2 podstawowe tak              1008.          344.\n3 srednie    nie              1340.          416.\n4 srednie    tak              1034.          380 \n5 wyzsze     nie              1919.          618 \n6 wyzsze     tak              1584.          543 \n7 &lt;NA&gt;       nie              1780.          679 \n8 &lt;NA&gt;       tak              1207.          442 \n\n\nPrzydatna jest także funkcja n(), która nie przyjmuje żadnego argumentu i zwraca liczebność zbioru bądź grupy.\n\nbank %&gt;%\n  group_by(wykszt) %&gt;%\n  summarise(liczebnosc=n(),\n            saldo_srednia=mean(saldo),\n            saldo_mediana=median(saldo))\n\n# A tibble: 4 × 4\n  wykszt     liczebnosc saldo_srednia saldo_mediana\n  &lt;chr&gt;           &lt;int&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 podstawowe       6851         1251.           403\n2 srednie         23202         1155.           392\n3 wyzsze          13301         1758.           577\n4 &lt;NA&gt;             1857         1527.           568\n\n\nJeżeli chcemy tylko wyznaczyć liczebności grup to możemy skorzystać z funkcji count():\n\nbank %&gt;%\n  group_by(wykszt) %&gt;%\n  count()\n\n# A tibble: 4 × 2\n# Groups:   wykszt [4]\n  wykszt         n\n  &lt;chr&gt;      &lt;int&gt;\n1 podstawowe  6851\n2 srednie    23202\n3 wyzsze     13301\n4 &lt;NA&gt;        1857\n\n\nJedną z kategorii zmiennej wykształcenie jest brak danych (NA). Zamienimy tą wartość na kategorię nieustalone z wykorzystaniem funkcji mutate() oraz if_else(). Funkcja if_else() przyjmuje trzy argumenty - pierwszy (condition =) to warunek, który jest weryfikowany, następnie podajemy wartość, która ma być wprowadzona w przypadku spełnienia warunku (true =), a na końcu wartość dla niespełnionego warunku (false =). Jest to odpowiednik funkcji JEŻELI z Excela.\nW omawianym przykładzie warunkiem jest sprawdzenie czy wartości zmiennej wykszt są równe NA. Jeśli tak to na ich miejsce wprowadzany jest tekst nieustalone, a w przeciwnym przypadku pozostaje oryginalna wartość.\n\nbank %&gt;%\n  mutate(wykszt=if_else(is.na(wykszt), \"nieustalone\", wykszt)) %&gt;%\n  group_by(wykszt) %&gt;%\n  count()\n\n# A tibble: 4 × 2\n# Groups:   wykszt [4]\n  wykszt          n\n  &lt;chr&gt;       &lt;int&gt;\n1 nieustalone  1857\n2 podstawowe   6851\n3 srednie     23202\n4 wyzsze      13301",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#sortowanie",
    "href": "03-przetwarzanie.html#sortowanie",
    "title": "3  Przetwarzanie danych",
    "section": "3.9 Sortowanie",
    "text": "3.9 Sortowanie\nSortowanie jest możliwe z wykorzystaniem funkcji arrange(). Jako argument podajemy zmienną według, której chcemy posortować zbiór. Domyślne zbiór sortowany jest rosnąco - od wartości najmniejszych do największych:\n\nbank_sort &lt;- bank %&gt;%\n  arrange(saldo)\n\nZmiana kierunku sortowania jest możliwa po zastosowaniu funkcji desc():\n\nbank_sort &lt;- bank %&gt;%\n  arrange(desc(saldo))\n\nSortowanie możemy także zastosować do wyników podsumowania danych:\n\nbank %&gt;%\n  group_by(wykszt) %&gt;%\n  summarise(liczebnosc=n(),\n            saldo_srednia=mean(saldo),\n            saldo_mediana=median(saldo)) %&gt;%\n  arrange(saldo_srednia)\n\n# A tibble: 4 × 4\n  wykszt     liczebnosc saldo_srednia saldo_mediana\n  &lt;chr&gt;           &lt;int&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 srednie         23202         1155.           392\n2 podstawowe       6851         1251.           403\n3 &lt;NA&gt;             1857         1527.           568\n4 wyzsze          13301         1758.           577",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#łączenie-zbiorów",
    "href": "03-przetwarzanie.html#łączenie-zbiorów",
    "title": "3  Przetwarzanie danych",
    "section": "3.10 Łączenie zbiorów",
    "text": "3.10 Łączenie zbiorów\nW celu zaprezentowania funkcji łączących dane przygotujemy kilka zbiorów pomocniczych:\n\npraca_czas &lt;- bank %&gt;%\n  group_by(praca) %&gt;%\n  summarise(sr_czas=mean(czas))\n\npraca_saldo &lt;- bank %&gt;%\n  group_by(praca) %&gt;%\n  summarise(sr_saldo=mean(saldo))\n\nzawod_saldo &lt;- bank %&gt;%\n  rename(zawod=praca) %&gt;%\n  group_by(zawod) %&gt;%\n  summarise(sr_saldo=mean(saldo))\n\nDo łączenia dwóch zbiorów danych służy funkcja inner_join(), która jako argumenty przyjmuje nazwy zbiorów danych oraz klucz łączenia. Jeśli w obu zbiorach występują kolumny o takich samych nazwach to zostaną potraktowane jako klucz łączenia:\n\npraca_czas_saldo &lt;- inner_join(praca_czas, praca_saldo)\n\nJoining with `by = join_by(praca)`\n\n\nJeśli takie kolumny nie będą istniały to wywołanie funkcji zwróci błąd:\n\npraca_czas_saldo &lt;- inner_join(praca_czas, zawod_saldo)\n\nError in `inner_join()`:\n! `by` must be supplied when `x` and `y` have no common variables.\nℹ Use `cross_join()` to perform a cross-join.\n\n\nW takich przypadku należy wskazać klucz połączenia w postaci by = c(\"id1\"=\"id2\"):\n\npraca_czas_saldo &lt;- inner_join(praca_czas, zawod_saldo, by=c(\"praca\"=\"zawod\"))\n\nJeśli w jednym ze zbiorów nie ma wszystkich identyfikatorów, które znajdują się w drugim zbiorze to zastosowanie funkcji inner_join() będzie skutkowało zbiorem, w którym znajdą się tylko te obserwacje, które udało się połączyć.\n\npraca_saldo_1500 &lt;- praca_saldo %&gt;%\n  filter(sr_saldo &gt; 1500)\n\ninner_join(praca_czas, praca_saldo_1500, by=\"praca\")\n\n# A tibble: 6 × 3\n  praca sr_czas sr_saldo\n  &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n1     2    289.    1522.\n2     3    254.    1764.\n3     5    256.    1521.\n4     7    268.    1648.\n5     8    287.    1984.\n6    NA    238.    1772.\n\n\nJeśli chcemy pozostawić niedopasowane obserwacje to należy wykorzystać jedną z funkcji - left_join() lub right_join() w zależności od tego dla którego zbioru chcemy pozostawić wszystkie informacje.\n\nleft_join(praca_czas, praca_saldo_1500, by=\"praca\")\n\n# A tibble: 11 × 3\n   praca sr_czas sr_saldo\n   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n 1     1    247.      NA \n 2     2    289.    1522.\n 3     3    254.    1764.\n 4     4    246.      NA \n 5     5    256.    1521.\n 6     6    263.      NA \n 7     7    268.    1648.\n 8     8    287.    1984.\n 9     9    253.      NA \n10    10    257.      NA \n11    NA    238.    1772.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#szeroka-i-wąska-reprezentacja-danych",
    "href": "03-przetwarzanie.html#szeroka-i-wąska-reprezentacja-danych",
    "title": "3  Przetwarzanie danych",
    "section": "3.11 Szeroka i wąska reprezentacja danych",
    "text": "3.11 Szeroka i wąska reprezentacja danych\nDo wyjaśnienia kwestii szerokiej i wąskiej reprezentacji danych posłużymy się danymi z GUS dotyczącymi przeciętnego miesięcznego spożycie wybranych artykułów żywnościowych na 1 osobę w 2016 roku - plik.\n\nspozycie &lt;- read_xlsx(\"data/spozycie.xlsx\")\n\nTaka tabela jest przykładem szerokiej reprezentacji danych. Z kolei w niektórych sytuacjach wygodnie jest korzystać z wąskiej reprezentacji danych, a niektóre pakiety wręcz wymagają takich zbiorów wejściowych.\nDo transformacji danych z reprezentacji szerokiej na wąską służy funkcja gather() (pol. gromadzić). Kluczowe są w niej dwa argumenty - pierwszy (key) określa nazwę nowej kolumny, która będzie zawierała nazwy zmiennych, a drugi (value) określa nazwę nowej kolumny, która będzie zawierała wartości zmiennych. Jako kolejne argumenty podaje się nazwy kolumn, które mają być transformowane lub nazwy kolumn ze znakiem minus -, które nie mają być transformowane.\n\nspozycie_waskie &lt;- spozycie %&gt;%\n  gather(artykul, spozycie, mieso, owoce, warzywa)\n\n# spozycie_waskie &lt;- spozycie %&gt;%\n#   gather(artykul, spozycie, -kod, -nazwa)\n\nW takiej formie łatwiej podsumować dane:\n\nspozycie_waskie %&gt;%\n  group_by(artykul) %&gt;%\n  summarise(sr_spozycie=mean(spozycie))\n\n# A tibble: 3 × 2\n  artykul sr_spozycie\n  &lt;chr&gt;         &lt;dbl&gt;\n1 mieso          5.47\n2 owoce          3.65\n3 warzywa        8.85\n\n\nW porównaniu do szerokiej reprezentacji danych:\n\nspozycie %&gt;%\n  summarise(sr_spozycie_mieso=mean(mieso),\n            sr_spozycie_owoce=mean(owoce),\n            sr_spozycie_warzywa=mean(warzywa))\n\n# A tibble: 1 × 3\n  sr_spozycie_mieso sr_spozycie_owoce sr_spozycie_warzywa\n              &lt;dbl&gt;             &lt;dbl&gt;               &lt;dbl&gt;\n1              5.47              3.65                8.85\n\n\nTransformacja z wąskiej do szerokiej reprezentacji danych jest możliwa z zastosowaniem funkcji spread() (pol. rozprzestrzeniać). W przypadku tej funkcji niezbędne są dwa argumenty - pierwszy (key) wskazuje kolumnę zawierającą nazwy dla nowych zmiennych, a drugi argument (value) wskazuje kolumnę zawierającą wartości dla nowych zmiennych.\n\nspozycie_szerokie &lt;- spozycie_waskie %&gt;%\n  spread(artykul, spozycie)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#eksport-danych",
    "href": "03-przetwarzanie.html#eksport-danych",
    "title": "3  Przetwarzanie danych",
    "section": "3.12 Eksport danych",
    "text": "3.12 Eksport danych\nZapis zbioru danych do zewnętrznego pliku jest możliwy z wykorzystaniem funkcji write.table(). Jako argumenty tej funkcji określamy: zbiór danych (x), docelowe miejsce na dysku i nazwę pliku (file), separator kolumn (sep), separator miejsc dziesiętnych (dec) oraz argument row.names = FALSE, dzięki któremu unikniemy dodatkowych numerów wierszy.\n\nwrite.table(spozycie_waskie, file = \"data/spozycie_w.csv\", sep=\";\", dec=\",\", row.names=F)\n\nTaki plik jest plikiem csv, który możemy otworzyć w Excelu i zapisać go z rozszerzeniem .xlsx. Teoretycznie istnieje pakiet xlsx, który umożliwia zapisywanie zbiorów od razu do Excela, ale działa w oparciu o Javę, co bywa problematyczne.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "03-przetwarzanie.html#zadania",
    "href": "03-przetwarzanie.html#zadania",
    "title": "3  Przetwarzanie danych",
    "section": "3.13 Zadania",
    "text": "3.13 Zadania\n\n3.13.1 Rossmann\nNa podstawie zbioru Rossmann odpowiedź na pytania:\n\nIle było sklepów o asortymencie rozszerzonym w dniu 25-02-2014?\nW jaki dzień tygodnia średnia liczba klientów była największa w sklepie nr 101?\nSklep jakiego typu charakteryzuje się największą medianą sprzedaży?\nCzy w ciągu roku odległość do najbliższego sklepu konkurencji zmieniła się dla jakiegokolwiek sklepu Rossmann?\nPołącz dane ze sklepów Rossmann z danymi o średnim kursie EUR/PLN z 2014 roku, który można pobrać ze strony NBP. Przelicz wielkość sprzedaży na złotówki.\n\n\n\n3.13.2 Wybory 2020\nNa podstawie zbioru dotyczącego wyborów prezydenckich w 2020 roku odpowiedź na pytania:\n\nIle obwodów głosowania miało frekwencję powyżej 80%?\nIle obwodów głosowania znajduje się w Poznaniu?\n\nIle jest obwodów według typu obszaru?\nJaka była średnia frekwencja w województwach?\nGdzie była największa różnica pomiędzy kandydatami?\n\n\n\n3.13.3 Mistrzostwa Świata\nNa podstawie zbioru dotyczącego wyników meczów rozegranych w ramach Mistrzostw Świata odpowiedź na pytania:\n\nIle razy Włochy grały w finale MŚ?\nJaka jest największa liczba bramek w jednym meczu?\n\nJakie miasto najczęściej gościło piłkarzy?\nJaka była średnia liczba widzów?\nIle było meczów, w których drużyna prowadząca po pierwszej połowie ostatecznie przegrywała?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Przetwarzanie danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html",
    "href": "04-wizualizacja.html",
    "title": "4  Wizualizacja danych",
    "section": "",
    "text": "4.1 Wprowadzenie\nPrezentacja\nBędziemy działać na zbiorze dotyczącym sprzedaży w sklepach: rossmann.xlsx i rossmann.RData.\nlibrary(tidyverse)\n\n# library(readxl)\n# \n# rossmann &lt;- read_xlsx(\"data/rossmann.xlsx\")\n#\n# save(rossmann, file=\"data/rossmann.RData\")\n\n# natywny format, mniejszy rozmiar, szybsze wczytywanie\nload(\"data/rossmann.RData\")\n\nsklep77 &lt;- rossmann %&gt;%\n  filter(sklep_id==77, czy_otwarty==\"Tak\")\nDo prostych wykresów można wykorzystać wbudowaną funkcję plot.\nplot(sklep77$sprzedaz, sklep77$liczba_klientow, \n     xlab = \"Sprzedaż\", ylab = \"Liczba klientów\",\n     main = \"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\")\nJej możliwości są jednak ograniczone i stworzenie bardziej zaawansowanych grafik będzie wymagające.\nWiodącym pakietem do wizualizacji danych w R jest ggplot2:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html#wprowadzenie",
    "href": "04-wizualizacja.html#wprowadzenie",
    "title": "4  Wizualizacja danych",
    "section": "",
    "text": "dokumentacja: https://ggplot2.tidyverse.org/\ncheatsheet\ntworzenie wykresów poprzez dodawanie (+) kolejnych warstw",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html#wykres-punktowy",
    "href": "04-wizualizacja.html#wykres-punktowy",
    "title": "4  Wizualizacja danych",
    "section": "4.2 Wykres punktowy",
    "text": "4.2 Wykres punktowy\nTen sam wykres co wcześniej, ale z wykorzystaniem pakietu ggplot2.\n\n\n\n\n\n\n\n\n\nWykonanie krok po kroku:\n\nUtworzenie siatki - określenie co chcemy na wykresie przedstawić\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow))\n\n\n\n\n\n\n\n\nW zależności od typu wykresu w funkcji aes mogą znaleźć się argumenty:\n\nx\ny\nfill\nsize\ncolor\nshape\n\n\nOkreślenie w jaki sposób chcemy te dane przedstawić - funkcja zawsze zaczyna się od geom_:\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nEdytowanie etykiet osi - funkcje xlab i ylab:\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\")\n\n\n\n\n\n\n\n\n\nDodanie tytułu - funkcja ggtitle\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\")\n\n\n\n\n\n\n\n\n\nZmiana motywu - funkcja rozpoczynająca się od theme_:\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\n\n\n\n\nDostępne motywy:\n\ntheme_bw\ntheme_classic\ntheme_dark\ntheme_gray\ntheme_light\ntheme_linedraw\ntheme_minimal\ntheme_void\n\nPowyższe motywy są zaimplementowane w pakiecie ggplot2, ale można także skorzystać z dodatkowych pakietów:\n\ntheme_bbc\ntheme_xkcd\n\nAlbo stworzyć swój własny motyw.\nZadanie\nZmień motyw wykresu na wybrany przez siebie.\nDodamy teraz do wykresu kolejną cechę - rozpoczęcie promocji, żeby sprawdzić czy istnieje jakaś tendencja.\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\n\n\n\n\nOkazuje się dosyć interesująco, niemniej nazwa etykiety legendy nie wygląda zbyt dobrze. Żeby to poprawić musimy użyć funkcji scale_\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\n\n\n\n\nW funkcji scale_ musimy podać w jaki sposób daną cechę wizualizujemy (x/y/color/…) oraz jakiego jest typu. Oprócz nazwy w tej funkcji możemy określić wiele innych kwestii takich jak:\n\nwyświetlane etykiety\npoczątek i koniec osi\nkolory wariantów\netykiety wariantów\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\n\n\n\n\nZmiana pozycji legendy możliwa jest z wykorzystaniem funkcji theme:\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n\n`geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html#histogram",
    "href": "04-wizualizacja.html#histogram",
    "title": "4  Wizualizacja danych",
    "section": "4.3 Histogram",
    "text": "4.3 Histogram\nRozkład cechy można ocenić na podstawie histogramu - domyślnie rysowanych jest 30 słupków.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nW funkcji geom_histogram można podać liczbę słupków (bins) albo ich szerokość (binwidth). Poniżej zastosowano słupki o szerokości 1000 euro.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 1000)\n\n\n\n\n\n\n\n\nDodatkowo w tej funkcji można określić kwestie estetyczne - kolory obramowania i wypełnienia słupków.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 500, color = \"black\", fill = \"green\")\n\n\n\n\n\n\n\n\nPełna lista nazw kolorów znajduje się tutaj.\nZ wykorzystaniem funkcji scale_ zmieniamy nazwy osi (name), granice (limits) oraz wskazania liczbowe (breaks). Te dwie ostatnie wartości musimy deklarować jako wektory z wykorzystaniem funkcji c().\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 500, \n                 color = \"black\", fill = \"green\") +\n  scale_x_continuous(name = \"Sprzedaż\", \n                     limits = c(4000,17000),\n                     breaks = c(5000, 8000, 11000)) +\n  scale_y_continuous(name = \"Liczebność\",\n                     limits = c(0,50))\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_bar()`).\n\n\n\n\n\n\n\n\n\nMożna zaumatyzować proces dobierania wskazań liczbowych z wykorzystaniem funkcji seq opisanej szerzej w rozdziale 2.1.2.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 500, \n                 color = \"black\", fill = \"green\") +\n  scale_x_continuous(name = \"Sprzedaż\", \n                     limits = c(4000,17000),\n                     breaks = seq(4000, 17000, 1500)) +\n  scale_y_continuous(name = \"Liczebność\",\n                     limits = c(0,50))\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_bar()`).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html#wykres-pudełkowy",
    "href": "04-wizualizacja.html#wykres-pudełkowy",
    "title": "4  Wizualizacja danych",
    "section": "4.4 Wykres pudełkowy",
    "text": "4.4 Wykres pudełkowy\nWykres pudełkowy umożliwia porównywanie rozkładów cechy wg zmiennej grupującej. Wymogiem jest aby na osi x znajdowała się zmienna grupująca, a na osi y cecha analizowana.\nPrzeanalizujemy sprzedaż według kolejnych dni tygodnia.\n\nggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) + geom_boxplot()\n\nWarning: Continuous x aesthetic\nℹ did you forget `aes(group = ...)`?\n\n\n\n\n\n\n\n\n\nZdecydowanie nie jest wykres jakiego oczekiwaliśmy. Wynika to z faktu, że dzień tygodnia w zbiorze danych jest zapisany jako zmienna numeryczna, natomiast prawidłowym typem dla zmiennej grupującej jest typ tekstowy lub czynnik (faktor). Ten typ danych został szczegółowo opisany w części 2.3.\nDokonujemy zatem zamiany typu danych:\n\nsklep77 &lt;- sklep77 %&gt;%\n  mutate(dzien_tyg=factor(x = dzien_tyg,\n                          levels = 1:6,\n                          labels = c(\"Pon\", \"Wt\", \"Śr\", \"Czw\", \"Pt\", \"Sob\"),\n                          ordered = TRUE))\n\nggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) +\n  geom_boxplot() \n\n\n\n\n\n\n\n\nZ tego wykresu można już odczytać, że najwyższa mediana sprzedaży występuje w poniedziałek, a najniższa w środę.\nJeżli kategorii jest dużo to można obrócić wykres z wykorzystaniem funkcji coord_flip.\n\nggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) +\n  geom_boxplot() +\n  coord_flip()\n\n\n\n\n\n\n\n\nUżycie tej funkcji powoduje wyłącznie obrócenie wykresu. Nazwy osi nie uległy zmianie pomimo, że zostały zamienione. Odwrócimy jeszcze kolejność etykiet dnia tygodnia, tak aby na górze był poniedziałek.\n\nggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) +\n  geom_boxplot() +\n  coord_flip() +\n  scale_x_discrete(limits = rev(levels(sklep77$dzien_tyg)))",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html#wykres-słupkowy",
    "href": "04-wizualizacja.html#wykres-słupkowy",
    "title": "4  Wizualizacja danych",
    "section": "4.5 Wykres słupkowy",
    "text": "4.5 Wykres słupkowy\nW zależności od typu danych wejściowych, wykres słupkowy można stworzyć na dwa sposoby:\n\ndane jednostkowe - geom_bar - funkcja sama oblicza wartości do wyświetlenia,\ndane zagregowane - geom_col - funkcja otrzymuje już obliczone wartości.\n\nSprawdźmy ile jest sklepów o danym asortymencie. W tym celu potrzebujemy informację o sklepie i typie oferowanego asortymentu.\n\nrossmann_asort &lt;- rossmann %&gt;%\n  select(sklep_id, sklep_asort) %&gt;%\n  distinct()\n\nglimpse(rossmann_asort)\n\nRows: 1,115\nColumns: 2\n$ sklep_id    &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18,…\n$ sklep_asort &lt;chr&gt; \"Podstawowy\", \"Podstawowy\", \"Podstawowy\", \"Rozszerzony\", \"…\n\n\nW funkcji aes podajemy tylko kolumnę zawierającą dane do zliczenia.\n\nggplot(rossmann_asort, aes(x=sklep_asort)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nNatomiast użycie funkcji geom_col wymaga samodzielnego obliczenia wartości:\n\nrossmann_asort2 &lt;- rossmann_asort %&gt;%\n  count(sklep_asort)\n\nglimpse(rossmann_asort2)\n\nRows: 3\nColumns: 2\n$ sklep_asort &lt;chr&gt; \"Extra\", \"Podstawowy\", \"Rozszerzony\"\n$ n           &lt;int&gt; 9, 593, 513\n\n\nWartość do wyświetlenia podajemy w funkcji aes w argumencie y.\n\nggplot(rossmann_asort2, aes(x=sklep_asort, y=n)) +\n  geom_col()\n\n\n\n\n\n\n\n\nUporządkujemy etykiety osi x (obecnie są wyświetlane w kolejności alfabetycznej) tworząc czynnik.\n\nrossmann_asort2 &lt;- rossmann_asort2 %&gt;%\n  mutate(sklep_asort=factor(x = sklep_asort,\n                            levels = c(\"Podstawowy\", \n                                       \"Rozszerzony\", \n                                       \"Extra\"), \n                            ordered = T))\n\nglimpse(rossmann_asort2)\n\nRows: 3\nColumns: 2\n$ sklep_asort &lt;ord&gt; Extra, Podstawowy, Rozszerzony\n$ n           &lt;int&gt; 9, 593, 513\n\n\n\nggplot(rossmann_asort2, aes(x=sklep_asort, y=n)) +\n  geom_col()\n\n\n\n\n\n\n\n\nDo wykresu słupkowego możemy dodać jeszcze jedną zmienną. W tym przypadku będzie to typ sklepu.\n\nrossmann_asort3 &lt;- rossmann %&gt;%\n  select(sklep_id, sklep_asort, sklep_typ) %&gt;%\n  distinct() %&gt;%\n  count(sklep_asort, sklep_typ) %&gt;%\n  mutate(sklep_asort=factor(x = sklep_asort,\n                            levels = c(\"Podstawowy\", \n                                       \"Rozszerzony\", \n                                       \"Extra\"), \n                            ordered = T))\n\nglimpse(rossmann_asort3)\n\nRows: 9\nColumns: 3\n$ sklep_asort &lt;ord&gt; Extra, Podstawowy, Podstawowy, Podstawowy, Podstawowy, Roz…\n$ sklep_typ   &lt;chr&gt; \"b\", \"a\", \"b\", \"c\", \"d\", \"a\", \"b\", \"c\", \"d\"\n$ n           &lt;int&gt; 9, 381, 7, 77, 128, 221, 1, 71, 220\n\n\nUwzględnienie kolejnej zmiennej jest możliwe jako argument fill w funkcji aes.\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col()\n\n\n\n\n\n\n\n\nDomyślnie kategorie są układane jedna na drugą - stack. Można je ułożyć obok siebie dodając argument position = \"dodge\" w funkcji geom_col.\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col(position = \"dodge\")\n\n\n\n\n\n\n\n\nMożemy jeszcze dodać etykiety słupków wykorzystując funkcję geom_text, w której trzeba podać argumenty definujące położenie wartości etykiet. Wartości tych argumentów będą zależały od typu wykresu.\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col(position = \"dodge\") + \n  geom_text(aes(label = n), \n            position = position_dodge(width = 0.9),\n            vjust = -0.3)\n\n\n\n\n\n\n\n\nZmienimy jeszcze nazwę legendy za pomocą funkcji scale_fill_discrete. Wykorzystujemy tę konkretną funkcję ze względu na to, że typ sklepu jest argumentem fill w funkcji aes oraz cechą jakościową (discrete).\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col(position = \"dodge\") + \n  geom_text(aes(label = n), \n            position = position_dodge(width = 0.9),\n            vjust = -0.3) +\n  scale_fill_discrete(name = \"Typ sklepu\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html#wykres-kafelkowy",
    "href": "04-wizualizacja.html#wykres-kafelkowy",
    "title": "4  Wizualizacja danych",
    "section": "4.6 Wykres kafelkowy",
    "text": "4.6 Wykres kafelkowy\nDo wizualizacji tabeli częstości można użyć wykresu kafelkowego. W tym celu najpierw zliczamy wystąpienia wariantów cech czy_promocja oraz czy_swieto_szkolne i wynik przekazujemy bezpośrednio do funkcji ggplot().\n\nsklep77 %&gt;%\n  count(czy_promocja, czy_swieto_szkolne) %&gt;%\n  ggplot(aes(x = czy_promocja, \n             y = czy_swieto_szkolne,\n             fill = n)) +\n  geom_tile()\n\n\n\n\n\n\n\n\nAby dodać do tego wykresu etykiety posłużymy się funkcją geom_label()\n\nsklep77 %&gt;%\n  count(czy_promocja, czy_swieto_szkolne) %&gt;%\n  ggplot(aes(x = czy_promocja, \n             y = czy_swieto_szkolne,\n             fill = n)) +\n  geom_tile() +\n  geom_label(aes(label = n), color = \"white\")\n\n\n\n\n\n\n\n\nZwykle patrząc na wykres podświadomie zakładamy, że ciemniejszy kolor oznacza wyższe wartości, natomiast jasny małe liczby. W tym przypadku układ kolorów jest odwrócony. Musimy odpowiednio dobrać kolory, aby to poprawić. Bardzo przydatne narzędzie znajduje się pod adresem: http://colorbrewer2.org/. Następnie korzystamy z funkcji scale_fill_gradient, w której określamy tylko kolor początkowy i końcowy.\n\nsklep77 %&gt;%\n  count(czy_promocja, czy_swieto_szkolne) %&gt;%\n  ggplot(., aes(x = czy_promocja, \n                y = czy_swieto_szkolne,\n                fill = n)) +\n  geom_tile() +\n  geom_label(aes(label = n), color = \"white\") +\n  scale_fill_gradient(low = \"#66c2a4\", \n                      high = \"#005824\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html#uwzględnienie-czasu",
    "href": "04-wizualizacja.html#uwzględnienie-czasu",
    "title": "4  Wizualizacja danych",
    "section": "4.7 Uwzględnienie czasu",
    "text": "4.7 Uwzględnienie czasu\nPróba stworzenia wykresu przedstawiającego zmianę sprzedaży w czasie za pomocą oryginalnych danych spowoduje uzsykanie niezbyt czytelnej grafiki.\n\nggplot(sklep77, aes(x=data,\n                    y=sprzedaz,\n                    color=dzien_tyg)) +\n  geom_point()\n\n\n\n\n\n\n\n\nWynika to z faktu, że dzien tygodnia jest traktowany jak zmienna numeryczna, a data jest zmienną tekstową. Konwersja tekstu na datę jest możliwa z wykorzystaniem pakietu lubridate. W tym pakiecie każda część daty ma swój akronim, który później jest wykorzystywany w odpowiednich funkcjach:\n\ny - rok (year)\nm - miesiąc (month)\nd - dzień (day)\nh - godzina (hour)\nm - minuta (minute)\n\nPrzykłady funkcji:\n\nymd - konwertuje tekst zapisany w postaci rok-miesiąc-dzień na obiekt daty\ndmy_hm - konwertuje tekst zapisany w postaci dzień-miesiąc-rok godzina:minuta na obiekt daty\nmonth - pobiera z obiektu daty informację o miesiącu\nyear - pobiera z obiektu daty informację o roku\nweek - pobiera z obiektu daty informację o tygodniu roku\n\nWedług powyższych reguł korzystamy z funkcji ymd() do konwersji daty w naszym zbiorze.\n\nlibrary(lubridate)\n\nsklep77a &lt;- sklep77 %&gt;%\n  mutate(dzien_tyg=as.factor(dzien_tyg),\n         data=ymd(data))\n\nggplot(sklep77a, aes(x=data,\n                    y=sprzedaz,\n                    color=dzien_tyg)) +\n  geom_point()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html#facets",
    "href": "04-wizualizacja.html#facets",
    "title": "4  Wizualizacja danych",
    "section": "4.8 Facets",
    "text": "4.8 Facets\n\nsr_sprzedaz &lt;- rossmann %&gt;%\n  filter(sprzedaz &gt; 0) %&gt;%\n  group_by(sklep_id, sklep_asort) %&gt;%\n  summarise(sprzedaz_sr=mean(sprzedaz))\n\n`summarise()` has grouped output by 'sklep_id'. You can override using the\n`.groups` argument.\n\nodleglosc &lt;- rossmann %&gt;%\n  select(sklep_id, sklep_konkurencja) %&gt;%\n  distinct()\n\nsprzedaz_odleglosc &lt;- inner_join(sr_sprzedaz, odleglosc, by=\"sklep_id\")\n\nggplot(sprzedaz_odleglosc, aes(x=sprzedaz_sr, y=sklep_konkurencja)) + \n  geom_point() +\n  facet_wrap(~ sklep_asort)\n\nWarning: Removed 3 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\nsr_sprzedaz_prom &lt;- rossmann %&gt;%\n  filter(sprzedaz &gt; 0) %&gt;%\n  group_by(sklep_id, czy_promocja) %&gt;%\n  summarise(sprzedaz_sr=mean(sprzedaz))\n\n`summarise()` has grouped output by 'sklep_id'. You can override using the\n`.groups` argument.\n\nsprzedaz_prom_odl &lt;- inner_join(sr_sprzedaz_prom, odleglosc)\n\nJoining with `by = join_by(sklep_id)`\n\nhead(sprzedaz_prom_odl)\n\n# A tibble: 6 × 4\n# Groups:   sklep_id [3]\n  sklep_id czy_promocja sprzedaz_sr sklep_konkurencja\n     &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;             &lt;dbl&gt;\n1        1 Nie                4288.              1270\n2        1 Tak                5274.              1270\n3        2 Nie                3902.               570\n4        2 Tak                6295.               570\n5        3 Nie                5286.             14130\n6        3 Tak                8790.             14130\n\nggplot(sprzedaz_prom_odl, aes(x=sprzedaz_sr, y=sklep_konkurencja, color=czy_promocja)) + \n  geom_point()\n\nWarning: Removed 6 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nZamiana reprezentacji danych na szeroką.\n\nsprzedaz_prom_odl_wide &lt;- sprzedaz_prom_odl %&gt;%\n  spread(czy_promocja, sprzedaz_sr)\n\nhead(sprzedaz_prom_odl_wide)\n\n# A tibble: 6 × 4\n# Groups:   sklep_id [6]\n  sklep_id sklep_konkurencja   Nie    Tak\n     &lt;dbl&gt;             &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1        1              1270 4288.  5274.\n2        2               570 3902.  6295.\n3        3             14130 5286.  8790.\n4        4               620 9030. 10686.\n5        5             29910 3473.  6084.\n6        6               310 4189.  6295.\n\n\nI na wąską.\n\nsprzedaz_prom_odl_long &lt;- sprzedaz_prom_odl_wide %&gt;%\n  gather(czy_promocja, sprzedaz_sr, Nie, Tak)\n\nhead(sprzedaz_prom_odl_long)\n\n# A tibble: 6 × 4\n# Groups:   sklep_id [6]\n  sklep_id sklep_konkurencja czy_promocja sprzedaz_sr\n     &lt;dbl&gt;             &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;\n1        1              1270 Nie                4288.\n2        2               570 Nie                3902.\n3        3             14130 Nie                5286.\n4        4               620 Nie                9030.\n5        5             29910 Nie                3473.\n6        6               310 Nie                4189.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html#wykres-interaktywny",
    "href": "04-wizualizacja.html#wykres-interaktywny",
    "title": "4  Wizualizacja danych",
    "section": "4.9 Wykres interaktywny",
    "text": "4.9 Wykres interaktywny\nZa pomocą pakietu plotly w prosty sposób można zamienić statystyczny wykres ggplot na interaktywny.\n\nlibrary(plotly)\n\np &lt;- ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n\nplotly::ggplotly(p)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "04-wizualizacja.html#zadania",
    "href": "04-wizualizacja.html#zadania",
    "title": "4  Wizualizacja danych",
    "section": "4.10 Zadania",
    "text": "4.10 Zadania\nWykonaj polecenia znajdujące się na stronie.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wizualizacja danych</span>"
    ]
  },
  {
    "objectID": "05-programowanie.html",
    "href": "05-programowanie.html",
    "title": "5  Programowanie w R",
    "section": "",
    "text": "5.1 Wprowadzenie\nPrezentacja\nW odróżnieniu od treści prezentowanych w poprzednich rozdziałach, w tym nie będziemy korzystać z zewnętrznych pakietów. Zagadnienia związane z tworzeniem własnych funkcji oraz modyfikacją przepływu sterowania będą od nas wymagały poznania wielu różnych operatorów wbudowanych w bazowe pakiety R.\nW rozdziale skorzystamy ze sztucznie wygenerowanego zbioru danych:\nset.seed(123)\ndane &lt;- data.frame(x1=rnorm(10), x2=rnorm(10), x3=rnorm(10), x4=rnorm(10))\ndane\n\n            x1         x2         x3          x4\n1  -0.56047565  1.2240818 -1.0678237  0.42646422\n2  -0.23017749  0.3598138 -0.2179749 -0.29507148\n3   1.55870831  0.4007715 -1.0260044  0.89512566\n4   0.07050839  0.1106827 -0.7288912  0.87813349\n5   0.12928774 -0.5558411 -0.6250393  0.82158108\n6   1.71506499  1.7869131 -1.6866933  0.68864025\n7   0.46091621  0.4978505  0.8377870  0.55391765\n8  -1.26506123 -1.9666172  0.1533731 -0.06191171\n9  -0.68685285  0.7013559 -1.1381369 -0.30596266\n10 -0.44566197 -0.4727914  1.2538149 -0.38047100",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Programowanie w R</span>"
    ]
  },
  {
    "objectID": "05-programowanie.html#funkcje",
    "href": "05-programowanie.html#funkcje",
    "title": "5  Programowanie w R",
    "section": "5.2 Funkcje",
    "text": "5.2 Funkcje\nFunkcję ograniczają potrzebę kopiowania kodu i ułatwiają wprowadzanie zmian. Zamiast dodawać komentarze do dużej ilości kodu można opakować go w funkcję, co ułatwi zrozumienie programu. Jeśli istnieje potrzeba wprowadzenia zmian to wystarczy zrobić to w jednym miejscu.\nStworzenie funkcji wymaga:\n\nwymyślenia nazwy funkcji,\nokreślenia elementów wejściowych,\numieszczenia kodu w ciele funkcji.\n\nIstnieją pewne dobre praktyki tworzenia funkcji:\n\nnazwy funkcji powinny być czasownikami,\npodkreślnik vs. notacja camelCase i konsekwencja stosowania,\nwspólny przedrostek np. rnorm, runif.\n\nPodstawowa składnia definiowania funkcji w R:\nnazwa_funkcji &lt;- function(argument1, argument2, ...) {\n  # ciało funkcji - zbiór instrukcji\n  \n  # zwracana wartość\n  return(wynik)\n}\nPrzykład prostej funkcji, która oblicza wskaźnik będący stosunkiem średniej do odchylenia standardowego:\noblicz_wskaznik &lt;- function(x) {\n  wskaznik &lt;- mean(x) / sd(x)\n  return(wskaznik)\n}\nW R można definiować funkcje na kilka sposobów, które różnią się składnią, ale działają identycznie:\n\n# Sposób 1 - pełna składnia z nawiasami klamrowymi i return\nnormalize &lt;- function(x) {\n  return((x - min(x)) / (max(x) - min(x)))\n}\n\n# Sposób 2 - bez jawnego return\nnormalize &lt;- function(x) {\n  (x - min(x)) / (max(x) - min(x))\n}\n\n# Sposób 3 - skrócona składnia, bez klamr\nnormalize &lt;- function(x) (x - min(x)) / (max(x) - min(x))\n\n# Sposób 4 - nowoczesna składnia od R 4.1 z operatorem \\()\nnormalize &lt;- \\(x) (x - min(x)) / (max(x) - min(x))\n\nW każdym z powyższych przypadków funkcja robi to samo - normalizuje wartości wektora do przedziału [0, 1].\nFunkcje najlepiej tworzyć, gdy: - Powtarzamy ten sam fragment kodu wielokrotnie - Chcemy uporządkować logicznie kod - Chcemy stworzyć narzędzie wielokrotnego użytku\nPrzykład zastosowania funkcji do normalizacji danych:\n\n# Zastosowanie funkcji normalize dla każdej kolumny\ndane$z1 &lt;- normalize(dane$x1)\ndane$z2 &lt;- normalize(dane$x2)\ndane$z3 &lt;- normalize(dane$x3)\ndane$z4 &lt;- normalize(dane$x4)\n\n# Wizualizacja efektu normalizacji\nplot(dane$x1, dane$z1)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Programowanie w R</span>"
    ]
  },
  {
    "objectID": "05-programowanie.html#instrukcje-warunkowe",
    "href": "05-programowanie.html#instrukcje-warunkowe",
    "title": "5  Programowanie w R",
    "section": "5.3 Instrukcje warunkowe",
    "text": "5.3 Instrukcje warunkowe\nZa pomocą instrukcji if możemy warunkowo wykonywać kod. Ogólna postać jest następująca:\nPodstawowa składnia:\nif (warunek) {\n  # kod wykonywany, gdy warunek jest TRUE\n} else {\n  # kod wykonywany, gdy warunek jest FALSE\n}\nRozszerzona składnia if-else if-else:\nif (warunek1) {\n  # kod wykonywany, gdy warunek1 jest TRUE\n} else if (warunek2) {\n  # kod wykonywany, gdy warunek1 jest FALSE, ale warunek2 jest TRUE\n} else {\n  # kod wykonywany, gdy oba warunki są FALSE\n}\nElement warunek musi zwracać wartość logiczną TRUE albo FALSE. Chcąc uwzględnić więcej niż jeden warunek należy wykorzystać odpowiedni operator łączenia:\n\ni : &&\nlub : ||\n\nPrzykład funkcji sprawdzającej wartość:\nsprawdz_wartosc &lt;- function(wartosc) {\n  # Sprawdzanie poprawności danych\n  if (is.na(wartosc)) {\n    stop(\"Podana wartość to NA\")\n  }\n  if (is.character(wartosc)) {\n    stop(\"Podana wartość to tekst\")\n  }\n  \n  # Sprawdzanie wartości\n  if (wartosc &gt; 0) {\n    print(\"Wartość &gt; 0\")\n  } else if (wartosc &lt; 0) {\n    print(\"Wartość &lt; 0\")\n  } else {\n    print(\"Wartość = 0\")\n  }\n}\nW tym przypadku użyliśmy warunków wewnątrz funkcji dodatkowo używając ich do weryfikacji poprawności argumentów wejściowych.\nTak zdefiniowane warunki pozwalają na warunkowe wykonywanie całych bloków kodu np. jeśli w zbiorze danych znajduje się kolumna wiek to stwórz i zapis wykres, a w przeciwnym wypadku połącz się z zewnętrznym źródłem danych w celu uzupełnienia brakujących informacji.\nW tym miejscu zapoznamy się także z warunkowym przetwarzaniem wartości obiektu z wykorzystaniem funkcji ifelse oraz jej ulepszonym wariantem z pakietu dplyr. Funkcja ifelse() jest wektorową wersją instrukcji warunkowej, działającą element po elemencie:\nifelse(test, yes, no)\ngdzie: - test to wektor wartości logicznych (TRUE/FALSE) - yes to wartości zwracane dla elementów, które spełniają warunek - no to wartości zwracane dla elementów, które nie spełniają warunku\nPrzykład:\n\nwartosc &lt;- 10\nifelse(test = wartosc &gt; 0, yes = \"Wartość &gt; 0\", no = \"Wartość &lt; 0\")\n\n[1] \"Wartość &gt; 0\"\n\n# Zastosowanie dla każdego wiersza w ramce danych\ndane$x1_zero &lt;- ifelse(dane$x1 &gt; 0, \"wartość &gt; 0\", \"wartość &lt; 0\")\n\nMożna zagnieżdżać wywołania ifelse() dla bardziej złożonych warunków:\ndane$z1_zero &lt;- ifelse(dane$z1 &gt; 0, \"wartość &gt; 0\", \n                       ifelse(dane$z1 &lt; 0, \"wartość &lt; 0\", \"wartość = 0\"))\nFunkcja case_when() z pakietu dplyr (część tidyverse) oferuje bardziej czytelną alternatywę dla zagnieżdżonych if-else:\nlibrary(tidyverse)\n\ndane &lt;- dane %&gt;% \n  mutate(z1_zero = case_when(\n    z1 &gt; 0 ~ \"wartość &gt; 0\",\n    z1 &lt; 0 ~ \"wartość &lt; 0\",\n    z1 == 0 ~ \"wartość = 0\"\n  ))\nW funkcji case_when możliwe jest podanie wartości .default w celu określenia co ma się stać z wartościami niepasującymi do żadnego warunku.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Programowanie w R</span>"
    ]
  },
  {
    "objectID": "05-programowanie.html#pętle",
    "href": "05-programowanie.html#pętle",
    "title": "5  Programowanie w R",
    "section": "5.4 Pętle",
    "text": "5.4 Pętle\nPętle pozwalają na wielokrotne wykonanie tego samego kodu dla różnych wartości. W R często można uniknąć używania pętli poprzez operacje wektorowe, ale ich znajomość jest kluczowa.\nPodstawowa składnia pętli for:\nfor (zmienna in sekwencja) {\n  # instrukcje wykonywane dla każdej wartości zmiennej\n}\nIteracja po indeksach - musimy wskazać ile razy pętla ma się wykonać\nfor (month in 1:12) {\n  print(month.name[month])\n}\nZamiast korzystać z ‘magicznych liczb’ można użyć funkcji seq_along(), która generuje sekwencję indeksów o długości danego wektora:\nfor (month in seq_along(month.name)) {\n  print(month.name[month])\n}\nW zależności od potrzeb możemy też przeprowadzić iterację po wektorze wartości\nfor (month in month.name) {\n  print(month)\n}\nPrzykład tworzenia nowego wektora na podstawie istniejącego:\nmonth_upper &lt;- character(length = length(month.name))  # inicjalizacja pustego wektora\n\nfor (month in seq_along(month.name)) {\n  month_upper[month] &lt;- toupper(month.name[month])\n}\n\nmonth_upper  # wektor z nazwami miesięcy dużymi literami\nWarto zauważyć, że w R często można uniknąć pętli, stosując operacje wektorowe:\nmonth_upper &lt;- toupper(month.name)  # to samo co powyższa pętla, ale szybsze i bardziej eleganckie\nPętle są szczególnie przydatne w przypadku symulacji różnych zdarzeń np. rzutów kostką:\n# Podejście z pętlą\nrzut_kostka &lt;- numeric(10000)\n\nfor (rzut in seq_along(rzut_kostka)) {\n  rzut_kostka[rzut] &lt;- sample(1:6, 1)\n}\n\n# Statystyki\nmean(rzut_kostka)\ntable(rzut_kostka)\nChociaż często tutaj także można zastosować podejście wektorowe:\n# Podejście wektorowe - bardziej wydajne\nrzut_kostka_vec &lt;- sample(1:6, 10000, replace = TRUE)\n\nmean(rzut_kostka_vec)\ntable(rzut_kostka_vec)\nChoć R jest zoptymalizowany pod kątem operacji wektorowych, pętle są przydatne gdy:\n\nAlgorytm wymaga dostępu do poprzednich wyników (np. symulacje szeregów czasowych)\nOperacje są zbyt złożone, aby wyrazić je w formie wektorowej\nIterujemy po strukturach danych, które nie są wektorami (np. listy elementów o różnej strukturze)\nPrzeprowadzamy operacje sekwencyjne (np. import wielu plików)\n\nWarto jednak zawsze rozważyć, czy operacja nie może być wykonana bardziej efektywnie za pomocą podejścia wektorowego lub funkcji takich jak apply, lapply, sapply, vapply, czy funkcji z pakietu purrr.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Programowanie w R</span>"
    ]
  },
  {
    "objectID": "05-programowanie.html#zadania",
    "href": "05-programowanie.html#zadania",
    "title": "5  Programowanie w R",
    "section": "5.5 Zadania",
    "text": "5.5 Zadania\n\n5.5.1 Paradoks dnia urodzin\nArtykuł na wikipedii\nIle minimalnie osób należy wybrać, żeby prawdopodobieństwo znalezienia wśród nich co najmniej dwóch osób obchodzących urodziny tego samego dnia było większe od 0,5.\nRozwiązaniem problemu jest liczba 23. Ta zaskakująco mała liczba osób jest przyczyną określenia „Paradoks dnia urodzin”.\nNapisz funkcję, która jako argument będzie przyjmowała liczbę osób (max. 100), dla których ma wylosować datę urodzenia (bez roku). Następnie sprawdź czy któraś data powtarza się w ramach wylosowanych wartości i zapisz wynik (prawda lub fałsz). Powtórz losowanie 100000 razy. Wynikiem jest prawdopodobieństwo wyznaczone poprzez podzielenie liczby przypadków, gdzie data się powtórzyła przez liczbę wszystkich losowań.\n\nparadoks_urodzin(23)\n\nW grupie 23 osób prawdopodobieństwo, że dwie osoby będą miały urodziny tego samego dnia wynosi 50.95%.\n\n\n5.5.2 Poszukiwacz dzielników\nTermin dzielnik liczby oznacza liczbę, która dzieli ją bez reszty.\nNapisz funkcję, która dla podanej liczby będzie zwracała jej dzielniki. Użyj pętli do sprawdzenia czy potencjalny dzielnik faktycznie dzieli się bez reszty.\n\ndzielnik_liczby(26)\n\nDzielniki liczby 26 to: 1, 2, 13, 26.\n\n\n5.5.3 Papier, kamień, nożyce,\nArtykuł na wikipedii\nNapisz funkcję, która jako argument przyjmuje jeden z trzech symboli (kamień/nożyce/papier). Komputer może objąć trzy strategię: losowo wybierać symbol, zawsze wygrywać lub zawsze przegrywać. Możesz użyć funkcji opóźniającej podanie wyniki, aby zwiększyć emocje.\n\npkn(symbol=\"kamień\", tryb=\"losowy\")\n\nkamień vs. nożyce - wygrałeś!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Programowanie w R</span>"
    ]
  },
  {
    "objectID": "06-testy.html",
    "href": "06-testy.html",
    "title": "6  Testy statystyczne",
    "section": "",
    "text": "6.1 Wprowadzenie\nPrezentacja\nDo rozwiązania wybranych zagadnień analizy statystycznej wystarczą metody weryfikacji hipotez statystycznych. Taki proces można przedstawić w następujących krokach:\nWymienione powyżej nowe pojęcia zostaną wyjaśnione poniżej.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#wprowadzenie",
    "href": "06-testy.html#wprowadzenie",
    "title": "6  Testy statystyczne",
    "section": "",
    "text": "Sformułowanie dwóch wykluczających się hipotez - zerowej \\(H_0\\) oraz alternatywnej \\(H_1\\)\nWybór odpowiedniego testu statystycznego\nOkreślenie dopuszczalnego prawdopodobieństwo popełnienia błędu I rodzaju (czyli poziomu istotności \\(\\alpha\\))\nPodjęcie decyzji",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#hipoteza-statystyczna",
    "href": "06-testy.html#hipoteza-statystyczna",
    "title": "6  Testy statystyczne",
    "section": "6.2 Hipoteza statystyczna",
    "text": "6.2 Hipoteza statystyczna\nPrzypuszczenie dotyczące własności analizowanej cechy, np. średnia w populacji jest równa 10, rozkład cechy jest normalny.\nFormułuje się zawsze dwie hipotezy: hipotezę zerową (\\(H_0\\)) i hipotezę alternatywną (\\(H_1\\)). Hipoteza zerowa jest hipotezą mówiącą o równości:\n\\(H_0: \\bar{x}=10\\)\nZ kolei hipoteza alternatywna zakłada coś przeciwnego:\n\\(H_1: \\bar{x}\\neq 10\\)\nZamiast znaku nierówności (\\(\\neq\\)) może się także pojawić znak mniejszości (\\(&lt;\\)) lub większości (\\(&gt;\\)).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#poziom-istotności-i-wartość-p",
    "href": "06-testy.html#poziom-istotności-i-wartość-p",
    "title": "6  Testy statystyczne",
    "section": "6.3 Poziom istotności i wartość p",
    "text": "6.3 Poziom istotności i wartość p\nHipotezy statystyczne weryfikuje się przy określonym poziomie istotności \\(\\alpha\\), który wskazuje maksymalny poziom akceptowalnego błędu (najczęściej \\(\\alpha=0,05\\)).\nWiększość programów statystycznych podaje w wynikach testu wartość p. Jest to najostrzejszy poziom istotności, przy którym możemy odrzucić hipotezę \\(H_0\\). Jest to rozwiązanie bardzo popularne, ale nie pozbawione wad. Dokładny opis potencjalnych zagrożeń można znaleźć w artykule.\nGeneralnie jeśli \\(p &lt; \\alpha\\) - odrzucamy hipotezę zerową.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#testy-statystyczne",
    "href": "06-testy.html#testy-statystyczne",
    "title": "6  Testy statystyczne",
    "section": "6.4 Testy statystyczne",
    "text": "6.4 Testy statystyczne\nW zależności od tego co chcemy weryfikować należy wybrać odpowiedni test. Tabela poniżej przedstawia dosyć wyczerpującą klasyfikację testów pobraną ze strony.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#zbiór-danych",
    "href": "06-testy.html#zbiór-danych",
    "title": "6  Testy statystyczne",
    "section": "6.5 Zbiór danych",
    "text": "6.5 Zbiór danych\nBędziemy działać na zbiorze danych dotyczącym pracowników przedsiębiorstwa. Poniżej znajduje się opis cech znajdujących się w tym zbiorze,\n\nid - kod pracownika\nplec - płeć pracownika (0 - mężczyzna, 1 - kobieta)\ndata_urodz - data urodzenia\nedukacja - wykształcenie (w latach nauki)\nkat_pracownika - grupa pracownicza (1 - specjalista, 2 - menedżer, 3 - konsultant)\nbwynagrodzenie - bieżące wynagrodzenie\npwynagrodzenie - początkowe wynagrodzenie\nstaz - staż pracy (w miesiącach)\ndoswiadczenie - poprzednie zatrudnienie (w miesiącach)\nzwiazki - przynależność do związków zawodowych (0 - nie, 1 - tak)\nwiek - wiek (w latach)\n\n\nlibrary(tidyverse)\nlibrary(readxl)\n\npracownicy &lt;- read_excel(\"data/pracownicy.xlsx\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#test-niezależności",
    "href": "06-testy.html#test-niezależności",
    "title": "6  Testy statystyczne",
    "section": "6.6 Test niezależności",
    "text": "6.6 Test niezależności\nZa pomocą testu niezależności \\(\\chi^2\\) (chi-kwadrat) można sprawdzić czy pomiędzy dwiema cechami jakościowymi występuje zależność. Układ hipotez jest następujący:\n\n\\(H_0:\\) zmienne są niezależne,\n\\(H_1:\\) zmienne nie są niezależne.\n\nW programie R test niezależności można wywołać za pomocą funkcji chisq.test() z pakietu stats. Jako argument tej funkcji należy podać tablicę kontyngencji. W przypadku operowania na danych jednostkowych można ją utworzyć poprzez funkcję table(). Jeżeli wprowadzamy liczebności ręcznie to należy zadbać o to, żeby wprowadzony obiekt był typu matrix.\nPrzykład\nCzy pomiędzy zmienną płeć, a zmienną przynależność do związków zawodowych istnieje zależność?\nW pierwszym kroku określamy hipotezy badawcze:\n\\(H_0\\): pomiędzy płcią a przynależnością do związków nie ma zależności\n\\(H_1\\): pomiędzy płcią a przynależnością do związków jest zależność\noraz przyjmujemy poziom istotności - weźmy standardową wartość \\(\\alpha = 0,05\\).\nW pierwszej kolejności popatrzmy na tabelę krzyżową (kontyngencji) zawierającą liczebności poszczególnych kombinacji wariantów.\n\ntable(pracownicy$plec, pracownicy$zwiazki)\n\n   \n      0   1\n  0 194  64\n  1 176  40\n\n\nWartości w tej tabeli nie wskazują na liczniejszą reprezentację jednej z płci w związkach zawodowych. Zweryfikujemy zatem wskazaną hipotezę zerową z wykorzystaniem testu \\(\\chi^2\\).\n\nchisq.test(table(pracownicy$plec, pracownicy$zwiazki))\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  table(pracownicy$plec, pracownicy$zwiazki)\nX-squared = 2.3592, df = 1, p-value = 0.1245\n\n\nPrzy poziomie istotności \\(\\alpha = 0,05\\), wartości p (0.1245) jest większa od wartości \\(\\alpha\\), zatem nie ma podstaw do odrzucenia hipotezy zerowej. Można stwierdzić, że nie ma zależności pomiędzy zmiennymi płeć i przynależność do związków zawodowych.\nPrzykład\nCzy pomiędzy płcią, a grupami bieżącego wynagrodzenia zdefiniowanymi przez medianę istnieje zależność?\n\\(H_0\\): pomiędzy płcią a grupami wynagrodzenia nie ma zależności\n\\(H_1\\): pomiędzy płcią a grupami wynagrodzenia jest zależność\nW pierwszej kolejności tworzymy nową cechą zamieniając cechę bwynagrodzenie na zmienną jakościową posiadającą dwa warianty: poniżej mediany i powyżej mediany.\n\npracownicy &lt;- pracownicy %&gt;% \n  mutate(bwyn_mediana=cut(x = bwynagrodzenie,\n                          breaks = c(min(bwynagrodzenie),\n                                     median(bwynagrodzenie),\n                                     max(bwynagrodzenie)),\n                          include.lowest = TRUE))\n\ntable(pracownicy$plec, pracownicy$bwyn_mediana)\n\n   \n    [1.58e+04,2.89e+04] (2.89e+04,1.35e+05]\n  0                  73                 185\n  1                 164                  52\n\n\nW tym przypadku wygląd tablicy krzyżowej może sugerować występowanie zależności.\n\nchisq.test(table(pracownicy$plec, pracownicy$bwyn_mediana))\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  table(pracownicy$plec, pracownicy$bwyn_mediana)\nX-squared = 104.8, df = 1, p-value &lt; 2.2e-16\n\n\nTest \\(\\chi^2\\) to potwierdza - mamy podstawy do odrzucenia hipotezy zerowej na korzyść hipotezy alternatywnej - istnieje zależność pomiędzy płcią, a grupami wynagrodzenia.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#test-proporcji",
    "href": "06-testy.html#test-proporcji",
    "title": "6  Testy statystyczne",
    "section": "6.7 Test proporcji",
    "text": "6.7 Test proporcji\nTest proporcji pozwala odpowiedzieć na pytanie czy odsetki w jednej, dwóch lub więcej grupach różnią się od siebie istotnie. Dla jednej próby układ hipotez został przedstawiony poniżej:\n\n\\(H_0: p=p_0\\)\n\\(H_1: p \\neq p_0\\) lub \\(H_1: p &gt; p_0\\) lub \\(H_1: p &lt; p_0\\)\n\nUkład hipotez w przypadku dwóch prób jest następujący:\n\n\\(H_0: p_1=p_2\\)\n\\(H_1: p_1 \\neq p_2\\) lub \\(H_1: p_1 &gt; p_2\\) lub \\(H_1: p_1 &lt; p_2\\)\n\nDla \\(k\\) badanych prób hipotezę zerową i alternatywną można zapisać w następująco:\n\n\\(H_0: p_1=p_2=p3=...=p_k\\)\n\\(H_1: \\exists \\; p_i \\neq p_j\\)\n\nW takim przypadku hipoteza alternatywna oznacza, że co najmniej jeden odsetek różni się istotnie od pozostałych.\nFunkcja prop.test z pakietu stats umożliwia przeprowadzanie testu proporcji w programie R. Jako argumenty należy podać wektor, który zawiera licznik badanych odsetków - x, oraz wektor zawierający wartości mianownika - n. W przypadku jednej próby należy jeszcze dodać argument p, którego wartość oznacza weryfikowany odsetek.\nPrzykład\nWysunięto przypuszczenie, że palacze papierosów stanowią jednakowy odsetek wśród mężczyzn i kobiet. W celu sprawdzenia tej hipotezy wylosowano 500 mężczyzn i 600 kobiet. Okazało się, że wśród mężczyzn było 200 palaczy, a wśród kobiet 250.\n\\(H_0\\): odsetek palaczy wg płci jest taki sam\n\\(H_1\\): odsetek palaczy różni się wg płci\n\nprop.test(x = c(200,250), n = c(500,600))\n\n\n    2-sample test for equality of proportions with continuity correction\n\ndata:  c(200, 250) out of c(500, 600)\nX-squared = 0.24824, df = 1, p-value = 0.6183\nalternative hypothesis: two.sided\n95 percent confidence interval:\n -0.07680992  0.04347659\nsample estimates:\n   prop 1    prop 2 \n0.4000000 0.4166667 \n\n\nPrzy poziomie istotności 0,05 nie ma podstaw do odrzucenia H0 - odsetek palaczy jest taki sam w grupach płci.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#testowanie-normalności---test-shapiro-wilka",
    "href": "06-testy.html#testowanie-normalności---test-shapiro-wilka",
    "title": "6  Testy statystyczne",
    "section": "6.8 Testowanie normalności - test Shapiro-Wilka",
    "text": "6.8 Testowanie normalności - test Shapiro-Wilka\nTesty parametryczne z reguły wymagają spełnienia założenia o normalności rozkładu. W celu weryfikacji tego założenia należy wykorzystać jeden z testów normalności.\nW celu formalnego zweryfikowania rozkładu cechy można wykorzystać test Shapiro-Wilka. Układ hipotez z tym teście jest następujący:\n\n\\(H_0: F(x) = F_0(x)\\) - rozkład cechy ma rozkład normalny\n\\(H_1: F(x) \\neq F_0(x)\\) - rozkład cechy nie ma rozkładu normalnego\n\nW przeprowadzonych dotychczas symulacjach wykazano, że test Shapiro-Wilka ma największą moc spośród testów normalności, niemniej jego ograniczeniem jest maksymalna liczba obserwacji, która wynosi 50001.\nW programie R test Shapiro-Wilka można uruchomić za pomocą funkcji shapiro.test() jako argument podając wektor wartości liczbowych, który chcemy zweryfikować.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#testowanie-normalności---wykres-kwantyl-kwantyl",
    "href": "06-testy.html#testowanie-normalności---wykres-kwantyl-kwantyl",
    "title": "6  Testy statystyczne",
    "section": "6.9 Testowanie normalności - wykres kwantyl-kwantyl",
    "text": "6.9 Testowanie normalności - wykres kwantyl-kwantyl\nNormalność rozkładu może także zostać zweryfikowana poprzez utworzenie wykresu przedstawiającego porównanie wartości oryginalnych oraz odpowiadającym im wartości pochodzących z rozkładu normalnego. Dodatkowo prowadzona jest linia regresji pomiędzy otrzymanymi wartościami. Punkty przebiegające w pobliżu tej linii oznaczają, że rozkład tej cechy jest normalny.\nNa wykresie przedstawiony jest wykres kwantyl-kwantyl dla 50 wartości wylosowanych z rozkładu normalnego i z rozkładu jednostajnego.\n\n\n\n\n\n\n\n\n\nJak można zauważyć punkty na wykresie po lewej stronie nie odbiegają znacząco od linii prostej, zatem można przypuszczać, że rozkład tej cechy jest normalny. Z kolei na wykresie po prawej stronie obserwuje się odstępstwo od rozkładu normalnego - wartości na krańcach linii są od niej oddalone.\nPrzykład\nCzy cecha doświadczenie ma rozkład normalny? Sprawdź za pomocą odpowiedniego testu oraz wykresu kwantyl-kwantyl.\n\\(H_0\\): doświadczenie ma rozkład normalny\n\\(H_1\\): doświadczenie nie ma rozkładu normalnego\n\nshapiro.test(pracownicy$doswiadczenie)\n\n\n    Shapiro-Wilk normality test\n\ndata:  pracownicy$doswiadczenie\nW = 0.8136, p-value &lt; 2.2e-16\n\n\nNa poziomie \\(\\alpha = 0,05\\) Odrzucamy \\(H_0\\) (p &lt; \\(\\alpha\\)) - doświadczenie nie ma rozkładu normalnego. Sprawdźmy jeszcze jak te wartości wyglądają na wykresie kwantyl-kwantyl.\n\nggplot(pracownicy, aes(sample = doswiadczenie)) +\n  stat_qq() +\n  stat_qq_line()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#testowanie-wariancji---test-bartletta",
    "href": "06-testy.html#testowanie-wariancji---test-bartletta",
    "title": "6  Testy statystyczne",
    "section": "6.10 Testowanie wariancji - test Bartletta",
    "text": "6.10 Testowanie wariancji - test Bartletta\nOprócz założenia o normalności, niektóre metody statystyczne wymagają także równości wariancji.\nJeśli chcemy sprawdzić homogeniczność wariancji w dwóch lub więcej grupach to należy skorzystać z testu Bartletta:\n\n\\(H_0: s^2_1=s^2_2= s^2_3 =...=s^2_k\\)\n\\(H_1: \\exists_{i,j\\in\\{1,..,k\\}} \\; s^2_i \\neq s^2_j\\)\n\nFunkcja bartlett.test() w programie R umożliwia zastosowanie tego testu. Argumenty do tej funkcji można przekazać na dwa sposoby. Pierwszy polega na przypisaniu do argumentu x wektora zawierającego wartości cechy, a do argumentu g wektora zawierającego identyfikatory poszczególnych grup. Drugi sposób to zadeklarowanie formuły w postaci zmienna_analizowa ~ zmienna_grupująca oraz podanie zbioru danych przypisanego do argumentu data.\nPrzykład\nSprawdźmy czy wariancje zmiennej doświadczenie w grupach płci są takie same.\n\\(H_0\\): wariancje doświadczenia są takie same w grupach płci\n\\(H_1\\): wariancje doświadczenia nie są takie same w grupach płci\nFunkcję weryfikującą \\(H_0\\) można zapisać na dwa sposoby - wynik zawsze będzie taki sam.\n\nbartlett.test(x = pracownicy$doswiadczenie, g = pracownicy$plec)\n\n\n    Bartlett test of homogeneity of variances\n\ndata:  pracownicy$doswiadczenie and pracownicy$plec\nBartlett's K-squared = 4.7659, df = 1, p-value = 0.02903\n\n\n\nbartlett.test(pracownicy$doswiadczenie ~ pracownicy$plec)\n\n\n    Bartlett test of homogeneity of variances\n\ndata:  pracownicy$doswiadczenie by pracownicy$plec\nBartlett's K-squared = 4.7659, df = 1, p-value = 0.02903\n\n\nPrzyjmując poziom istotności \\(\\alpha = 0,05\\) odrzucamy hipotezę zerową stwierdzając, że wariancje różnią się w grupach płci. Z kolei dopuszczając niższy poziom istotności \\(\\alpha = 0,01\\) podjęlibyśmy decyzję o braku podstaw do odrzucenia \\(H_0\\) i nieistotnej różnicy pomiędzy grupami.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#testowanie-średnich",
    "href": "06-testy.html#testowanie-średnich",
    "title": "6  Testy statystyczne",
    "section": "6.11 Testowanie średnich",
    "text": "6.11 Testowanie średnich\nW przypadku testowania wartości przeciętnych należy wprowadzić pojęcie prób zależnych i niezależnych:\n\npróby zależne (paired) - analizowane są te same jednostki, ale różne cechy.\npróby niezależne (unpaired) - analizowane są różne jednostki, ale ta sama cecha.\n\nW zależności od tego czy spełnione są odpowiednie założenia dotyczące normalności cechy oraz równości wariancji należy wybrać odpowiedni test według poniższego diagramu.\n\n\n6.11.1 Test t-średnich\nWeryfikacja równości średnich może odbywać się na zasadzie porównania wartości średniej w jednej grupie z arbitralnie przyjętym poziomem lub w dwóch różnych grupach. W pierwszym przypadku rozważamy układ hipotez:\n\n\\(H_0: m = m_0\\)\n\\(H_1: m \\neq m_0\\) lub \\(H_1: m &lt; m_0\\) lub \\(H_1: m &gt; m_0\\)\n\nnatomiast w drugim przypadku hipotezy będą wyglądać następująco:\n\n\\(H_0: m_1 = m_2\\)\n\\(H_1: m_1 \\neq m_2\\) lub \\(H_1: m_1 &lt; m_2\\) lub \\(H_1: m_1 &gt; m_2\\)\n\nAlternatywnie hipotezę zerową można zapisać jako \\(m_1 - m_2 = 0\\) czyli sprawdzamy czy różnica pomiędzy grupami istotnie różni się od zera.\nW funkcji t.test() z pakietu stats w przypadku jednej próby należy podać argument x czyli wektor z wartościami, które są analizowane oraz wartość, z którą tą średnią porównujemy (argument mu, który domyślnie jest równy 0). Dodatkowo w argumencie alternative wskazujemy jaką hipotezę alternatywną bierzemy pod uwagę.\nDla weryfikacji równości średniej w dwóch próbach należy dodać argument y z wartościami w drugiej próbie. W tym przypadku mamy także możliwość określenia czy próby są zależne (argument paired) lub czy wariancja w obu próbach jest taka sama (var.equal). Jeżeli wariancje są różne to program R przeprowadzi test t Welcha i liczba stopni swobody nie będzie liczbą całkowitą.\n\n\n6.11.2 ANOVA\nW przypadku większej liczby grup stosuje się jednoczynnikową analizę wariancji (ANOVA). Ta analiza wymaga spełnienia założenia o normalności rozkładu i równości wariancji w badanych grupach. Układ hipotez jest następujący:\n\n\\(H_0: m_1 = m_2 = m_3 = ... = m_k\\)\n\\(H_1: \\exists_{i,j\\in\\{1,..,k\\}} \\; m_i \\neq m_j\\)\n\nZa pomocą funkcji aov() można w R przeprowadzić jednoczynnikową analizę wariancji. Jako argument funkcji należy podać formułę przedstawiającą zależność zmiennej badanej do zmiennej grupującej wykorzystując w tym celu symbol tyldy (~) w następującym kontekście: zmienna_analizowana ~ zmienna_grupująca. Przy takim zapisie należy także w argumencie data podać nazwę zbioru danych.\nW porównaniu do wcześniej opisanych funkcji, aov() nie zwraca w bezpośrednim wyniku wartości p. Aby uzyskać tę wartość należy wynik działania tej funkcji przypisać do obiektu, a następnie na nim wywołać funkcję summary().\nW przypadku odrzucenia hipotezy zerowej można przeprowadzić test Tukeya w celu identyfikacji różniących się par wykorzystując funkcję TukeyHSD() i jako argument podając obiekt zawierający wynik ANOVA.\nW sytuacji, w której założenia użycia testu parametrycznego nie są spełnione, należy skorzystać z testów nieparametrycznych. W przypadku testowania miar tendencji centralnej różnica pomiędzy testami parametrycznymi a nieparametrycznymi polega na zastąpieniu wartości średniej medianą. Z punktu widzenia obliczeń w miejsce oryginalnych wartości cechy wprowadza się rangi czyli następuje osłabienie skali pomiarowej - z ilorazowej na porządkową.\n\n\n6.11.3 Test Wilcoxona\nTest Wilcoxona jest nieparametryczną wersją testu t. Hipotezy w tym teście dotyczą równości rozkładów:\n\n\\(H_0: F_1=F_2\\)\n\\(H_1: F_1 \\neq F_2\\)\n\nWartość statystyki testowej będzie zależna od typu testu, natomiast w R funkcja, której należy użyć to wilcox.test(). Argumenty tej funkcji są takie same jak w przypadku testu t.\n\n\n6.11.4 Test Kruskala-Wallisa\nZ kolei test Kruskala-Wallisa jest nieparametrycznym odpowiednikiem ANOVA. Hipotezy są następujące:\n\n\\(H_0: F_1=F_2=F_3=...=F_k\\)\n\\(H_1: \\exists_{i,j\\in\\{1,..,k\\}} \\; F_i \\neq F_j\\)\n\nW programie R korzysta się z funkcji kruskal.test(), która przyjmuje takie same argumenty jak funkcja do metody ANOVA aov(). Główną różnicą jest sposób podawania wyniku testu, ponieważ w tym przypadku od razu otrzymujemy wartość p. W przypadku odrzucenia hipotezy zerowej należy sprawdzić, które grupy różnią się między sobą. Można to zrobić za pomocą funkcji pairwise.wilcox.test().\nPrzykład\nSprawdzimy czy średnie doświadczenie w grupach płci jest takie same.\n\\(H_0\\): średnie doświadczenie w grupach płci jest takie samo\n\\(H_1\\): średnie doświadczenie w grupach płci nie jest takie samo\nW związku z tym, że badana cecha nie ma rozkładu normalnego zostanie przeprowadzony test Wilcoxona. Mamy tutaj do czynienia z testem dla prób niezależnych - badana jest jedna cecha (doświadczenie) w ramach rozłącznych grup płci.\n\nwilcox.test(pracownicy$doswiadczenie ~ pracownicy$plec)\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  pracownicy$doswiadczenie by pracownicy$plec\nW = 36295, p-value = 1.372e-08\nalternative hypothesis: true location shift is not equal to 0\n\n\nPrzyjmując poziom istotności \\(\\alpha = 0,05\\) odrzucamy \\(H_0\\) - średnie doświadczenie nie jest takie samo.\nPrzykład\nCzy początkowe i bieżące wynagrodzenie różni się od siebie w sposób istotny?\n\\(H_0\\): średnie początkowe i bieżące wynagrodzenie jest takie samo\n\\(H_1\\): średnie początkowe i bieżące wynagrodzenie nie jest takie samo\nW pierwszej kolejności weryfikujemy normalność rozkładu analizowanych cech.\n\nshapiro.test(pracownicy$pwynagrodzenie)\n\n\n    Shapiro-Wilk normality test\n\ndata:  pracownicy$pwynagrodzenie\nW = 0.71535, p-value &lt; 2.2e-16\n\nshapiro.test(pracownicy$bwynagrodzenie)\n\n\n    Shapiro-Wilk normality test\n\ndata:  pracownicy$bwynagrodzenie\nW = 0.77061, p-value &lt; 2.2e-16\n\n\nWynagrodzenie w tym zbiorze danych zdecydowanie nie przypomina rozkładu normalnego. W tym przypadku analizujemy próby zależne - badamy dwie różne cechy dla tych samych jednostek (obserwacji).\n\nwilcox.test(x = pracownicy$pwynagrodzenie, \n            y = pracownicy$bwynagrodzenie,\n            paired = TRUE)\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  pracownicy$pwynagrodzenie and pracownicy$bwynagrodzenie\nV = 0, p-value &lt; 2.2e-16\nalternative hypothesis: true location shift is not equal to 0\n\n\nNa podstawie podanej wartości p odrzucamy \\(H_0\\) - średnie początkowe i bieżące wynagrodzenie różni się od siebie istotnie statystycznie.\nPrzykład\nAnalogicznie można także sprawdzić czy np. doświadczenie różni się w ramach więcej niż dwóch grup - w takim przypadku rozpatrujemy głównie próby niezależne.\n\\(H_0\\): średnie doświadczenie w grupach kategorii pracownika jest takie same\n\\(H_1\\): średnie doświadczenie w grupach kategorii pracownika nie jest takie same - co najmniej jedna para jest różna\n\nkruskal.test(pracownicy$doswiadczenie ~ pracownicy$kat_pracownika)\n\n\n    Kruskal-Wallis rank sum test\n\ndata:  pracownicy$doswiadczenie by pracownicy$kat_pracownika\nKruskal-Wallis chi-squared = 57.466, df = 2, p-value = 3.322e-13\n\n\nPrzyjmując poziom istotności \\(\\alpha = 0,05\\) odrzucamy hipotezę zerową - co najmniej jedna para kategorii pracownika różni się pod względem średniego wynagrodzenia.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  },
  {
    "objectID": "06-testy.html#footnotes",
    "href": "06-testy.html#footnotes",
    "title": "6  Testy statystyczne",
    "section": "",
    "text": "W przypadku liczniejszych prób można wykorzystać test Kołmogorowa-Smirnova.↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testy statystyczne</span>"
    ]
  }
]