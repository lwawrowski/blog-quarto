[
  {
    "objectID": "03-przetwarzanie.html#wprowadzenie---pakiet-tidyverse",
    "href": "03-przetwarzanie.html#wprowadzenie---pakiet-tidyverse",
    "title": "3  Przetwarzanie danych",
    "section": "3.1 Wprowadzenie - pakiet tidyverse",
    "text": "3.1 Wprowadzenie - pakiet tidyverse\nPakiet tidyverse to zestaw pakietów do kompleksowego przetwarzania i wizualizacji danych. Ładuje następujące pakiety:\n\nggplot2 - tworzenie wykresów,\ndplyr - przetwarzanie danych,\ntidyr - zmiana reprezentacji danych,\nreadr - wczytywanie danych tekstowych,\npurrr - programowanie funkcyjne\ntibble - sposób przechowywania danych,\nstringr - przetwarzanie tekstów,\nforcats - przetwarzanie faktorów\nlubridate - operacje na datach\n\nManifest tidyverse ustala następujące zasady:\n\npowtórne użycie istniejących struktur danych,\ntworzenie czytelnych kodów z operatorem pipe %&gt;% (ang. rura, przewód, łącznik).\n\nWobec tego załadujmy pakiet tidyverse:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nW konsoli pojawi się informacja o wersji załadowanych pakietów oraz o konfliktach występujących pomiędzy pakietami. Konflikty te wynikają z takich samych nazw funkcji w różnych pakietach. Kolejność wczytywania pakietów ma znaczenie - kolejny pakiet przykryje funkcje z wcześniej wczytanego. Wywołanie przykrytej funkcji jest możliwe poprzez zapis nazwa_pakietu::nazwa_funkcji.\nKorzystanie z pakietu i zasad tidyverse to dużo bardziej czytelny kod w porównaniu do wbudowanych funkcji. Poniżej przedstawiony jest przykład przetwarzania danych polegający na filtrowaniu, wyborze kolumn oraz utworzeniu nowej zmiennej.\n\ndata(\"ChickWeight\")\n\n# bez pakietu tidyverse\n\nchick_15 &lt;- ChickWeight[ChickWeight$Chick==\"15\",]\nchick_15 &lt;- chick_15[c(\"weight\", \"Time\", \"Diet\"),]\nchick_15$weight_kg &lt;- chick_15$weight/1000\n\n# z pakietem tidyverse\n\nchick_15 &lt;- ChickWeight %&gt;%\n  filter(Chick==\"15\") %&gt;%\n  select(-Chick) %&gt;%\n  mutate(weight_kg=weight/1000)\n\nRozwiązanie z wykorzystaniem wbudowanych funkcji to 133 znaki, natomiast wykorzystanie tidyverse to 30% oszczędność miejsca i tylko 92 znaki."
  },
  {
    "objectID": "03-przetwarzanie.html#import-danych",
    "href": "03-przetwarzanie.html#import-danych",
    "title": "3  Przetwarzanie danych",
    "section": "3.2 Import danych",
    "text": "3.2 Import danych\nWczytywanie danych do R jest możliwe z wielu różnych źródeł. Funkcje, które to umożliwiają zwykle mają nazwę rozpoczynającą się od read.\nBędziemy korzystać z następujących zbiorów danych:\n\nmovies - plik tekstowy zawierający informacje o filmach,\nbank - plik excel zawierający dane dot. kampanii marketingowej banku, opis zmiennych,\nrossmann - plik excel zawierający dane ze sklepów Rossmann,\nlotto - plik tekstowy zawierający dane z losowań Lotto.\n\n\n3.2.1 Pliki CSV\nDo wczytywania plików csv można wykorzystać wbudowaną funkcję read.csv() lub tą pochodzącą z pakietu readr - read_csv(). W obu przypadkach wynik wczytania będzie podobny.\n\nmovies &lt;- read.csv(\"data/movies.csv\")\n\nmovies2 &lt;- read_csv(\"data/movies.csv\")\n\nRows: 2961 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): title, genre, director\ndbl (8): year, duration, gross, budget, cast_facebook_likes, votes, reviews,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nJeśli nas plik ma nietypową strukturę to w funkcji read.csv() możemy określić dodatkowe argumenty informując o nazwach kolumn obecnych w pliku (header =), separatorze kolumn (sep =) lub separatorze miejsc dziesiętnych (dec =)\n\nmovies &lt;- read.csv(file = \"data/movies.csv\", header = T, sep=\",\", dec=\".\")\n\n\n\n3.2.2 Pliki excel\nDo wczytywania plików z Excela niezbędny jest dodatkowy pakiet readxl. W funkcji read_xlsx() podajemy jako argument nazwę pliku. Możemy także dodać nazwę lub numer arkusza w argumencie (sheet =) oraz zakres komórek jako wartość argumentu range =.\n\nlibrary(readxl)\n\nbank &lt;- read_xlsx(\"data/bank.xlsx\")\n\n# bank &lt;- read_xlsx(\"data/bank.xlsx\", sheet = \"dane\")\n# bank &lt;- read_xlsx(\"data/bank.xlsx\", sheet = 1)\n\nbank_a1i30 &lt;- read_xlsx(\"data/bank.xlsx\", range = \"A1:I30\")\n\nrossmann &lt;- read_xlsx(\"data/rossmann.xlsx\")\n\n\n\n3.2.3 Pliki tekstowe\nZ kolei do wczytywania plików tekstowych wykorzystuje się funkcję read.table(). Wczytywany plik nie musi być zlokalizowany na dysku twardym - może to być link internetowy.\n\nlotto &lt;- read.table(\"http://www.mbnet.com.pl/dl.txt\")\nnames(lotto) &lt;- c(\"lp\", \"data\", \"numery\")"
  },
  {
    "objectID": "03-przetwarzanie.html#filtrowanie",
    "href": "03-przetwarzanie.html#filtrowanie",
    "title": "3  Przetwarzanie danych",
    "section": "3.3 Filtrowanie",
    "text": "3.3 Filtrowanie\nDo przetwarzania danych służą funkcje z pakietu dplyr. Większość z nich jako pierwszy argument przyjmuje przetwarzany zbiór danych, ale można tego uniknąć wykorzystując symbole %&gt;%.\nFiltrowanie polega na wybraniu obserwacji, które spełniają określony warunek lub warunki. Ze zbioru movies wybierzmy wszystkie komedie:\n\nkomedie &lt;- filter(movies, genre==\"Comedy\")\n\nlub alternatywnie:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\")\n\nPo zmiennej, która jest filtrowana musimy podać operator porównania czyli podwójny znak równości ==. Jeśli chcemy filtrować po większej liczbie zmiennych to kolejne warunki dodajemy po przecinku:\n\nkomedie_2012 &lt;- movies %&gt;%\n  filter(genre==\"Comedy\", year==2012)\n\nWówczas oba warunki muszą zostać spełnione czyli pomiędzy nimi zachodzi relacja i. Równoważny zapis jest następujący:\n\nkomedie_2012 &lt;- movies %&gt;%\n  filter(genre==\"Comedy\" & year==2012)\n\nPomiędzy warunkami może także zachodzić relacja lub. Wybieramy filmy, które są komediami lub miały swoją premierę w 2012 roku.\n\nkomedie_l_2012 &lt;- movies %&gt;%\n  filter(genre==\"Comedy\" | year==2012)\n\nMożliwy jest także wybór wielu kryteriów filtrowania poprzez operator %in%:\n\nkomedie_familijne &lt;- movies %&gt;%\n  filter(genre %in% c(\"Comedy\", \"Family\"))\n\nmovies_2000_2010 &lt;- movies %&gt;%\n  filter(year %in% 2000:2010)"
  },
  {
    "objectID": "03-przetwarzanie.html#wybieranie-kolumn",
    "href": "03-przetwarzanie.html#wybieranie-kolumn",
    "title": "3  Przetwarzanie danych",
    "section": "3.4 Wybieranie kolumn",
    "text": "3.4 Wybieranie kolumn\nDo wyboru kolumn służy funkcja select(). Zmodyfikujemy wcześniej utworzony zbiór komedie:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(title, year, duration, budget, rating)\n\nTen sam kod możemy zapisać zagnieżdżając funkcje, ale traci on w ten sposób na czytelności:\n\nkomedie &lt;- select(filter(movies, genre==\"Comedy\"), title, year, duration, budget, rating)\n\nMożemy także wskazać, które zmienne nie mają znaleźć się w zbiorze wynikowym:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre)\n\nNatomiast jeśli zmiennych jest więcej to musimy jest umieścić w wektorze, żeby nie pisać przed każdą zmienną znaku minus:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre, -director, -gross, -budget)\n\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-c(genre, director, gross, budget))\n\nZ wykorzystaniem znaku dwukropka możemy także wskazywać zakresy zmiennych:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre, -c(gross:reviews))"
  },
  {
    "objectID": "03-przetwarzanie.html#tworzenie-nowych-zmiennych",
    "href": "03-przetwarzanie.html#tworzenie-nowych-zmiennych",
    "title": "3  Przetwarzanie danych",
    "section": "3.5 Tworzenie nowych zmiennych",
    "text": "3.5 Tworzenie nowych zmiennych\nDo utworzenia nowej zmiennej wykorzystuje się funkcję mutate(). Utwórzmy w naszym zbiorze nową zmienną, która będzie zawierała czas trwania filmu w godzinach:\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre, -c(gross:reviews)) %&gt;%\n  mutate(dur_hour = duration/60)\n\nRozsądnie będzie zaokrąglić otrzymaną wartość do jednego miejsca po przecinku - służy do tego funkcja round():\n\nkomedie &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre, -c(gross:reviews)) %&gt;%\n  mutate(dur_hour = round(duration/60,1))\n\nZ kolei funkcja transmute() tworzy zbiór w którym jest tylko nowo utworzona kolumna:\n\nkomedie_t &lt;- movies %&gt;%\n  filter(genre==\"Comedy\") %&gt;%\n  select(-genre, -c(gross:reviews)) %&gt;%\n  transmute(dur_hour = round(duration/60,1))"
  },
  {
    "objectID": "03-przetwarzanie.html#zmiana-nazwy-zmiennej",
    "href": "03-przetwarzanie.html#zmiana-nazwy-zmiennej",
    "title": "3  Przetwarzanie danych",
    "section": "3.6 Zmiana nazwy zmiennej",
    "text": "3.6 Zmiana nazwy zmiennej\nDo zmiany nazw zmiennych służy funkcja rename(). Najpierw podajemy nazwę nowej zmiennej, a po znaku równości starą nazwę:\n\nbank &lt;- bank %&gt;%\n  rename(karta=kredyt)\n\nZmiany nazwy można także dokonać z wykorzystaniem funkcji select:\n\nbank_nowy &lt;- bank %&gt;%\n  select(lokata=wynik)\n\nW takim przypadku trzeba jednak pamiętać o wypisaniu wszystkich zmiennych, które mają się znaleźć w zbiorze wynikowym."
  },
  {
    "objectID": "03-przetwarzanie.html#podsumowanie-danych",
    "href": "03-przetwarzanie.html#podsumowanie-danych",
    "title": "3  Przetwarzanie danych",
    "section": "3.7 Podsumowanie danych",
    "text": "3.7 Podsumowanie danych\nFunkcja summarise() służy do podsumowań danych w formie zagregowanej:\n\nbank %&gt;%\n  summarise(saldo_srednia=mean(saldo),\n            saldo_mediana=median(saldo))\n\n# A tibble: 1 × 2\n  saldo_srednia saldo_mediana\n          &lt;dbl&gt;         &lt;dbl&gt;\n1         1362.           448\n\n\nPodsumowanie danych ma najwięcej sensu w połączniu z funkcją grupującą."
  },
  {
    "objectID": "03-przetwarzanie.html#grupowanie",
    "href": "03-przetwarzanie.html#grupowanie",
    "title": "3  Przetwarzanie danych",
    "section": "3.8 Grupowanie",
    "text": "3.8 Grupowanie\nDo grupowania obserwacji służy funkcja group_by(). Zobaczmy jak wyglądają statystyki salda w poszczególnych grupach wykształcenia:\n\nbank %&gt;%\n  group_by(wykszt) %&gt;%\n  summarise(saldo_srednia=mean(saldo),\n            saldo_mediana=median(saldo))\n\n# A tibble: 4 × 3\n  wykszt     saldo_srednia saldo_mediana\n  &lt;chr&gt;              &lt;dbl&gt;         &lt;dbl&gt;\n1 podstawowe         1251.           403\n2 srednie            1155.           392\n3 wyzsze             1758.           577\n4 &lt;NA&gt;               1527.           568\n\n\nPo przecinku w funkcji group_by() można wskazać kolejne zmienne grupujące:\n\nbank %&gt;%\n  group_by(wykszt, hipoteka) %&gt;%\n  summarise(saldo_srednia=mean(saldo),\n            saldo_mediana=median(saldo))\n\n`summarise()` has grouped output by 'wykszt'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 8 × 4\n# Groups:   wykszt [4]\n  wykszt     hipoteka saldo_srednia saldo_mediana\n  &lt;chr&gt;      &lt;chr&gt;            &lt;dbl&gt;         &lt;dbl&gt;\n1 podstawowe nie              1571.          521 \n2 podstawowe tak              1008.          344.\n3 srednie    nie              1340.          416.\n4 srednie    tak              1034.          380 \n5 wyzsze     nie              1919.          618 \n6 wyzsze     tak              1584.          543 \n7 &lt;NA&gt;       nie              1780.          679 \n8 &lt;NA&gt;       tak              1207.          442 \n\n\nPrzydatna jest także funkcja n(), która nie przyjmuje żadnego argumentu i zwraca liczebność zbioru bądź grupy.\n\nbank %&gt;%\n  group_by(wykszt) %&gt;%\n  summarise(liczebnosc=n(),\n            saldo_srednia=mean(saldo),\n            saldo_mediana=median(saldo))\n\n# A tibble: 4 × 4\n  wykszt     liczebnosc saldo_srednia saldo_mediana\n  &lt;chr&gt;           &lt;int&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 podstawowe       6851         1251.           403\n2 srednie         23202         1155.           392\n3 wyzsze          13301         1758.           577\n4 &lt;NA&gt;             1857         1527.           568\n\n\nJeżeli chcemy tylko wyznaczyć liczebności grup to możemy skorzystać z funkcji count():\n\nbank %&gt;%\n  group_by(wykszt) %&gt;%\n  count()\n\n# A tibble: 4 × 2\n# Groups:   wykszt [4]\n  wykszt         n\n  &lt;chr&gt;      &lt;int&gt;\n1 podstawowe  6851\n2 srednie    23202\n3 wyzsze     13301\n4 &lt;NA&gt;        1857\n\n\nJedną z kategorii zmiennej wykształcenie jest brak danych (NA). Zamienimy tą wartość na kategorię nieustalone z wykorzystaniem funkcji mutate() oraz if_else(). Funkcja if_else() przyjmuje trzy argumenty - pierwszy (condition =) to warunek, który jest weryfikowany, następnie podajemy wartość, która ma być wprowadzona w przypadku spełnienia warunku (true =), a na końcu wartość dla niespełnionego warunku (false =). Jest to odpowiednik funkcji JEŻELI z Excela.\nW omawianym przykładzie warunkiem jest sprawdzenie czy wartości zmiennej wykszt są równe NA. Jeśli tak to na ich miejsce wprowadzany jest tekst nieustalone, a w przeciwnym przypadku pozostaje oryginalna wartość.\n\nbank %&gt;%\n  mutate(wykszt=if_else(is.na(wykszt), \"nieustalone\", wykszt)) %&gt;%\n  group_by(wykszt) %&gt;%\n  count()\n\n# A tibble: 4 × 2\n# Groups:   wykszt [4]\n  wykszt          n\n  &lt;chr&gt;       &lt;int&gt;\n1 nieustalone  1857\n2 podstawowe   6851\n3 srednie     23202\n4 wyzsze      13301"
  },
  {
    "objectID": "03-przetwarzanie.html#sortowanie",
    "href": "03-przetwarzanie.html#sortowanie",
    "title": "3  Przetwarzanie danych",
    "section": "3.9 Sortowanie",
    "text": "3.9 Sortowanie\nSortowanie jest możliwe z wykorzystaniem funkcji arrange(). Jako argument podajemy zmienną według, której chcemy posortować zbiór. Domyślne zbiór sortowany jest rosnąco - od wartości najmniejszych do największych:\n\nbank_sort &lt;- bank %&gt;%\n  arrange(saldo)\n\nZmiana kierunku sortowania jest możliwa po zastosowaniu funkcji desc():\n\nbank_sort &lt;- bank %&gt;%\n  arrange(desc(saldo))\n\nSortowanie możemy także zastosować do wyników podsumowania danych:\n\nbank %&gt;%\n  group_by(wykszt) %&gt;%\n  summarise(liczebnosc=n(),\n            saldo_srednia=mean(saldo),\n            saldo_mediana=median(saldo)) %&gt;%\n  arrange(saldo_srednia)\n\n# A tibble: 4 × 4\n  wykszt     liczebnosc saldo_srednia saldo_mediana\n  &lt;chr&gt;           &lt;int&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 srednie         23202         1155.           392\n2 podstawowe       6851         1251.           403\n3 &lt;NA&gt;             1857         1527.           568\n4 wyzsze          13301         1758.           577"
  },
  {
    "objectID": "03-przetwarzanie.html#łączenie-zbiorów",
    "href": "03-przetwarzanie.html#łączenie-zbiorów",
    "title": "3  Przetwarzanie danych",
    "section": "3.10 Łączenie zbiorów",
    "text": "3.10 Łączenie zbiorów\nW celu zaprezentowania funkcji łączących dane przygotujemy kilka zbiorów pomocniczych:\n\npraca_czas &lt;- bank %&gt;%\n  group_by(praca) %&gt;%\n  summarise(sr_czas=mean(czas))\n\npraca_saldo &lt;- bank %&gt;%\n  group_by(praca) %&gt;%\n  summarise(sr_saldo=mean(saldo))\n\nzawod_saldo &lt;- bank %&gt;%\n  rename(zawod=praca) %&gt;%\n  group_by(zawod) %&gt;%\n  summarise(sr_saldo=mean(saldo))\n\nDo łączenia dwóch zbiorów danych służy funkcja inner_join(), która jako argumenty przyjmuje nazwy zbiorów danych oraz klucz łączenia. Jeśli w obu zbiorach występują kolumny o takich samych nazwach to zostaną potraktowane jako klucz łączenia:\n\npraca_czas_saldo &lt;- inner_join(praca_czas, praca_saldo)\n\nJoining with `by = join_by(praca)`\n\n\nJeśli takie kolumny nie będą istniały to wywołanie funkcji zwróci błąd:\n\npraca_czas_saldo &lt;- inner_join(praca_czas, zawod_saldo)\n\nError in `inner_join()`:\n! `by` must be supplied when `x` and `y` have no common variables.\nℹ Use `cross_join()` to perform a cross-join.\n\n\nW takich przypadku należy wskazać klucz połączenia w postaci by = c(\"id1\"=\"id2\"):\n\npraca_czas_saldo &lt;- inner_join(praca_czas, zawod_saldo, by=c(\"praca\"=\"zawod\"))\n\nJeśli w jednym ze zbiorów nie ma wszystkich identyfikatorów, które znajdują się w drugim zbiorze to zastosowanie funkcji inner_join() będzie skutkowało zbiorem, w którym znajdą się tylko te obserwacje, które udało się połączyć.\n\npraca_saldo_1500 &lt;- praca_saldo %&gt;%\n  filter(sr_saldo &gt; 1500)\n\ninner_join(praca_czas, praca_saldo_1500, by=\"praca\")\n\n# A tibble: 6 × 3\n  praca sr_czas sr_saldo\n  &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n1     2    289.    1522.\n2     3    254.    1764.\n3     5    256.    1521.\n4     7    268.    1648.\n5     8    287.    1984.\n6    NA    238.    1772.\n\n\nJeśli chcemy pozostawić niedopasowane obserwacje to należy wykorzystać jedną z funkcji - left_join() lub right_join() w zależności od tego dla którego zbioru chcemy pozostawić wszystkie informacje.\n\nleft_join(praca_czas, praca_saldo_1500, by=\"praca\")\n\n# A tibble: 11 × 3\n   praca sr_czas sr_saldo\n   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n 1     1    247.      NA \n 2     2    289.    1522.\n 3     3    254.    1764.\n 4     4    246.      NA \n 5     5    256.    1521.\n 6     6    263.      NA \n 7     7    268.    1648.\n 8     8    287.    1984.\n 9     9    253.      NA \n10    10    257.      NA \n11    NA    238.    1772."
  },
  {
    "objectID": "03-przetwarzanie.html#szeroka-i-wąska-reprezentacja-danych",
    "href": "03-przetwarzanie.html#szeroka-i-wąska-reprezentacja-danych",
    "title": "3  Przetwarzanie danych",
    "section": "3.11 Szeroka i wąska reprezentacja danych",
    "text": "3.11 Szeroka i wąska reprezentacja danych\nDo wyjaśnienia kwestii szerokiej i wąskiej reprezentacji danych posłużymy się danymi z GUS dotyczącymi przeciętnego miesięcznego spożycie wybranych artykułów żywnościowych na 1 osobę w 2016 roku - plik.\n\nspozycie &lt;- read_xlsx(\"data/spozycie.xlsx\")\n\nTaka tabela jest przykładem szerokiej reprezentacji danych. Z kolei w niektórych sytuacjach wygodnie jest korzystać z wąskiej reprezentacji danych, a niektóre pakiety wręcz wymagają takich zbiorów wejściowych.\nDo transformacji danych z reprezentacji szerokiej na wąską służy funkcja gather() (pol. gromadzić). Kluczowe są w niej dwa argumenty - pierwszy (key) określa nazwę nowej kolumny, która będzie zawierała nazwy zmiennych, a drugi (value) określa nazwę nowej kolumny, która będzie zawierała wartości zmiennych. Jako kolejne argumenty podaje się nazwy kolumn, które mają być transformowane lub nazwy kolumn ze znakiem minus -, które nie mają być transformowane.\n\nspozycie_waskie &lt;- spozycie %&gt;%\n  gather(artykul, spozycie, mieso, owoce, warzywa)\n\n# spozycie_waskie &lt;- spozycie %&gt;%\n#   gather(artykul, spozycie, -kod, -nazwa)\n\nW takiej formie łatwiej podsumować dane:\n\nspozycie_waskie %&gt;%\n  group_by(artykul) %&gt;%\n  summarise(sr_spozycie=mean(spozycie))\n\n# A tibble: 3 × 2\n  artykul sr_spozycie\n  &lt;chr&gt;         &lt;dbl&gt;\n1 mieso          5.47\n2 owoce          3.65\n3 warzywa        8.85\n\n\nW porównaniu do szerokiej reprezentacji danych:\n\nspozycie %&gt;%\n  summarise(sr_spozycie_mieso=mean(mieso),\n            sr_spozycie_owoce=mean(owoce),\n            sr_spozycie_warzywa=mean(warzywa))\n\n# A tibble: 1 × 3\n  sr_spozycie_mieso sr_spozycie_owoce sr_spozycie_warzywa\n              &lt;dbl&gt;             &lt;dbl&gt;               &lt;dbl&gt;\n1              5.47              3.65                8.85\n\n\nTransformacja z wąskiej do szerokiej reprezentacji danych jest możliwa z zastosowaniem funkcji spread() (pol. rozprzestrzeniać). W przypadku tej funkcji niezbędne są dwa argumenty - pierwszy (key) wskazuje kolumnę zawierającą nazwy dla nowych zmiennych, a drugi argument (value) wskazuje kolumnę zawierającą wartości dla nowych zmiennych.\n\nspozycie_szerokie &lt;- spozycie_waskie %&gt;%\n  spread(artykul, spozycie)"
  },
  {
    "objectID": "03-przetwarzanie.html#eksport-danych",
    "href": "03-przetwarzanie.html#eksport-danych",
    "title": "3  Przetwarzanie danych",
    "section": "3.12 Eksport danych",
    "text": "3.12 Eksport danych\nZapis zbioru danych do zewnętrznego pliku jest możliwy z wykorzystaniem funkcji write.table(). Jako argumenty tej funkcji określamy: zbiór danych (x), docelowe miejsce na dysku i nazwę pliku (file), separator kolumn (sep), separator miejsc dziesiętnych (dec) oraz argument row.names = FALSE, dzięki któremu unikniemy dodatkowych numerów wierszy.\n\nwrite.table(spozycie_waskie, file = \"data/spozycie_w.csv\", sep=\";\", dec=\",\", row.names=F)\n\nTaki plik jest plikiem csv, który możemy otworzyć w Excelu i zapisać go z rozszerzeniem .xlsx. Teoretycznie istnieje pakiet xlsx, który umożliwia zapisywanie zbiorów od razu do Excela, ale działa w oparciu o Javę, co bywa problematyczne."
  },
  {
    "objectID": "03-przetwarzanie.html#zadania",
    "href": "03-przetwarzanie.html#zadania",
    "title": "3  Przetwarzanie danych",
    "section": "3.13 Zadania",
    "text": "3.13 Zadania\n\n3.13.1 Rossmann\nNa podstawie zbioru Rossmann odpowiedź na pytania:\n\nIle było sklepów o asortymencie rozszerzonym w dniu 25-02-2014?\nW jaki dzień tygodnia średnia liczba klientów była największa w sklepie nr 101?\nSklep jakiego typu charakteryzuje się największą medianą sprzedaży?\nCzy w ciągu roku odległość do najbliższego sklepu konkurencji zmieniła się dla jakiegokolwiek sklepu Rossmann?\nPołącz dane ze sklepów Rossmann z danymi o średnim kursie EUR/PLN z 2014 roku, który można pobrać ze strony NBP. Przelicz wielkość sprzedaży na złotówki.\n\n\n\n3.13.2 Wybory 2020\nNa podstawie zbioru dotyczącego wyborów prezydenckich w 2020 roku odpowiedź na pytania:\n\nIle obwodów głosowania miało frekwencję powyżej 80%?\nIle obwodów głosowania znajduje się w Poznaniu?\n\nIle jest obwodów według typu obszaru?\nJaka była średnia frekwencja w województwach?\nGdzie była największa różnica pomiędzy kandydatami?\n\n\n\n3.13.3 Mistrzostwa Świata\nNa podstawie zbioru dotyczącego wyników meczów rozegranych w ramach Mistrzostw Świata odpowiedź na pytania:\n\nIle razy Włochy grały w finale MŚ?\nJaka jest największa liczba bramek w jednym meczu?\n\nJakie miasto najczęściej gościło piłkarzy?\nJaka była średnia liczba widzów?\nIle było meczów, w których drużyna prowadząca po pierwszej połowie ostatecznie przegrywała?"
  },
  {
    "objectID": "03-przetwarzanie.html#wybory-2020",
    "href": "03-przetwarzanie.html#wybory-2020",
    "title": "3  Przetwarzanie danych",
    "section": "3.14 Wybory 2020",
    "text": "3.14 Wybory 2020\nNa podstawie zbioru dotyczącego wyborów prezydenckich w 2020 roku odpowiedź na pytania:\n\nIle obwodów głosowania miało frekwencję powyżej 80%?\nIle obwodów głosowania znajduje się w Poznaniu?\n\nIle jest obwodów według typu obszaru?\nJaka była średnia frekwencja w województwach?\nGdzie była największa różnica pomiędzy kandydatami?"
  },
  {
    "objectID": "03-przetwarzanie.html#mistrzostwa-świata",
    "href": "03-przetwarzanie.html#mistrzostwa-świata",
    "title": "3  Przetwarzanie danych",
    "section": "3.15 Mistrzostwa Świata",
    "text": "3.15 Mistrzostwa Świata\nNa podstawie zbioru dotyczącego wyników meczów rozegranych w ramach Mistrzostw Świata odpowiedź na pytania:\n\nIle razy Włochy grały w finale MŚ?\nJaka jest największa liczba bramek w jednym meczu?\n\nJakie miasto najczęściej gościło piłkarzy?\nJaka była średnia liczba widzów?\nIle było meczów, w których drużyna prowadząca po pierwszej połowie ostatecznie przegrywała?"
  },
  {
    "objectID": "01-intro.html#wprowadzenie",
    "href": "01-intro.html#wprowadzenie",
    "title": "1  Wprowadzenie do R",
    "section": "1.1 Wprowadzenie",
    "text": "1.1 Wprowadzenie\nGNU R to interpretowany język programowania oraz środowisko do obliczeń statystycznych i wizualizacji wyników [Wikipedia 2017].\nRobert A. Muenchen - The Popularity of Data Science Software"
  },
  {
    "objectID": "01-intro.html#r",
    "href": "01-intro.html#r",
    "title": "1  Wprowadzenie do R",
    "section": "1.2 R",
    "text": "1.2 R\nBazowa wersja R jest do pobrania ze strony r-project.org."
  },
  {
    "objectID": "01-intro.html#rstudio",
    "href": "01-intro.html#rstudio",
    "title": "1  Wprowadzenie do R",
    "section": "1.3 RStudio",
    "text": "1.3 RStudio\nRStudio to zintegrowane środowisko programistyczne (IDE) dla języka R dostępne za darmo na stronie RStudio.\n\nZ R można także korzystać w Microsoft Visual Studio."
  },
  {
    "objectID": "01-intro.html#ważne-informacje",
    "href": "01-intro.html#ważne-informacje",
    "title": "1  Wprowadzenie do R",
    "section": "1.4 Ważne informacje",
    "text": "1.4 Ważne informacje\nR jest wrażliwy na wielkość liter.\nSeparatorem części dziesiętnej liczby jest kropka.\nW codziennej pracy RStudio jest wygodniejsze, jednak długotrwałe obliczenia lepiej uruchamiać w trybie wsadowym w zwykłym R.\n\nKatalog roboczy\n\nWażnym pojęciem w R jest katalog roboczy (ang. working directory), który określa gdzie zostaną zapisane pliki, wykresy, zbiory, itp. jeśli nie podamy dokładnej ścieżki do pliku. Katalog roboczy przypisuje się z wykorzystaniem funkcji setwd(\"ścieżka do katalogu\"), a jego wartość można sprawdzić funkcją getwd(). W RStudio przypisanie katalogu roboczego odbywa się w momencie utworzenia projektu.\n\nProjekt\n\nKatalog na dysku, w którym znajdują się wszystkie pliki projektu wraz z plikiem o rozszerzeniu .Rproj skojarzonym z RStudio.\n\nKorzystanie z pomocy\n\nDostęp do pomocy odnośnie wybranej funkcji można uzyskać na dwa sposoby. Pierwszym z nich jest poprzedzenie nazwy funkcji w konsoli znakiem zapytania np. ?getwd lub wywołanie funkcji help na nazwie funkcji help(\"getwd\"). Drugim sposobem jest umieszczenie kursora w dowolnym miejscu nazwy funkcji i wciśnięcie klawisza F1.\nInternet - przede wszystkim stackoverflow.\n\nKomentarze\n\n\nReal programmers don’t comment their code. If it was hard to write it should be hard to understand.\n\nDobrze napisany kod jest czytelny bez komentarzy. W R komentarze rozpoczynają się od symbolu #. Skrót klawiaturowy w RStudio to CTRL + SHIFT + C (do wstawiania i usuwania komentarzy).\n\nPodpowiadanie składni\n\nRStudio ma zaimplementowaną funkcję podpowiadania składni. Listę możliwych funkcji i obiektów wywołuję się klawiszem TAB lub CTRL + SPACJA po wpisaniu co najmniej jednej litery. Kolejne naciśnięcie TAB lub ENTER powoduje uzupełnienie kodu o wybraną funkcję lub obiekt.\n\nWykonywanie programów\n\nProgramy w R możemy tworzyć jako skrypty w pliku tekstowym o rozszerzeniu .R lub wywoływać polecenia bezpośrednio w konsoli. Kod programu napisanego w skrypcie przekazywany jest do konsoli. Gotowość do pracy R sygnalizuje w konsoli znakiem zachęty &gt;. Jeśli podczas wykonywania programu w konsoli pojawi się znak + to oznacza oczekiwanie na kompletny kod - brak domkniętego nawiasu, cudzysłowia, itp.:\n&gt; getwd(\n+ \nW powyższym przykładzie brakuje prawego nawiasu. Dodanie brakującego kodu spowoduje wykonanie przekazanego polecenia. Z kolei wciśnięcie klawisza ESC spowoduje przerwanie wykonywanie programu i powrót do znaku zachęty. Zawartość konsoli można wyczyścić stosując kombinację klawiszy CTRL + L.\n\nPliki \n\nJeśli w pamięci znajdują się jakieś obiekty (zakładka Environment) to RStudio przy zamykaniu programu zapyta o zapisanie tych obiektów do pliku .RData. Jeżeli zdecydujemy się na tą propozycję to po ponownym uruchomieniu projektu obiekty znajdujące się w pliku .RData zostaną automatycznie wczytane do pamięci.\nMożna także samodzielnie tworzyć pliki o rozszerzeniu .RData z wykorzystaniem funkcji save():\nsave(obiekt1, obiekt2, obiekt3, file = \"nazwa_pliku.RData\")\nWczytanie obiektów z takiego pliku do pamięci odbywa się z zastosowaniem funkcji load():\nload(\"nazwa_pliku.RData\")"
  },
  {
    "objectID": "01-intro.html#pakiety",
    "href": "01-intro.html#pakiety",
    "title": "1  Wprowadzenie do R",
    "section": "1.5 Pakiety",
    "text": "1.5 Pakiety\nPodstawowe możliwości R są dosyć ograniczone. Rozszerzają je pakiety, których obecnie jest ponad 12 tysięcy. Można je przeglądać według kategorii w CRAN Task Views lub w wygodnej wyszukiwarce METACRAN i rdrr.io."
  },
  {
    "objectID": "01-intro.html#r-jako-kalkulator",
    "href": "01-intro.html#r-jako-kalkulator",
    "title": "1  Wprowadzenie do R",
    "section": "1.6 R jako kalkulator",
    "text": "1.6 R jako kalkulator\nDziałania matematycznie w R:\n\n\n\nOperator\nOperacja\n\n\n\n\n+\ndodawanie\n\n\n-\nodejmowanie\n\n\n*\nmnożenie\n\n\n/\ndzielenie\n\n\n^ lub **\npotęgowanie\n\n\nsqrt()\npierwiastkowanie\n\n\n\nW R istnieje także stała wbudowana pi przechowująca wartość liczby pi.\nFunkcja factorial(x) zwraca silnię (znak wykrzyknika !) z podanej wartości x, a sign(x) sprawdza znak wyrażenia i zwraca odpowiednio wartość -1 jeśli wyrażenie jest ujemne, 0 jeśli jest równe 0 i 1 dla wyrażeń dodatnich.\nFunkcja exp(x) zwraca wartość wyrażenia \\(e^x\\), natomiast funkcja log(x) zwraca logarytm z podanej liczby. Domyślnie jest to logarytm naturalny, ale można zmienić podstawę podając wartość argumentu base.\nFunkcja abs(x) zwraca wartość bezwzględną (absolutną) wyrażenia.\nĆwiczenie\nOblicz wartość wyrażenia: \\(2\\cdot \\sqrt{\\pi} + log_28\\).\nRozwiązanie:\n\n2*sqrt(pi)+log(8,2)\n\n[1] 6.544908\n\n\nZadania\nOblicz wartość wyrażeń:\n\n\\(\\frac{2^3\\cdot6^2}{(\\frac{1}{2})^2\\cdot(\\frac{4}{5})^3}\\)\n\\(\\sqrt[3]{\\frac{6-3.5}{2^{11}}}\\)\n\\(\\pi+\\sqrt{e^4}\\)\n\\(5! - log_{10}100\\)\n\\(|1-e|\\)"
  },
  {
    "objectID": "02-struktury.html#obiekty",
    "href": "02-struktury.html#obiekty",
    "title": "2  Struktury danych",
    "section": "2.1 Obiekty",
    "text": "2.1 Obiekty\nW R praktycznie wszystko jest obiektem. Może to być zbiór danych, ale także wykres czy mapa. Zasadnicza różnica to klasa tych obiektów i operacje jakie mogą być na nich wykonywane.\nFunkcje w R wymagają jako argumentów określonych typów obiektów - stąd tak ważna jak znajomość istniejących struktur.\nKażdy obiekt w R możemy przypisać do tzw. obiektu nazwanego. Wówczas jest przechowywany w pamięci i można się do niego odwołać. Przypisanie odbywa się za pomocą operatora &lt;-.\nnazwa &lt;- obiekt\nobiekt -&gt; nazwa\nMożna także przypisywać obiekty z wykorzystaniem znaku równości =, ale nie jest to zalecane ponieważ symbol ten jest używany w innych miejscach np. do deklarowania wartości argumentów w funkcji.\nW R dostępna jest funkcja assign, która także umożliwia przypisanie nazwy do obiektu:\nassign(\"nazwa\", obiekt)"
  },
  {
    "objectID": "02-struktury.html#wektor",
    "href": "02-struktury.html#wektor",
    "title": "2  Struktury danych",
    "section": "2.2 Wektor",
    "text": "2.2 Wektor\nWektor jest najprostszym typem danych w R. Najczęściej korzysta się z trzech typów wektorów:\n\nlogicznych\nliczbowych\ntekstowych\n\nWektor tworzy się z wykorzystaniem funkcji c().\n\n2.2.1 Wektor wartości logicznych\nPrzyjmuje wartości prawda lub fałsz:\n\nc(TRUE, FALSE, FALSE)\n\n[1]  TRUE FALSE FALSE\n\n\nlub w skróconej wersji:\n\nc(T, F, F)\n\n[1]  TRUE FALSE FALSE\n\n\nDo sprawdzenia długości wektora używa się funkcji length:\n\nlength(c(T, F, F))\n\n[1] 3\n\n\nlub korzystając z obiektu nazwanego:\n\nwart_log &lt;- c(T,F,F)\nlength(wart_log)\n\n[1] 3\n\n\nWektory można także utworzyć poprzez replikację określonej wartości lub wektora z wykorzystaniem funkcji rep. Funkcja ta przyjmuje co najmniej dwa argumenty: obowiązkowo x - wektor wejściowy oraz jeden z następujących: times - liczba powtórzeń elementów wektora x, each - liczba powtórzeń elementów wektora x (wyjaśnienie różnicy poniżej) lub length.out - oczekiwana długość wektora wynikowego.\nTrzy równoważne zapisy:\n\nrep(x = c(T,F), times = 3)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\nrep(c(T,F), times = 3)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\nrep(c(T,F), 3)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\n\nA tak to wygląda z argumentem each:\n\nrep(c(T,F), each = 3)\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\n\nWykorzystanie argumentu length.out:\n\nrep(c(T,F), length.out = 5)\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n\n\n\n\n2.2.2 Wektor wartości liczbowych\nW wektorze możemy przechowywać także liczby:\n\nc(1, 3, -5, 2.5, .6) # nie trzeba pisać zera przed ułamkiem\n\n[1]  1.0  3.0 -5.0  2.5  0.6\n\n\nPołączenie dwóch wektorów to także wektor:\n\nc(c(1,2,3), c(3.5,4,4.5))\n\n[1] 1.0 2.0 3.0 3.5 4.0 4.5\n\n\nPojedyncza liczba też jest jednoelementowym wektorem:\n\nlength(2)\n\n[1] 1\n\n\nProste ciągi o różnicy równej 1 można generować wykorzystując dwukropek:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nlub\n\nc(-5:-1,1:5)\n\n [1] -5 -4 -3 -2 -1  1  2  3  4  5\n\n\nDo generowania ciągów liczbowych o różnych różnicach wykorzystuje się funkcję seq, która przyjmuje następujące argumenty. Wartość początkową from, wartość końcową to oraz jeden z następujących: by - krok lub length.out - oczekiwana długość wektora.\nTo samo co 1:10\n\nseq(1, 10, 1)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWartości niecałkowite:\n\nseq(1, 2, 0.2)\n\n[1] 1.0 1.2 1.4 1.6 1.8 2.0\n\n\nWektor wartości malejących:\n\nseq(10, 1, by=1) # błędny zapis\n\nError in seq.default(10, 1, by = 1): wrong sign in 'by' argument\n\nseq(10, 1, by=-1) # poprawny zapis\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n\nTworzenie wektora w oparciu o argument length.out - funkcja sama dobiera krok:\n\nseq(1, 7, length.out = 13)\n\n [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0\n\n\nDo generowania liczb pseudolosowych służy funkcja runif(n), która do poprawnego wywołania wymaga tylko jednego argumentu - długości wektora wynikowego. Domyślnie losowane są liczby z przedziału \\([0;1]\\) (tak jak w funkcji los() w Excelu), można to jednak zmienić podając odpowiednie wartości argumentów min i max.\n\nrunif(6)\n\n[1] 0.3195719 0.1278855 0.5032706 0.9783932 0.6031072 0.6790640\n\n\nObserwacje można także generować z innych rozkładów:\n\nrnorm - rozkład normalny,\nrchisq - rozkład \\(\\chi^2\\),\nrt - rozkład t-studenta,\nitp.\n\nWykaz wszystkich dostępnych w R rozkładów uzyskamy wywołując polecenie help(\"Distributions\").\nZa każdym uruchomieniem jednej z wymienionych wyżej funkcji losujących wartości z danego rozkładu otrzymamy inne wartości:\n\nrunif(5)\n\n[1] 0.1625951 0.3835654 0.5293908 0.4157393 0.3100997\n\nrunif(5)\n\n[1] 0.8787186 0.9163193 0.9412319 0.1133653 0.1806800\n\n\nPowtarzalność wyników możemy uzyskać ustalając ziarno generatora:\n\nset.seed(123)\nrunif(5)\n\n[1] 0.2875775 0.7883051 0.4089769 0.8830174 0.9404673\n\nset.seed(123)\nrunif(5)\n\n[1] 0.2875775 0.7883051 0.4089769 0.8830174 0.9404673\n\n\n\n\n2.2.3 Wektor wartości tekstowych\nW wektorze może być przechowywany tekst - wówczas poszczególne elementy zapisujemy w cudzysłowie lub apostrofach:\n\nc(\"ala\", \"ma\", \"kota\")\n\n[1] \"ala\"  \"ma\"   \"kota\"\n\nc('ala', 'ma', 'kota')\n\n[1] \"ala\"  \"ma\"   \"kota\"\n\n\nW RStudio wygodniej używać cudzysłowu, ponieważ program automatycznie go zamyka.\nIstnieje także stała zawierająca litery alfabetu:\n\nletters\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nLETTERS\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n\n\n\n2.2.4 Przeciążanie wektora\nJeśli w wektorze pomieszamy kilka typów zmiennych to R przekształci poszczególne wartości, tak aby stracić jak najmniej informacji:\n\nc(TRUE, 2, 5)\n\n[1] 1 2 5\n\nc(3, \"cztery\", 5)\n\n[1] \"3\"      \"cztery\" \"5\"     \n\n\nW pierwszym przypadku wartość TRUE została przekształcona na odpowiednik liczbowy - 1. Z kolei w drugim przykładzie podane liczby zostały przekonwertowane na tekst.\n\n\n2.2.5 Operacje na wektorach\nNa wektorach logicznych i liczbowych można wykonywać operacje arytmetyczne np. mnożenie:\n\n1:10*2\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\nWektor liczbowy plus wektor liczbowy:\n\n1:10 + c(1,2)\n\n [1]  2  4  4  6  6  8  8 10 10 12\n\n\nWektor liczbowy razy wektor liczbowy:\n\n1:10 * c(1,2)\n\n [1]  1  4  3  8  5 12  7 16  9 20\n\n\nWektor liczbowy razy wektor logiczny:\n\n1:10 * c(T, F)\n\n [1] 1 0 3 0 5 0 7 0 9 0\n\n\nDługości obu wektorów muszą być odpowiednie:\n\n1:10 * c(T,F,T)\n\nWarning in 1:10 * c(T, F, T): longer object length is not a multiple of shorter\nobject length\n\n\n [1]  1  0  3  4  0  6  7  0  9 10\n\n\nDłuższy z wektorów musi być wielokrotnością krótszego.\nSiłą rzeczy działania arytmetyczne na wektorach tekstowych nie są możliwe:\n\nc(\"jeden\", \"dwa\", \"trzy\", \"cztery\") * c(T,F)\n\nError in c(\"jeden\", \"dwa\", \"trzy\", \"cztery\") * c(T, F): non-numeric argument to binary operator\n\nc(\"jeden\", \"dwa\", \"trzy\", \"cztery\") + c(1,2)\n\nError in c(\"jeden\", \"dwa\", \"trzy\", \"cztery\") + c(1, 2): non-numeric argument to binary operator\n\n\n\n\n2.2.6 Operacje agregujące\nNa wektorach można także wykonywać operacje agregujące:\n\n\n\nFunkcja\nDziałanie\n\n\n\n\nmean()\nśrednia elementów\n\n\nsum()\nsuma elementów\n\n\nprod()\niloczyn elementów\n\n\nvar()\nwariancja elementów\n\n\nsd()\nodchylenie standardowe elementów\n\n\nmedian()\nmediana elementów\n\n\nquantile()\nkwantyl danego rzędu\n\n\nmin()\nminimum\n\n\nmax()\nmaksimum\n\n\n\nObliczenie skośności i kurtozy jest możliwe po zainstalowaniu pakietu e1071. Wówczas mamy dostęp do funkcji:\n\n\n\nFunkcja\nDziałanie\n\n\n\n\nskewness()\nskośność elementów\n\n\nkurtosis()\nkurtoza elementów\n\n\n\nSuma wektora numerycznego:\n\nsum(1:10)\n\n[1] 55\n\n\nSuma i średnia wektora logicznego:\n\nsum(c(T, F, F, T))\n\n[1] 2\n\nmean(c(T, F, F, T))\n\n[1] 0.5\n\n\nKorzystanie z funkcji pochodzących z pakietów zewnętrznych wymaga wskazania skąd pochodzi dana funkcja. Można to zrobić na dwa sposoby: funkcją library(pakiet) - wówczas wszystkie funkcje z tego pakietu są wczytywane do pamięci i można do nich sięgać bezpośrednio lub wskazując przed nazwą funkcji z jakiego pakietu pochodzi.\nWczytanie pakietu:\n\nlibrary(e1071)\nskewness(c(1,2,3,4,5,7,9,11,13))\n\n[1] 0.3451259\n\n\nlub równoważnie:\n\ne1071::skewness(c(1,2,3,4,5,7,9,11,13))\n\n[1] 0.3451259\n\n\nPodsumowanie rozkładu wektora można także uzyskać z wykorzystaniem funkcji summary(x):\n\nsummary(1:10)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    3.25    5.50    5.50    7.75   10.00 \n\n\nDziała także na wektorach tekstowych:\n\nsummary(c(\"jeden\", \"dwa\", \"trzy\", \"cztery\"))\n\n   Length     Class      Mode \n        4 character character \n\n\n\n\n2.2.7 Sprawdzanie typu wektora\nDo określenia typu wektora służy funkcja typeof, class lub mode.\n\ntypeof(wart_log)\n\n[1] \"logical\"\n\n\nSprawdzenie czy obiekt jest danego typu odbywa się z wykorzystaniem dedykowanych funkcji z przyrostkiem is.\n\nis.logical(wart_log)\n\n[1] TRUE\n\nis.character(wart_log)\n\n[1] FALSE\n\n\n\n\n2.2.8 Rzutowanie wektorów\nCzasami jako np. argument funkcji będzie wymagany inny typ wektora aniżeli aktualnie posiadany w pamięci. Można wówczas spróbować przekształcić taki wektor z wykorzystaniem funkcji rozpoczynającej się od as.:\n\ntypeof(wart_log)\n\n[1] \"logical\"\n\nas.numeric(wart_log)\n\n[1] 1 0 0\n\ntypeof(as.numeric(wart_log))\n\n[1] \"double\"\n\n\n\n\n2.2.9 Indeksowanie wektorów\nAby uzyskać dostęp do części wektora korzysta się z indeksatora w postaci nawiasów kwadratowych. Utworzymy nowy wektor zawierający liczby całkowite od 10 do 20:\n\nwart_10_20 &lt;- seq(10,20)\nwart_10_20\n\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\na następnie wybieramy trzecią obserwację:\n\nwart_10_20[3]\n\n[1] 12\n\n\nMożemy także odwołać się do większego zakresu:\n\nwart_10_20[3:5]\n\n[1] 12 13 14\n\n\nI wybranych elementów:\n\nwart_10_20[c(1,3,5)]\n\n[1] 10 12 14\n\n\nW ten sposób można także modyfikować odpowiednie elementy wektora:\n\nwart_10_20[7] &lt;- 90\n\nWybór obserwacji większych od 15:\n\nwart_10_20[wart_10_20&gt;15]\n\n[1] 90 17 18 19 20\n\n\nZ kolei następujący zapis zwróci nam wektor wartości logicznych:\n\nwart_10_20 &gt; 15\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n\n2.2.10 Wartości nieliczbowe\nBrak danych w R jest przedstawiany jako wartość NA (ang. not available) i może powodować trudności z wywoływaniem niektórych funkcji:\n\nv_na &lt;- c(1,2,1,NA,1)\nv_na\n\n[1]  1  2  1 NA  1\n\nsum(v_na)\n\n[1] NA\n\n\nW związku z tym większość funkcji ma zaimplementowany dodatkowy argument służący do obsługi tego typu wartości, który najczęściej nie uwzględnia tych wartości w obliczeniach:\n\nsum(v_na, na.rm = TRUE)\n\n[1] 5\n\n\nOprócz braku danych podczas obliczeń możemy natrafić na wartości nieokreślone NaN (ang. not a number) oraz nieskończone Inf (ang. infinity).\n\n0/0\n\n[1] NaN\n\n1/0\n\n[1] Inf\n\nsqrt(-10)\n\nWarning in sqrt(-10): NaNs produced\n\n\n[1] NaN\n\n\nW R istnieje także wartość NULL, która jest podstawowym typem danych a nie wartością. NULL można traktować jako odpowiednik zbioru pustego. Jest stosowany np. w funkcjach, które niczego nie zwracają.\n\nv_null &lt;- c(1,2,1,NULL,1)\nv_null\n\n[1] 1 2 1 1\n\nsum(v_null)\n\n[1] 5\n\n\n\n\n2.2.11 Zadania\n\nIle wynosi suma elementów większych od 10 dla następujących liczb: 12, 5, 20, 18, 8.5, 10, 4, 101, -2?\nZ wykorzystaniem funkcji seq i na podstawie wektora … dokonaj przekształcenia tworząc następujący wektor: 2 0 0 4 0 0 6 0 0 8 0 0.\nDane są dwa wektory - a: 2, 3, 7, 8, 2, b: 9, 1, 2, 0, 2. Jakiego typu będzie wektor będący wynikiem działania a&lt;=b?\nUzupełnij wektor letters o polskie litery diakrytyzowane. Jaką długość ma nowo utworzony wektor?\nWylosuj z rozkładu normalnego 1000 obserwacji z ziarnem równym 76. Ile wynosi kurtoza tych wartości?"
  },
  {
    "objectID": "02-struktury.html#macierz",
    "href": "02-struktury.html#macierz",
    "title": "2  Struktury danych",
    "section": "2.3 Macierz",
    "text": "2.3 Macierz\nMacierze są wykorzystywane w R do przechowywania np. odległości pomiędzy punktami czy wskazywania sąsiedztwa obszarów geograficznych.\nDo tworzenia macierzy służy funkcja matrix:\n\nm &lt;- matrix(1:6, nrow = 2, ncol=3)\nm\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nZ wykorzystaniem wybranych funkcji można sprawdzić wymiary macierzy, liczbę wierszy oraz kolumn:\n\ndim(m)\n\n[1] 2 3\n\nncol(m)\n\n[1] 3\n\nnrow(m)\n\n[1] 2\n\n\nMacierz może także zawierać tekst:\n\nmatrix(letters[1:9], nrow=3)\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"d\"  \"g\" \n[2,] \"b\"  \"e\"  \"h\" \n[3,] \"c\"  \"f\"  \"i\" \n\n\nDomyślnie macierz układana jest kolumnami. Aby to zmienić należy dodać argument byrow=TRUE:\n\nmatrix(letters[1:9], nrow=3, byrow=TRUE)\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"b\"  \"c\" \n[2,] \"d\"  \"e\"  \"f\" \n[3,] \"g\"  \"h\"  \"i\" \n\n\nJeśli liczba elementów wejściowych jest mniejsza iloczyn podanej liczby kolumn i wierszy to w brakujące miejsce wstawiane są elementy z początku wektora wejściowego:\n\nmatrix(letters[1:7], nrow=3, byrow=TRUE)\n\nWarning in matrix(letters[1:7], nrow = 3, byrow = TRUE): data length [7] is not\na sub-multiple or multiple of the number of rows [3]\n\n\n     [,1] [,2] [,3]\n[1,] \"a\"  \"b\"  \"c\" \n[2,] \"d\"  \"e\"  \"f\" \n[3,] \"g\"  \"a\"  \"b\" \n\n\nZ kolei macierz diagnonalną posiadającą elementy niezerowe wyłącznie na przekątnej tworzy się z wykorzystaniem funkcji diag. Macierz jednostkowa o wymiarach \\(4 \\times 4\\):\n\ndiag(4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    0    0\n[2,]    0    1    0    0\n[3,]    0    0    1    0\n[4,]    0    0    0    1\n\n\nMacierz diagonalna o wartościach 5 na przekątnej i wymiarach \\(3 \\times 3\\)\n\ndiag(5, nrow=3, ncol=3)\n\n     [,1] [,2] [,3]\n[1,]    5    0    0\n[2,]    0    5    0\n[3,]    0    0    5\n\n\nFunkcja diag umożliwia także ekstrakcję przekątnej z istniejącej już macierzy:\n\ndiag(matrix(letters[1:9], nrow=3))\n\n[1] \"a\" \"e\" \"i\"\n\n\n\n2.3.1 Łączenie macierzy\nZ wykorzystaniem funkcji rbind i cbind można odpowiednio łączyć obiekty wierszami (ang. row bind) lub kolumnami (ang. col bind):\n\nrbind(m, c(99, 88, 77))\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n[3,]   99   88   77\n\ncbind(m, matrix(101:104, nrow=2))\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5  101  103\n[2,]    2    4    6  102  104\n\n\n\n\n2.3.2 Indeksowanie macierzy\nDostęp do poszczególnych elementów macierzy odbywa się z wykorzystaniem nawiasów kwadratowych, ale można podać dwie wartość - obiekt[wiersz,kolumna]:\n\nm[2,1] # drugi wiersz, pierwsza kolumna\n\n[1] 2\n\nm[2,]  # tylko drugi wiersz\n\n[1] 2 4 6\n\nm[,1]  # tylko pierwsza kolumna\n\n[1] 1 2\n\nm[,]   # wszystkie obserwacje\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nm[]    # wszystkie obserwacje\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nW ten sposób można dokonać modyfikacji konkretnych elementów macierzy:\n\nm[2,1] &lt;- 77\nm\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]   77    4    6\n\n\n\n\n2.3.3 Operacje na macierzach\nNa macierzach można wywołać szereg operacji:\n\n\n\nOperator/funkcja\nDziałanie\n\n\n\n\na %*% b\nmnożenie macierzy a i b\n\n\nt(a)\ntranspozycja macierzy a\n\n\ndet(a)\nwyznacznik macierzy a\n\n\nsolve(a)\nmacierz odwrotna z a\n\n\nsolve(a, b)\nrozwiązanie układu a*x=b\n\n\n\nRozważmy dwie macierze:\n\na &lt;- matrix(c(2, 3, 4, 2, 1, 2, 1, 3, 2), nrow = 3)\nb &lt;- matrix(6:1, ncol=2)\na;b\n\n     [,1] [,2] [,3]\n[1,]    2    2    1\n[2,]    3    1    3\n[3,]    4    2    2\n\n\n     [,1] [,2]\n[1,]    6    3\n[2,]    5    2\n[3,]    4    1\n\n\nAby przeprowadzić mnożenie macierzy a i b, liczba kolumn macierzy a musi być równa liczbie wierszy w macierzy b. Z kolei rozmiar macierzy wyjściowej to liczba wierszy macierzy a i liczba kolumn macierzy b.\n\na %*% b\n\n     [,1] [,2]\n[1,]   26   11\n[2,]   35   14\n[3,]   42   18\n\n\nTranspozycja macierzy b:\n\nt(b)\n\n     [,1] [,2] [,3]\n[1,]    6    5    4\n[2,]    3    2    1\n\n\nWyznacznik macierzy a:\n\ndet(a)\n\n[1] 6\n\n\nMacierz odwrotna do macierzy a:\n\nsolve(a)\n\n           [,1]       [,2]       [,3]\n[1,] -0.6666667 -0.3333333  0.8333333\n[2,]  1.0000000  0.0000000 -0.5000000\n[3,]  0.3333333  0.6666667 -0.6666667\n\n\nWyznaczenie macierzy x w równaniu a*x=b:\n\nsolve(a,b)\n\n          [,1]      [,2]\n[1,] -2.333333 -1.833333\n[2,]  4.000000  2.500000\n[3,]  2.666667  1.666667\n\na %*% solve(a,b)\n\n     [,1] [,2]\n[1,]    6    3\n[2,]    5    2\n[3,]    4    1\n\nb\n\n     [,1] [,2]\n[1,]    6    3\n[2,]    5    2\n[3,]    4    1\n\n\n\n\n2.3.4 Zadanie\n\nCo powstanie po przemnożeniu macierzy przez jej macierz odwrotną?\nEstymator parametrów beta w metodzie najmniejszych kwadratów jest dany wzorem:\n\n\\[b=(X'X)^{-1}X'y\\]\nZmienna \\(x_1\\) przyjmuje wartości 2,4,1,6,9,3,2,9,10,7, zmienna \\(x_2\\) 1.5,0.2,0.1,2,3.1,1.2,0.4,2.9,2.5,1.9, a zmienna \\(x_0\\) to wektor jedynek. Te trzy zmienne tworzą macierz \\(X\\). Z kolei wartości zmiennej \\(y\\) są następujące 12,15,10,19,26,13,13,21,29,18. Wyznacz wartość \\(b\\).\n\nzad1 &lt;- matrix(1:4, nrow=2)\nsolve(zad1)\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\nzad1 %*% solve(zad1)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1"
  },
  {
    "objectID": "02-struktury.html#czynnik",
    "href": "02-struktury.html#czynnik",
    "title": "2  Struktury danych",
    "section": "2.4 Czynnik",
    "text": "2.4 Czynnik\nCzynnik (ang. factor) służy do przechowywania danych jakościowych o mało licznej liczbie kategorii, mierzonych na skali nominalnej i porządkowej.\nRozważmy informacje o wykształceniu:\n\nwyk &lt;- rep(c(\"podstawowe\", \"średnie\", \"wyższe\"), c(5,3,2))\nwyk\n\n [1] \"podstawowe\" \"podstawowe\" \"podstawowe\" \"podstawowe\" \"podstawowe\"\n [6] \"średnie\"    \"średnie\"    \"średnie\"    \"wyższe\"     \"wyższe\"    \n\n\ni dokonajmy transformacji na czynnik:\n\nwyk_f &lt;- factor(wyk)\nwyk_f\n\n [1] podstawowe podstawowe podstawowe podstawowe podstawowe średnie   \n [7] średnie    średnie    wyższe     wyższe    \nLevels: podstawowe średnie wyższe\n\n\nFunkcja summary() wywołana na czynniku zwraca wynik innego typu aniżeli na wektorze tekstowym:\n\nsummary(wyk)\n\n   Length     Class      Mode \n       10 character character \n\nsummary(wyk_f)\n\npodstawowe    średnie     wyższe \n         5          3          2 \n\n\nJeśli chcemy zaakcentować fakt, że zmienne są mierzone na skali porządkowej dodajemy argument ordered=TRUE:\n\nwyk_of &lt;- factor(wyk, ordered = TRUE)\nwyk_of\n\n [1] podstawowe podstawowe podstawowe podstawowe podstawowe średnie   \n [7] średnie    średnie    wyższe     wyższe    \nLevels: podstawowe &lt; średnie &lt; wyższe\n\n\nW łatwy sposób możemy edytować etykiety:\n\nlevels(wyk_of) &lt;- c(\"pod.\", \"śr.\", \"wyż.\")\nwyk_of\n\n [1] pod. pod. pod. pod. pod. śr.  śr.  śr.  wyż. wyż.\nLevels: pod. &lt; śr. &lt; wyż.\n\n\nCzynniki mają szczególne znaczenie w przypadku tworzenia wykresów, gdy chcemy określić porządek wyświetlania."
  },
  {
    "objectID": "02-struktury.html#lista",
    "href": "02-struktury.html#lista",
    "title": "2  Struktury danych",
    "section": "2.5 Lista",
    "text": "2.5 Lista\nListy to ciągi złożone z elementów o dowolnych typach. Mogą przydać się w szczególności przy budowaniu funkcji, które zwracają tylko jedną wartość. Wówczas dane różnego typu mogą być zawarte w takiej liście.\nTworzenie prostej listy:\n\nl &lt;- list(TRUE, c(1,2,3,4), \"element tekstowy\")\nl\n\n[[1]]\n[1] TRUE\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] \"element tekstowy\"\n\n\nJuż na pierwszy rzut oka widać bardziej złożoną strukturę listy. W związku z tym odwoływanie do poszczególnych elementów będzie trochę się różnić od wektorów czy macierzy.\n\nl[2] # druga lista\n\n[[1]]\n[1] 1 2 3 4\n\nl[[2]] # zawartość listy\n\n[1] 1 2 3 4\n\nl[[2]][3] # trzeci element wektora drugiej listy\n\n[1] 3\n\n\nListę można także rozwinąć do wektora z wykorzystaniem funkcji unlist:\n\nunlist(l)\n\n[1] \"TRUE\"             \"1\"                \"2\"                \"3\"               \n[5] \"4\"                \"element tekstowy\"\n\n\nPoszczególne elementy listy można nazwać:\n\nln &lt;- list(log=TRUE, num=c(1,2,3,4), tekst=\"element tekstowy\")\nln\n\n$log\n[1] TRUE\n\n$num\n[1] 1 2 3 4\n\n$tekst\n[1] \"element tekstowy\"\n\n\nWówczas można uzyskać do nich dostęp poprzez symbol $ i podaną nazwę:\n\nln$num\n\n[1] 1 2 3 4\n\nln[[2]] # normalne indeksowanie nadal działa\n\n[1] 1 2 3 4\n\nln$num[2]\n\n[1] 2"
  },
  {
    "objectID": "02-struktury.html#ramka-danych",
    "href": "02-struktury.html#ramka-danych",
    "title": "2  Struktury danych",
    "section": "2.6 Ramka danych",
    "text": "2.6 Ramka danych\nRamka danych to tabela, która przypomina tą z Excela zawierająca dane o różnych typach. Tworzona za pomocą funkcji data.frame:\n\ndf &lt;- data.frame(plec=c(\"m\", \"k\", \"k\", \"m\", \"k\", \"m\", \"m\", \"m\"),\n                 wzrost=c(173, 170, 163, 178, 169, 180, 175, NA),\n                 pali=c(T, F, F, F, T, F, NA, T))\n\nW RStudio po wybraniu tego obiektu w zakładce Environment pojawia się przyjazne okno do przeglądania oraz poglądowego filtrowania i sortowania danych ze zbioru.\nMożemy zobaczyć podsumowanie całego zbioru wywołując na nim funkcję summary():\n\nsummary(df)\n\n     plec               wzrost         pali        \n Length:8           Min.   :163.0   Mode :logical  \n Class :character   1st Qu.:169.5   FALSE:4        \n Mode  :character   Median :173.0   TRUE :3        \n                    Mean   :172.6   NA's :1        \n                    3rd Qu.:176.5                  \n                    Max.   :180.0                  \n                    NA's   :1                      \n\n\nRamki danych można indeksować w taki sam sposób jak macierze lub z wykorzystaniem operatora $:\n\ndf[,2] # druga kolumna\n\n[1] 173 170 163 178 169 180 175  NA\n\ndf$wzrost # kolumna wzrost\n\n[1] 173 170 163 178 169 180 175  NA\n\ndf[,c(\"plec\", \"pali\")]\n\n  plec  pali\n1    m  TRUE\n2    k FALSE\n3    k FALSE\n4    m FALSE\n5    k  TRUE\n6    m FALSE\n7    m    NA\n8    m  TRUE\n\n\nZ kolei do wyboru obserwacji można wykorzystać warunek:\n\ndf[df$plec==\"m\",]\n\n  plec wzrost  pali\n1    m    173  TRUE\n4    m    178 FALSE\n6    m    180 FALSE\n7    m    175    NA\n8    m     NA  TRUE\n\n\nWyodrębnienie informacji o wzroście tylko dla kobiet i wyznaczenie średniej:\n\nwzrost_k &lt;- df$wzrost[df$plec == \"k\"]\nwzrost_k\n\n[1] 170 163 169\n\nmean(wzrost_k)\n\n[1] 167.3333\n\n\nWidzimy, że dla mężczyzn nie udało się ustalić wszystkich informacji i jeden z nich nie ma podanego wzrostu, a dla drugiego brakuje informacji o paleniu papierosów. Możemy usunąć braki danych w kolumnach korzystając z funkcji complete.cases():\n\ndf[complete.cases(df$wzrost),] # tylko zmienna wzrost\n\n  plec wzrost  pali\n1    m    173  TRUE\n2    k    170 FALSE\n3    k    163 FALSE\n4    m    178 FALSE\n5    k    169  TRUE\n6    m    180 FALSE\n7    m    175    NA\n\ndf[complete.cases(df),] # wszystkie zmienne\n\n  plec wzrost  pali\n1    m    173  TRUE\n2    k    170 FALSE\n3    k    163 FALSE\n4    m    178 FALSE\n5    k    169  TRUE\n6    m    180 FALSE\n\n\nZbiory danych przechowywane są także w R i pochodzą z różnych pakietów. Wywołując funkcję data(\"zbior\") ładujemy dany zbiór do pamięci. Do szybkiego podglądu zebranych danych służy funkcja head(), która domyślnie wyświetla 6 pierwszych obserwacji ze zbioru:\n\ndata(\"iris\")\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\n\n2.6.1 Zadania\nZaładuj do pamięci zbiór o nazwie ChickWeight.\n\nIle razy jedzenie otrzymał kurczak o numerze 15?\nIle wynosi mediana wagi kurczaka o numerze 35?\nIle średnio ważyły kurczaki na diecie nr 1, a ile na diecie nr 2?"
  },
  {
    "objectID": "04-wizualizacja.html#wprowadzenie",
    "href": "04-wizualizacja.html#wprowadzenie",
    "title": "4  Wizualizacja danych",
    "section": "4.1 Wprowadzenie",
    "text": "4.1 Wprowadzenie\nBędziemy działać na zbiorze dotyczącym sprzedaży w sklepach: rossmann.xlsx i rossmann.RData.\n\nlibrary(tidyverse)\n\n# library(readxl)\n# \n# rossmann &lt;- read_xlsx(\"data/rossmann.xlsx\")\n#\n# save(rossmann, file=\"data/rossmann.RData\")\n\n# natywny format, mniejszy rozmiar, szybsze wczytywanie\nload(\"data/rossmann.RData\")\n\nsklep77 &lt;- rossmann %&gt;%\n  filter(sklep_id==77, czy_otwarty==\"Tak\")\n\nDo prostych wykresów można wykorzystać wbudowaną funkcję plot.\n\nplot(sklep77$sprzedaz, sklep77$liczba_klientow, \n     xlab = \"Sprzedaż\", ylab = \"Liczba klientów\",\n     main = \"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\")\n\n\n\n\nJej możliwości są jednak ograniczone i stworzenie bardziej zaawansowanych grafik będzie wymagające.\nWiodącym pakietem do wizualizacji danych w R jest ggplot2:\n\ndokumentacja: https://ggplot2.tidyverse.org/\ncheatsheet\ntworzenie wykresów poprzez dodawanie (+) kolejnych warstw"
  },
  {
    "objectID": "04-wizualizacja.html#wykres-punktowy",
    "href": "04-wizualizacja.html#wykres-punktowy",
    "title": "4  Wizualizacja danych",
    "section": "4.2 Wykres punktowy",
    "text": "4.2 Wykres punktowy\nTen sam wykres co wcześniej, ale z wykorzystaniem pakietu ggplot2.\n\n\n\n\n\nWykonanie krok po kroku:\n\nUtworzenie siatki - określenie co chcemy na wykresie przedstawić\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow))\n\n\n\n\nW zależności od typu wykresu w funkcji aes mogą znaleźć się argumenty:\n\nx\ny\nfill\nsize\ncolor\nshape\n\n\nOkreślenie w jaki sposób chcemy te dane przedstawić - funkcja zawsze zaczyna się od geom_:\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point()\n\n\n\n\n\nEdytowanie etykiet osi - funkcje xlab i ylab:\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\")\n\n\n\n\n\nDodanie tytułu - funkcja ggtitle\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\")\n\n\n\n\n\nZmiana motywu - funkcja rozpoczynająca się od theme_:\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\nDostępne motywy:\n\ntheme_bw\ntheme_classic\ntheme_dark\ntheme_gray\ntheme_light\ntheme_linedraw\ntheme_minimal\ntheme_void\n\nPowyższe motywy są zaimplementowane w pakiecie ggplot2, ale można także skorzystać z dodatkowych pakietów:\n\ntheme_bbc\ntheme_xkcd\n\nAlbo stworzyć swój własny motyw.\nZadanie\nZmień motyw wykresu na wybrany przez siebie.\nDodamy teraz do wykresu kolejną cechę - rozpoczęcie promocji, żeby sprawdzić czy istnieje jakaś tendencja.\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\nOkazuje się dosyć interesująco, niemniej nazwa etykiety legendy nie wygląda zbyt dobrze. Żeby to poprawić musimy użyć funkcji scale_\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  xlab(\"Sprzedaż\") +\n  ylab(\"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\nW funkcji scale_ musimy podać w jaki sposób daną cechę wizualizujemy (x/y/color/…) oraz jakiego jest typu. Oprócz nazwy w tej funkcji możemy określić wiele innych kwestii takich jak:\n\nwyświetlane etykiety\npoczątek i koniec osi\nkolory wariantów\netykiety wariantów\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light()\n\n\n\n\nZmiana pozycji legendy możliwa jest z wykorzystaniem funkcji theme:\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\nggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "04-wizualizacja.html#histogram",
    "href": "04-wizualizacja.html#histogram",
    "title": "4  Wizualizacja danych",
    "section": "4.3 Histogram",
    "text": "4.3 Histogram\nRozkład cechy można ocenić na podstawie histogramu - domyślnie rysowanych jest 30 słupków.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nW funkcji geom_histogram można podać liczbę słupków (bins) albo ich szerokość (binwidth). Poniżej zastosowano słupki o szerokości 1000 euro.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 1000)\n\n\n\n\nDodatkowo w tej funkcji można określić kwestie estetyczne - kolory obramowania i wypełnienia słupków.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 500, color = \"black\", fill = \"green\")\n\n\n\n\nPełna lista nazw kolorów znajduje się tutaj.\nZ wykorzystaniem funkcji scale_ zmieniamy nazwy osi (name), granice (limits) oraz wskazania liczbowe (breaks). Te dwie ostatnie wartości musimy deklarować jako wektory z wykorzystaniem funkcji c().\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 500, \n                 color = \"black\", fill = \"green\") +\n  scale_x_continuous(name = \"Sprzedaż\", \n                     limits = c(4000,17000),\n                     breaks = c(5000, 8000, 11000)) +\n  scale_y_continuous(name = \"Liczebność\",\n                     limits = c(0,50))\n\nWarning: Removed 2 rows containing missing values (`geom_bar()`).\n\n\n\n\n\nMożna zaumatyzować proces dobierania wskazań liczbowych z wykorzystaniem funkcji seq opisanej szerzej w rozdziale 2.1.2.\n\nggplot(data = sklep77, aes(x=sprzedaz)) +\n  geom_histogram(binwidth = 500, \n                 color = \"black\", fill = \"green\") +\n  scale_x_continuous(name = \"Sprzedaż\", \n                     limits = c(4000,17000),\n                     breaks = seq(4000, 17000, 1500)) +\n  scale_y_continuous(name = \"Liczebność\",\n                     limits = c(0,50))\n\nWarning: Removed 2 rows containing missing values (`geom_bar()`)."
  },
  {
    "objectID": "04-wizualizacja.html#wykres-pudełkowy",
    "href": "04-wizualizacja.html#wykres-pudełkowy",
    "title": "4  Wizualizacja danych",
    "section": "4.4 Wykres pudełkowy",
    "text": "4.4 Wykres pudełkowy\nWykres pudełkowy umożliwia porównywanie rozkładów cechy wg zmiennej grupującej. Wymogiem jest aby na osi x znajdowała się zmienna grupująca, a na osi y cecha analizowana.\nPrzeanalizujemy sprzedaż według kolejnych dni tygodnia.\n\nggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) + geom_boxplot()\n\nWarning: Continuous x aesthetic\nℹ did you forget `aes(group = ...)`?\n\n\n\n\n\nZdecydowanie nie jest wykres jakiego oczekiwaliśmy. Wynika to z faktu, że dzień tygodnia w zbiorze danych jest zapisany jako zmienna numeryczna, natomiast prawidłowym typem dla zmiennej grupującej jest typ tekstowy lub czynnik (faktor). Ten typ danych został szczegółowo opisany w części 2.3.\nDokonujemy zatem zamiany typu danych:\n\nsklep77 &lt;- sklep77 %&gt;%\n  mutate(dzien_tyg=factor(x = dzien_tyg,\n                          levels = 1:6,\n                          labels = c(\"Pon\", \"Wt\", \"Śr\", \"Czw\", \"Pt\", \"Sob\"),\n                          ordered = TRUE))\n\nggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) +\n  geom_boxplot() \n\n\n\n\nZ tego wykresu można już odczytać, że najwyższa mediana sprzedaży występuje w poniedziałek, a najniższa w środę.\nJeżli kategorii jest dużo to można obrócić wykres z wykorzystaniem funkcji coord_flip.\n\nggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) +\n  geom_boxplot() +\n  coord_flip()\n\n\n\n\nUżycie tej funkcji powoduje wyłącznie obrócenie wykresu. Nazwy osi nie uległy zmianie pomimo, że zostały zamienione. Odwrócimy jeszcze kolejność etykiet dnia tygodnia, tak aby na górze był poniedziałek.\n\nggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) +\n  geom_boxplot() +\n  coord_flip() +\n  scale_x_discrete(limits = rev(levels(sklep77$dzien_tyg)))"
  },
  {
    "objectID": "04-wizualizacja.html#wykres-słupkowy",
    "href": "04-wizualizacja.html#wykres-słupkowy",
    "title": "4  Wizualizacja danych",
    "section": "4.5 Wykres słupkowy",
    "text": "4.5 Wykres słupkowy\nW zależności od typu danych wejściowych, wykres słupkowy można stworzyć na dwa sposoby:\n\ndane jednostkowe - geom_bar - funkcja sama oblicza wartości do wyświetlenia,\ndane zagregowane - geom_col - funkcja otrzymuje już obliczone wartości.\n\nSprawdźmy ile jest sklepów o danym asortymencie. W tym celu potrzebujemy informację o sklepie i typie oferowanego asortymentu.\n\nrossmann_asort &lt;- rossmann %&gt;%\n  select(sklep_id, sklep_asort) %&gt;%\n  distinct()\n\nglimpse(rossmann_asort)\n\nRows: 1,115\nColumns: 2\n$ sklep_id    &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18,…\n$ sklep_asort &lt;chr&gt; \"Podstawowy\", \"Podstawowy\", \"Podstawowy\", \"Rozszerzony\", \"…\n\n\nW funkcji aes podajemy tylko kolumnę zawierającą dane do zliczenia.\n\nggplot(rossmann_asort, aes(x=sklep_asort)) +\n  geom_bar()\n\n\n\n\nNatomiast użycie funkcji geom_col wymaga samodzielnego obliczenia wartości:\n\nrossmann_asort2 &lt;- rossmann_asort %&gt;%\n  count(sklep_asort)\n\nglimpse(rossmann_asort2)\n\nRows: 3\nColumns: 2\n$ sklep_asort &lt;chr&gt; \"Extra\", \"Podstawowy\", \"Rozszerzony\"\n$ n           &lt;int&gt; 9, 593, 513\n\n\nWartość do wyświetlenia podajemy w funkcji aes w argumencie y.\n\nggplot(rossmann_asort2, aes(x=sklep_asort, y=n)) +\n  geom_col()\n\n\n\n\nUporządkujemy etykiety osi x (obecnie są wyświetlane w kolejności alfabetycznej) tworząc czynnik.\n\nrossmann_asort2 &lt;- rossmann_asort2 %&gt;%\n  mutate(sklep_asort=factor(x = sklep_asort,\n                            levels = c(\"Podstawowy\", \n                                       \"Rozszerzony\", \n                                       \"Extra\"), \n                            ordered = T))\n\nglimpse(rossmann_asort2)\n\nRows: 3\nColumns: 2\n$ sklep_asort &lt;ord&gt; Extra, Podstawowy, Rozszerzony\n$ n           &lt;int&gt; 9, 593, 513\n\n\n\nggplot(rossmann_asort2, aes(x=sklep_asort, y=n)) +\n  geom_col()\n\n\n\n\nDo wykresu słupkowego możemy dodać jeszcze jedną zmienną. W tym przypadku będzie to typ sklepu.\n\nrossmann_asort3 &lt;- rossmann %&gt;%\n  select(sklep_id, sklep_asort, sklep_typ) %&gt;%\n  distinct() %&gt;%\n  count(sklep_asort, sklep_typ) %&gt;%\n  mutate(sklep_asort=factor(x = sklep_asort,\n                            levels = c(\"Podstawowy\", \n                                       \"Rozszerzony\", \n                                       \"Extra\"), \n                            ordered = T))\n\nglimpse(rossmann_asort3)\n\nRows: 9\nColumns: 3\n$ sklep_asort &lt;ord&gt; Extra, Podstawowy, Podstawowy, Podstawowy, Podstawowy, Roz…\n$ sklep_typ   &lt;chr&gt; \"b\", \"a\", \"b\", \"c\", \"d\", \"a\", \"b\", \"c\", \"d\"\n$ n           &lt;int&gt; 9, 381, 7, 77, 128, 221, 1, 71, 220\n\n\nUwzględnienie kolejnej zmiennej jest możliwe jako argument fill w funkcji aes.\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col()\n\n\n\n\nDomyślnie kategorie są układane jedna na drugą - stack. Można je ułożyć obok siebie dodając argument position = \"dodge\" w funkcji geom_col.\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col(position = \"dodge\")\n\n\n\n\nMożemy jeszcze dodać etykiety słupków wykorzystując funkcję geom_text, w której trzeba podać argumenty definujące położenie wartości etykiet. Wartości tych argumentów będą zależały od typu wykresu.\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col(position = \"dodge\") + \n  geom_text(aes(label = n), \n            position = position_dodge(width = 0.9),\n            vjust = -0.3)\n\n\n\n\nZmienimy jeszcze nazwę legendy za pomocą funkcji scale_fill_discrete. Wykorzystujemy tę konkretną funkcję ze względu na to, że typ sklepu jest argumentem fill w funkcji aes oraz cechą jakościową (discrete).\n\nggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) +\n  geom_col(position = \"dodge\") + \n  geom_text(aes(label = n), \n            position = position_dodge(width = 0.9),\n            vjust = -0.3) +\n  scale_fill_discrete(name = \"Typ sklepu\")"
  },
  {
    "objectID": "04-wizualizacja.html#wykres-kafelkowy",
    "href": "04-wizualizacja.html#wykres-kafelkowy",
    "title": "4  Wizualizacja danych",
    "section": "4.6 Wykres kafelkowy",
    "text": "4.6 Wykres kafelkowy\nDo wizualizacji tabeli częstości można użyć wykresu kafelkowego. W tym celu najpierw zliczamy wystąpienia wariantów cech czy_promocja oraz czy_swieto_szkolne i wynik przekazujemy bezpośrednio do funkcji ggplot().\n\nsklep77 %&gt;%\n  count(czy_promocja, czy_swieto_szkolne) %&gt;%\n  ggplot(aes(x = czy_promocja, \n             y = czy_swieto_szkolne,\n             fill = n)) +\n  geom_tile()\n\n\n\n\nAby dodać do tego wykresu etykiety posłużymy się funkcją geom_label()\n\nsklep77 %&gt;%\n  count(czy_promocja, czy_swieto_szkolne) %&gt;%\n  ggplot(aes(x = czy_promocja, \n             y = czy_swieto_szkolne,\n             fill = n)) +\n  geom_tile() +\n  geom_label(aes(label = n), color = \"white\")\n\n\n\n\nZwykle patrząc na wykres podświadomie zakładamy, że ciemniejszy kolor oznacza wyższe wartości, natomiast jasny małe liczby. W tym przypadku układ kolorów jest odwrócony. Musimy odpowiednio dobrać kolory, aby to poprawić. Bardzo przydatne narzędzie znajduje się pod adresem: http://colorbrewer2.org/. Następnie korzystamy z funkcji scale_fill_gradient, w której określamy tylko kolor początkowy i końcowy.\n\nsklep77 %&gt;%\n  count(czy_promocja, czy_swieto_szkolne) %&gt;%\n  ggplot(., aes(x = czy_promocja, \n                y = czy_swieto_szkolne,\n                fill = n)) +\n  geom_tile() +\n  geom_label(aes(label = n), color = \"white\") +\n  scale_fill_gradient(low = \"#66c2a4\", \n                      high = \"#005824\")"
  },
  {
    "objectID": "04-wizualizacja.html#uwzględnienie-czasu",
    "href": "04-wizualizacja.html#uwzględnienie-czasu",
    "title": "4  Wizualizacja danych",
    "section": "4.7 Uwzględnienie czasu",
    "text": "4.7 Uwzględnienie czasu\nPróba stworzenia wykresu przedstawiającego zmianę sprzedaży w czasie za pomocą oryginalnych danych spowoduje uzsykanie niezbyt czytelnej grafiki.\n\nggplot(sklep77, aes(x=data,\n                    y=sprzedaz,\n                    color=dzien_tyg)) +\n  geom_point()\n\n\n\n\nWynika to z faktu, że dzien tygodnia jest traktowany jak zmienna numeryczna, a data jest zmienną tekstową. Konwersja tekstu na datę jest możliwa z wykorzystaniem pakietu lubridate. W tym pakiecie każda część daty ma swój akronim, który później jest wykorzystywany w odpowiednich funkcjach:\n\ny - rok (year)\nm - miesiąc (month)\nd - dzień (day)\nh - godzina (hour)\nm - minuta (minute)\n\nPrzykłady funkcji:\n\nymd - konwertuje tekst zapisany w postaci rok-miesiąc-dzień na obiekt daty\ndmy_hm - konwertuje tekst zapisany w postaci dzień-miesiąc-rok godzina:minuta na obiekt daty\nmonth - pobiera z obiektu daty informację o miesiącu\nyear - pobiera z obiektu daty informację o roku\nweek - pobiera z obiektu daty informację o tygodniu roku\n\nWedług powyższych reguł korzystamy z funkcji ymd() do konwersji daty w naszym zbiorze.\n\nlibrary(lubridate)\n\nsklep77a &lt;- sklep77 %&gt;%\n  mutate(dzien_tyg=as.factor(dzien_tyg),\n         data=ymd(data))\n\nggplot(sklep77a, aes(x=data,\n                    y=sprzedaz,\n                    color=dzien_tyg)) +\n  geom_point()"
  },
  {
    "objectID": "04-wizualizacja.html#facets",
    "href": "04-wizualizacja.html#facets",
    "title": "4  Wizualizacja danych",
    "section": "4.8 Facets",
    "text": "4.8 Facets\n\nsr_sprzedaz &lt;- rossmann %&gt;%\n  filter(sprzedaz &gt; 0) %&gt;%\n  group_by(sklep_id, sklep_asort) %&gt;%\n  summarise(sprzedaz_sr=mean(sprzedaz))\n\n`summarise()` has grouped output by 'sklep_id'. You can override using the\n`.groups` argument.\n\nodleglosc &lt;- rossmann %&gt;%\n  select(sklep_id, sklep_konkurencja) %&gt;%\n  distinct()\n\nsprzedaz_odleglosc &lt;- inner_join(sr_sprzedaz, odleglosc, by=\"sklep_id\")\n\nggplot(sprzedaz_odleglosc, aes(x=sprzedaz_sr, y=sklep_konkurencja)) + \n  geom_point() +\n  facet_wrap(~ sklep_asort)\n\nWarning: Removed 3 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsr_sprzedaz_prom &lt;- rossmann %&gt;%\n  filter(sprzedaz &gt; 0) %&gt;%\n  group_by(sklep_id, czy_promocja) %&gt;%\n  summarise(sprzedaz_sr=mean(sprzedaz))\n\n`summarise()` has grouped output by 'sklep_id'. You can override using the\n`.groups` argument.\n\nsprzedaz_prom_odl &lt;- inner_join(sr_sprzedaz_prom, odleglosc)\n\nJoining with `by = join_by(sklep_id)`\n\nhead(sprzedaz_prom_odl)\n\n# A tibble: 6 × 4\n# Groups:   sklep_id [3]\n  sklep_id czy_promocja sprzedaz_sr sklep_konkurencja\n     &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;             &lt;dbl&gt;\n1        1 Nie                4288.              1270\n2        1 Tak                5274.              1270\n3        2 Nie                3902.               570\n4        2 Tak                6295.               570\n5        3 Nie                5286.             14130\n6        3 Tak                8790.             14130\n\nggplot(sprzedaz_prom_odl, aes(x=sprzedaz_sr, y=sklep_konkurencja, color=czy_promocja)) + \n  geom_point()\n\nWarning: Removed 6 rows containing missing values (`geom_point()`).\n\n\n\n\n\nZamiana reprezentacji danych na szeroką.\n\nsprzedaz_prom_odl_wide &lt;- sprzedaz_prom_odl %&gt;%\n  spread(czy_promocja, sprzedaz_sr)\n\nhead(sprzedaz_prom_odl_wide)\n\n# A tibble: 6 × 4\n# Groups:   sklep_id [6]\n  sklep_id sklep_konkurencja   Nie    Tak\n     &lt;dbl&gt;             &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1        1              1270 4288.  5274.\n2        2               570 3902.  6295.\n3        3             14130 5286.  8790.\n4        4               620 9030. 10686.\n5        5             29910 3473.  6084.\n6        6               310 4189.  6295.\n\n\nI na wąską.\n\nsprzedaz_prom_odl_long &lt;- sprzedaz_prom_odl_wide %&gt;%\n  gather(czy_promocja, sprzedaz_sr, Nie, Tak)\n\nhead(sprzedaz_prom_odl_long)\n\n# A tibble: 6 × 4\n# Groups:   sklep_id [6]\n  sklep_id sklep_konkurencja czy_promocja sprzedaz_sr\n     &lt;dbl&gt;             &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;\n1        1              1270 Nie                4288.\n2        2               570 Nie                3902.\n3        3             14130 Nie                5286.\n4        4               620 Nie                9030.\n5        5             29910 Nie                3473.\n6        6               310 Nie                4189."
  },
  {
    "objectID": "04-wizualizacja.html#wykres-interaktywny",
    "href": "04-wizualizacja.html#wykres-interaktywny",
    "title": "4  Wizualizacja danych",
    "section": "4.9 Wykres interaktywny",
    "text": "4.9 Wykres interaktywny\nZa pomocą pakietu plotly w prosty sposób można zamienić statystyczny wykres ggplot na interaktywny.\n\nlibrary(plotly)\n\np &lt;- ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) +\n  geom_point() +\n  scale_x_continuous(name = \"Sprzedaż\") +\n  scale_y_continuous(name = \"Liczba klientów\") +\n  scale_color_discrete(name = \"Promocja\") +\n  ggtitle(\"Sprzedaż i liczba klientów w sklepie Rossmann nr 77\") +\n  theme_light() +\n  theme(legend.position = \"bottom\")\n\nplotly::ggplotly(p)"
  },
  {
    "objectID": "05-programowanie.html#instrukcje-warunkowe",
    "href": "05-programowanie.html#instrukcje-warunkowe",
    "title": "5  Programowanie w R",
    "section": "5.1 Instrukcje warunkowe",
    "text": "5.1 Instrukcje warunkowe\nZa pomocą instrukcji if możemy warunkowo wykonywać kod. Ogólna postać jest następująca:\nif(warunek){\n  # kod wykonany jeśli warunek jest równy TRUE\n} else if(warunek) {\n  # kod wykonany jeśli warunek jest równy TRUE\n} else {\n  # kod wykonany jeśli warunek jest równy FALSE\n}\nElement warunek musi zwracać wartość logiczną TRUE albo FALSE. Chcąć uwzględnić więcej niż jeden warunek należy wykorzystać odpowiedni operator łączenia:\n\ni : &&\nlub : ||"
  },
  {
    "objectID": "05-programowanie.html#funkcje",
    "href": "05-programowanie.html#funkcje",
    "title": "5  Programowanie w R",
    "section": "5.2 Funkcje",
    "text": "5.2 Funkcje\nFunkcję ograniczają potrzebę kopiowania kodu i ułatwiają wprowadzanie zmian.\nStworzenie funkcji wymaga:\n\nwymyślenia nazwy funkcji,\nokreślenia elementów wejściowych,\numieszczenia kodu w ciele funkcji.\n\nIstnieją pewne dobre praktyki tworzenia funkcji:\n\nnazwy funkcji powinny być czasownikami,\npodkreślnik vs. notacja camelCase i konsekwencja stosowania,\nwspólny przedrostek np. rnorm, runif."
  },
  {
    "objectID": "05-programowanie.html#pętle",
    "href": "05-programowanie.html#pętle",
    "title": "5  Programowanie w R",
    "section": "5.3 Pętle",
    "text": "5.3 Pętle\nPętlę są wykorzystywane w sytuacji, w której chcemy powtórzyć wykonanie kodu."
  },
  {
    "objectID": "04-wizualizacja.html#zadania",
    "href": "04-wizualizacja.html#zadania",
    "title": "4  Wizualizacja danych",
    "section": "4.10 Zadania",
    "text": "4.10 Zadania\nWykonaj polecenia znajdujące się na stronie."
  },
  {
    "objectID": "05-programowanie.html#zadania",
    "href": "05-programowanie.html#zadania",
    "title": "5  Programowanie w R",
    "section": "5.4 Zadania",
    "text": "5.4 Zadania\nWykonaj polecenia znajdujące się na stronie."
  }
]